# 随手记

## RSA握手解析

**TLS第一次握手**：client hello(TLS版本、随机数、支持的密码套件列表)

**TLS第二次握手**：server hello(确认支持TLS的版本、随机数、选择的密码套件)

选择的密码套件示例：TLS_RSA_WITH_AES_128_GCM_SHA256(密钥交换算法+签名算法+对称加密算法+摘要算法)

忽略TLS，WITH单词前面只有RSA一个单词(一般有两个)，说明握手时密钥交换算法和签名算法都是使用RSA；

握手后的通信使用AES对称算法，密钥长度128，分组模式是GCM；

摘要算法SHA256用于消息认证和产生随机数。

client和server所生成的两个随机数是后续作为生成【会话密钥】的条件，会话密钥就是数据传输时，所使用的对称加密密钥。

**server certificate：server发送数字证书给client。**

server hello done：server通知client该发送的东西都已经发送，本次server hello过程结束。

客户端验证数字证书

数字证书包含公钥、持有者信息、证书认证机构信息、CA对这份文件的数字签名及使用的算法、证书有效期、额外信息等。

证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。

为了让服务端的公钥被大家信任，服务端的证书都是由 CA （Certificate Authority，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。

**之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改**。

数字证书的签发和验证流程：

CA签发：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的**私钥**将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了数字签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端验证：

- 首先客户端会使用同样的 Hash 算法获取文件证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的**公钥**解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

证书链：

证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的。

客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。

请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。

“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。
这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。

**TLS第三次握手**：

client生成一个新的随机数pre-master，用server的RSA公钥加密该随机数，通过change cipher key exchange消息发给server。

server收到，用自己的RSA私钥解密，拿到pre-master。

**至此，客户端和服务端双方都共享了三个随机数，分别是 Client Random(明文)、Server Random(明文)、pre-master(非对称加密)**。

于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。

参考口令加密算法，用户口令加上随机salt得到最终AES加密和解密使用的key，那这里就是用三个随机数来得到加密和解密的key。

双方生成会话密钥后，client发送【change cipher spec】告诉服务端开始使用加密方式发送消息。

客户端再发【Encrypted Handshake Message（Finishd）】消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。

**TLS第四次握手**：

服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

最后，就用「会话密钥」加解密 HTTP 请求和响应了。

## ECDHE握手解析

使用 RSA 密钥协商算法的最大问题是不支持**前向保密**。因为客户端传递随机数pre-master（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

DH密钥参考廖雪峰密钥交换算法。

客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公式算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。

DH 密钥交换过程中，即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，**而且每一次对称加密密钥都是实时生成的**，实现前向保密。

但因为 DH 算法的计算效率问题，后面出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。

ECDHE

1. 双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；
2. 双方各自随机生成一个随机数作为私钥d，并与基点 G 相乘得到公钥Q（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；
3. 双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥。

**这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）**。

1. 第一次握手：客户端发送TLS版号、支持的套件、**随机数**。
2. 第二次握手：服务端发送确认的版号、确认的套件、**随机数**。
    - 举例：TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        - 密钥协商算法用ECDHE；
        - 签名算法用RSA；
        - 对称通信用AES，密钥长度256，分组模式是GCM；
        - 摘要算法用SHA384。
3. 服务端发送数字证书给客户端。
4. 服务端发送`server key exchange`消息给客户端。
    - **椭圆曲线**，相当于椭圆曲线**基点G**也定好了
    - 一个随机数作为椭圆曲线的私钥，保留在服务端
    - 根据基点G和私钥计算椭圆曲线的**公钥**
    - 服务端用RSA私钥对椭圆曲线公钥做签名
5. 服务端发送`server hello done`消息给客户端。
6. 客户端验证数字证书真实性。
7. 第三次握手：客户端发送`client key exchange`消息给服务端
    - 一个随机数作为客户端椭圆曲线的私钥
    - 生成客户端椭圆曲线的公钥
8. 至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线公钥、椭圆曲线基点G，于是计算出坐标(x,y)，这里的x坐标值双方是一致的，但这还不是最后的会话密钥。
9. 最终的会话密钥，用”客户端随机数+服务端随机数+x“三个部分组成。
10. 算好本地会话密钥后，客户端发送`change chipher spec`消息告诉服务端后续改用对称算法加密通信。
11. 客户端发送`encrypted handshake message`消息，把之前发送的数据做摘要，再用对称密钥加密一下，让服务端做验证，看看本次生成的会话密钥是否可用。
12. 第四次握手：服务端同样发送`change chipher spec`和`encrypted handshake message`消息。

使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。

ECDHE 相比 RSA 握手过程省去了一个消息往返的时间，这个有点「抢跑」的意思，它被称为是「TLS False Start」，跟「TCP Fast Open」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。

TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384：

- 密钥协商算法使用 ECDHE；
- 签名算法使用 RSA；
- 握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；
- 摘要算法使用 SHA384；

server发送完证书后会再发送一个【Server Key Exchange】消息：

- 选择了名为 named_curve 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；
- 生成随机数作为服务端椭圆曲线的私钥，保留到本地；
- 根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。

为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。

随后才是【Server Hello Done】消息

至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥，这几个信息很重要，是后续生成会话密钥的材料。

客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「Client Key Exchange」消息发给服务端。

至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，但实际应用中，x 还不是最终的会话密钥。

最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。

之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算出最终的会话密钥，安全性更高。

区别：

- RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；
- 使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；
- 使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；

## 优化HTTPS

### 分析性能损耗

1. TLS协议握手有性能损耗
2. 握手后的对称加密报文传输有性能损耗(实际上非常小)

对于第一步，握手过程不仅增加了可能长达2RTT的网络时延，并且一些步骤也会产生性能损耗，比如：

- ECDHE密钥协商算法，每次握手都需要临时生成椭圆曲线的公私钥；
- 验证证书时，需要访问CA，验证证书是否被吊销；
- 双方计算pre-master，也就是对称加密密钥。

### 硬件优化

HTTPS 协议是计算密集型，⽽不是 I/O 密集型，所以不能把钱花在⽹卡、硬盘等地⽅，应该花在 CPU 上。

如果可以，应该选择可以⽀持 AES-NI 特性的 CPU，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。

如果我们的 CPU ⽀持 AES-NI 特性，那么对于对称加密的算法应该选择 AES 算法。否则可以选择 ChaCha20 对称加密算法，因为 ChaCha20 算法的运算指令相⽐ AES 算法会对 CPU 更友好⼀点。

### 软件优化

升级内核版本，升级OpenSSL版本，但是软件升级对于有成百上千服务器的公司来说跟硬件问题一样也是一个棘手的问题。

### 会话复用

TLS 握⼿的⽬的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把⾸次 TLS 握⼿协商的对称加密密钥**缓存**起来，待下次需要建⽴ HTTPS 连接时，直接「复⽤」这个密钥，不就减少 TLS 握⼿的性能损耗了吗？

【session ID】

**客户端和服务器⾸次 TLS 握⼿连接后，双⽅会在内存缓存会话密钥，并⽤唯⼀的 Session ID 来标识**，Session ID 和会话密钥相当于 key-value 的关系。

缺点：1.服务端内存压力大，2.客户端不一定命中上次访问过的服务端(多台服务器负载均衡的情况下)。

【session ticket】

**服务器不再缓存每个客户端的会话密钥，⽽是把缓存的⼯作交给了客户端**，类似于 HTTP 的 Cookie。

**对于集群服务器的话，要确保每台服务器加密 「会话密钥」的密钥是⼀致的**，这样客户端携带 Ticket 访问任意⼀台服务器时，都能恢复会话。

**避免重放攻击的⽅式就是需要对会话密钥设定⼀个合理的过期时间**。

【pre-shared key】

**对于重连 TLS1.3 只需要 0 RTT，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求⼀同发送给服务端，这种⽅式叫 Pre-shared Key**。

### 协议优化

对【密钥交换过程】进行优化：

TLS 1.2 版本如果使⽤的是 RSA 密钥交换算法，那么需要 4 次握⼿，也就是要花费 2 RTT，才可以进⾏应⽤数据的传输，⽽且 RSA 密钥交换算法不具备前向安全性。

总之使⽤ RSA 密钥交换算法的 TLS 握⼿过程，不仅慢，⽽且安全性也不⾼。

因此如果可以，尽量选⽤ ECDHE 密钥交换算法替换 RSA 算法，因为该算法由于⽀持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握⼿后，第 4 次握⼿前，发送加密的应⽤数据，以此将 TLS 握⼿的消息往返由 2 RTT 减少到 1 RTT，⽽且安全性也⾼，具备前向安全性。

同的椭圆曲线性能也不同，应该尽量选择 x25519 曲线，该曲线是⽬前最快的椭圆曲线。

对于对称加密算法⽅⾯，如果对安全性不是特别⾼的要求，可以选⽤ AES_128_GCM，它⽐ AES_256_GCM 快⼀些，因为密钥的⻓度短⼀些。

对【TLS协议】进行升级：

TLS 1.3 ⼤幅度简化了握⼿的步骤，完成 TLS 握⼿只要 1 RTT，⽽且安全性更⾼。

在 TLS 1.2 的握⼿中，⼀般是需要 4 次握⼿，先要通过 Client Hello （第 1 次握⼿）和 Server Hello（第 2 次握⼿） 消息协商出后续使⽤的加密算法，再互相交换公钥（第 3 和 第 4 次握⼿），然后计算出最终的会话密钥。

**TLS 1.3 把 Hello 和公钥交换这两个消息合并成了⼀个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握⼿**。具体的做法是，客户端在 Client Hello 消息⾥带上了⽀持的椭圆曲线，以及这些椭圆曲线对应的公钥。

服务端收到后，选定⼀个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双⽅⼿上已经有⽣成会话密钥的材料了，于是客户端计算出会话密钥，就可以进⾏应⽤数据的加密传输了。

### 证书优化

【证书传输】优化：

对于服务器的证书应该选择椭圆曲线（ECDSA）证书，⽽不是 RSA 证书，因为在相同安全强度下， ECC 密钥⻓度⽐ RSA 短的多。

【证书验证】优化：

OCSP Stapling，其原理是：服务器向 CA 周期性地查询证书状态，获得⼀个带有时间戳和签名的响应结果并缓存它。

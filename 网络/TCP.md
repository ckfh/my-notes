# 随手记

## TCP重传、滑动窗口、流量控制、拥塞控制

### 重传机制

TCP针对数据包丢失的情况，会采用超时重传的机制解决。

**超时重传**：定时器，重传时间RTO应略大于报文往返RTT的值，根据公式设定RTO的初始值，而又需要重传的时候，TCP的策略是超时间隔加倍。

问题：超时触发重传存在的问题是，超时周期可能相对较长。

**快速重传**：不以时间为驱动，而是以数据驱动重传。快速重传的工作方式是当收到三个相同的ACK报文时，会在“定时器过期”之前，重传丢失的报文段。

问题：重传的时候，是重传之前的一个，还是重传所有的问题。为了解决不知道重传哪些TCP报文，于是有了SACK方法。

因为ACK报文确认的是未到达的那一个报文，如果发送方一次性发送多个报文，第一个报文丢失，即使后面的报文到达了，接收方发送的ACK包也是丢失报文的ACK包，所以问题是重传丢失的那一个，还是重传丢失报文之后的所有报文，因为后面报文也没有ACK包。

**SACK**：在TCP头部选项字段里加一个SACK字段，它可以将缓存的区间发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。**比如发送方在收到三个同样的ACK时，会查看SACK中的缺失区间，然后重传该区间内的数据**。

**D-SACK**：使用了SACK来告诉「发送方」有哪些数据被重复接收了。重复接收是因为接收方返回的ACK包丢失了，导致客户端**超时重传**，发送了相同的数据包。

1. 假如接收方ACK丢失导致发送方**超时重传**相同的数据包，接收方发现接收到相同的数据包，于是在SACK字段中填入数据包区间，告诉发送方这区间的数据包已经被接受了，发送方查看返回的报文首段中ACK的序号已经超过SACK的区间了，就表示这个SACK的内容已经被接收方接收了，从而知道是接收方的ACK报文丢失导致自己超时重传。
2. 当由于网络延时，某个包在网络中滞留，后续包正常发送，此时发送方收到三个相同的ACK，因此**快速重传**滞留的包，而之前滞留的包最后到达了服务端，接收方发现数据被重复接收，接收方在SACK中填入数据包区间，发送方接收到包时，发现接收方收到了重复包，但发送方也知道快速重传触发的包不是丢失，也不是回应的ACK丢了，而是网络延时了。

D-SACK：

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的ACK包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

### 滑动窗口

无需等待确认应答，而可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

累计确认和累计应答，就是说接收方对于之前某个报文的ACK包遗失了，也没关系，直接发送最新的ACK包给发送方，发送方也知道自己之前发送的报文都被接收了。

TCPWindow字段，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过TCP报文中的Windows字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

### 流量控制

TCP提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。

当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。

TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。

**流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么**。

**拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络，造成网络瘫痪**。

## TCP实战抓包分析

### TCP三次握手异常情况实战分析

第一次握手SYN丢包：

当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 tcp_syn_retries 值后，客户端不再发送 SYN 包。

第二次握手SYN、ACK丢包：

当 TCP 第二次握手 SYN、ACK 包丢了后，客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。

客户端 SYN 包超时重传的最大次数，是由 tcp_syn_retries 决定的，默认值是 6 次；服务端 SYN、ACK 包时重传的最大次数，是由 tcp_synack_retries 决定的，默认值是 5 次。(5.8.0)

第三次握手ACK丢包：

会导致服务端重传SYN、ACK包，服务端在重传SYN、ACK包超过指定次数后，**会主动中止此次的TCP连接**。

客户端收到SYN、ACK包，进入ESTABLISHED状态，如果此时使用telnet命令向服务端推送数据，会一直超时重传相同的数据包，共重传15次，该次数由 tcp_retries2 参数决定，此时telnet会断开连接。

如果客户端不发送数据，什么时候才会断开处于 ESTABLISHED 状态的连接？保活机制。

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个「探测报文」，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

- net.ipv4.tcp_keepalive_time=7200：2小时内没有任何连接的活动，启动保活机制。
- net.ipv4.tcp_keepalive_intvl=75：每次探测间隔为75秒。
- net.ipv4.tcp_keepalive_probes=9：探测9次。

也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。

小结：

在建立 TCP 连接时，如果第三次握手的 ACK，服务端无法收到，则服务端就会短暂处于 SYN_RECV 状态，而客户端会处于 ESTABLISHED 状态。

由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过tcp_synack_retries 值（默认值 5 次）后，服务端就会断开 TCP 连接。

而客户端则会有两种情况：

1. 如果客户端没发送数据包，一直处于 ESTABLISHED 状态，然后经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接，于是客户端连接就会断开连接。
2. 如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 tcp_retries2 值（默认值 15 次）后，客户端就会断开 TCP 连接。

### TCP快速建立连接

如果第三次握手不携带数据，则一次HTTP请求需要2.5个RTT，如果第三次握手携带数据(HTTP GET)，则需要2个RTT，下次HTTP GET，同样需要2.5和2个RTT。

FAST OPEN第一次需要2个RTT(SYN/SYN+ACK+COOKIE/ACK+HTTP GET/DATA)，之后每一次只需要1个RTT(SYN+COOKIE+HTTP GET/SYN+ACK+DATA)。

服务端在第二次握手产生一个Cookie（已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 Cookie ，所以第一次发起 HTTP GET 请求的时候，还是需要 2 个 RTT 的时延；

在下次请求的时候，客户端在 SYN 包带上 Cookie 发给服务端，就提前可以跳过三次握手的过程，因为 Cookie 中维护了一些信息，服务端可以从 Cookie **获取 TCP 相关的信息**，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；

注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断重复 TCP Fast Open 直至服务器认为Cookie 无效（通常为过期）。

该 Cookie 是通过将服务器秘密持有的密钥应用于客户端的块密码生成的，生成了一个第三方难以伪造的认证标签，即使他们可以伪造源IP地址或从其他IP地址向同一服务器进行双向连接。

虽然它使用加密技术来生成 Cookie，但TFO并不是为了提供比它所取代的三方握手更多的安全性，也不会对产生的TCP连接提供任何形式的加密保护，或对任何一个端点提供身份保证。它也不打算抵御中间人攻击。如果需要抵御这种攻击，它可以与TLS或IPsec等加密协议结合使用。

### TCP流量控制

零窗口通知和窗口探测。

假设接收方处理数据的速度跟不上接收数据的速度，缓存就会被占满，从而导致接收窗口为 0，当发送方接收到零窗口通知时，就会停止发送数据。

接着，发送方会定时发送窗口大小探测报文，以便及时知道接收方窗口大小的变化。

这些窗口探测报文时间间隔是翻倍递增的。

如何在包里看出发送窗口的大小。

很遗憾，没有简单的办法，发送窗口虽然是由接收窗口决定，但是它又可以被网络因素影响，也就是拥塞窗口，实际上发送窗口是值是 min(拥塞窗口，接收窗口)。

发送窗口和 MSS 有什么关系。

发送窗口决定了一口气能发多少字节，而 MSS 决定了这些字节要分多少包才能发完。

发送方在一个窗口发出 n 个包，是不是需要 n 个 ACK 确认报文？不一定，因为 TCP 有累计确认机制，所以当收到多个数据包时，只需要应答最后一个数据包的 ACK 报文就可以了。

### TCP延迟确认与Nagle算法

Nagle算法

1. 没有已发送未确认报文时，立刻发送数据。
2. 存在未确认报文时，直到「没有已发送未确认报文」或「数据长度达到 MSS 大小」时，再发送数据。

只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。

也就是说Nagle算法会囤积正要发送的数据直到上一个发送数据的确认报文到达。

Nagle 算法一定会有一个小报文，也就是在最开始的时候。

Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。

可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）。

延迟确认(注意和滑动窗口中接收方的累计确认相区别))

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

当 TCP 延迟确认 和 Nagle 算法混合使用时，会导致时耗增长

因为Nagle算法需要等待上一个报文的ACK报文，而TCP延迟确认又延迟了上一个报文的ACK报文。

很明显，这两个同时使用会造成额外的时延，这就会使得网络"很慢"的感觉。

1. 要不发送方关闭 Nagle 算法
2. 要不接收方关闭 TCP 延迟确认

## TCP半连接队列和全连接队列

SYN队列和ACCEPT队列。

全连接队列满载：

后续到达的客户端ACK包就被DROP，也就是说客户端此时处于连接状态，但是服务端这边已经放弃了连接。

除了DROP操作外，还可以选择服务端发送一个RST包给客户端，即通知客户端应当关闭此次连接。

如果客户端想要知道是不是服务端全连接队列满导致的连接丢失，可以设置 tcp_abort_on_overflow 参数为1，如果在客户端异常中可以看到很多connection reset by peer的错误，则可以确定是服务端TCP全连接队列溢出的问题。

但通常情况下应该设置为0，有利于应对突发流量，也就是服务端只是短期内导致全连接队列溢出，一段时间后，客户端再次接收到的报文由于含有ACK，因此仍会触发服务端成功建立连接，提高建立连接的成功率。

TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，前者是内核参数，后者是服务端listen函数的参数。

半连接队列满载：

客户端一直发送第一次握手的SYN包，但是接收到服务端的SYN、ACK包后，不向服务端发送ACK包，这样会使得服务端有大量的处于SYN_RECV状态的TCP连接，这其实也就是所谓的 SYN 洪泛、SYN 攻击、DDos 攻击。

满载时，后续连接的处理策略：

如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；

若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；

如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于(max_syn_backlog >> 2)，则会丢弃；

半连接队列最大值不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系。

开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接。

syncookies是这么做的：服务器根据当前状态计算出一个值，放在己方发出的SYN+ACK报文中发出，当客户端返回ACK报文时，取出该值验证，如果合法，就认为连接建立成功

几种防御 SYN 攻击的方法：

- 增大半连接队列；
- 开启tcp_syncookies功能，不开启的情况下，服务端对每一个SYN包的连接都立即分配存储空间，开启后，只有在第三次握手ACK中携带正确的cookie，才进行存储空间的分配。
- 减少 SYN+ACK 重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

## TCP内核参数

SYN全称也叫同步序列号，客户端发送SYN包时，序列号为随机初始化，服务端发送SYN、ACK包时，除了对客户端的序列号进行确认，返回ACK=客户端序列号+1，表示接下去希望收到这个序列号为起点的包，同时自己也会随机初始化一个序列号给到客户端，客户端发送ACK包时，里面就附带了ACK=服务端序列号+1的信息。

### 三次握手性能提升

- 客户端：适当调低SYN包的重试次数，尽快把错误暴露给上层应用。
- 服务端：服务端SYN_RECV状态优化，网络繁忙时，可以增大SYN、ACK包的重试次数，反之可以调小次数。
- 如果accept函数处理不及时，就会导致accept队列溢出，导致建立好的连接被丢弃。
- 绕过三次握手，使用TCP fast open，减少了握手带来的 1 个 RTT 的时间消耗，必须保证客户端和服务端同时开启。

### 四次握手性能提升

### 传输数据性能提升

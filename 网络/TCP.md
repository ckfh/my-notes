# 随手记

## TCP-IP网络模型

### 应用层

应⽤层只需要专注于为⽤户提供应⽤功能，不⽤去关⼼数据是如何传输的。

应⽤层是⼯作在操作系统中的⽤户态，传输层及以下则⼯作在内核态。

### 传输层

提供”端口“概念，帮助实现应⽤到应⽤的通信。

TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅。

应用数据如果超过MSS(TCP最大报文段长度)，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重传这⼀个分块，⽽不⽤重新发送整个数据包。

UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，**但它实时性相对更好，传输效率也⾼**。

### 网络层

如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚。

⽹络层负责将数据从网络中⼀个主机传输到另一网络中另⼀个主机。

### 链路层

借助路由器上的路由表以及ARP协议，实现一个设备到另一个设备的数据传输。

### 物理层

提供二进制传输服务。

## TCP分割数据

MTU=IP头部+TCP头部+数据(这部分最大长度就是MSS)

MTU是一个IP包的最大长度，以太网中一般为1500字节；MSS是除去IP和TCP头部之后，一个网络包所能容纳的TCP数据最大长度。

TCP数据会被以MSS的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。

### 既然IP层会分片，为什么TCP层还需要MSS呢？

先说结论，IP层分片传输，非常没有效率。

如果TCP整个报文，包括头部和数据，都交给IP层来分片，如果一个IP分片丢失，整个IP报文的所有分片都需要重传，因为IP本身没有超时重传机制，它依赖TCP来负责超时和重传。

接收方发现TCP报文的某一片丢失后，不会响应ACK给发送方，发送方在超时后，会重发”整个“TCP报文。

**为了达到最佳传输效能，TCP协议在建立连接时通常需要协商双方的MSS值，当TCP层发现数据超过MSS时，则主动进行分片，由它形成的IP包长度自然也不会超过MTU了，IP包就不需要分片了**。

## TCP长连接和心跳那些事

[参考](https://mp.weixin.qq.com/s/cwqAMPku-LwXAGM3Cqztig)

要点：

- TCP协议本身并没有长短连接的区别，长短与否，完全在于我们如何使用它。
- 通过Linux命令查看到的连接状态处于`ESTABLISHED`并不是一件靠谱的事。
    - 虽然双方建立了连接，但因为网络问题，链路不通，或者连接已经“死”了，却没有被系统感知到。
- TCP的KeepAlive机制是在网络层保证了连接的可用性，但这对于应用框架层面来说还不够。
    - 开关虽然可以在应用层开启，但是具体的参数设置却是操作系统级别的，对于应用不够灵活。
    - 这个保活机制只在**链路空闲**的情况下才会起作用，假设此时有数据发送，但是链路不通，操作系统这边的链路状态还是`ESTABLISHED`，就会触发TCP的超时重传，指数退避算法也是一个漫长的过程。
    - KeepAlive本身是**面向网络**的，而不是面向应用的，当连接不可用时，可能是因为应用本身的GC问题或者是系统load高问题，但网络依然是畅通的，此时，应用失去了活性，所以连接自然应该认为不可用。
- 应用层的连接保活是有必要的。
    - 心跳请求应该和普通请求区别对待，例如使用标志字段进行区分。
- HTTP协议中的KeepAlive和TCP协议中的KeepAlive是两个概念。
    - 前者在于连接复用，同一个连接上串行传递请求-响应数据；后者在于保活、心跳，检测连接错误等。

## TCP重传、滑动窗口、流量控制、拥塞控制

### 重传机制(针对TCP数据包丢失情况)

**超时重传**：定时器，重传时间RTO应略大于报文往返RTT的值，根据公式设定RTO的初始值，【而又需要重传的时候，TCP的策略是超时间隔加倍】。

问题：超时触发重传存在的问题是，超时周期可能相对较长。

**快速重传**：不以时间为驱动，而是【以数据驱动重传】。快速重传的工作方式是当收到三个相同的ACK报文时，会在【定时器过期】之前，重传丢失的报文段。

问题：重传的时候，是重传之前的一个，还是重传所有的问题。为了解决不知道重传哪些TCP报文，于是有了SACK方法。

因为ACK报文确认的是未到达的那一个报文，如果发送方一次性发送多个报文，第一个报文丢失，即使后面的报文到达了，接收方发送的ACK包也是丢失报文的ACK包，所以问题是重传丢失的那一个，还是重传丢失报文之后的所有报文，【因为后面报文也没有ACK包】。

**SACK**：在TCP头部选项字段里加一个SACK字段，它可以将缓存的区间发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。**比如发送方在收到三个同样的ACK时，会查看SACK中的缺失区间，然后重传该区间内的数据**。(这里强调的是【快速重传】时，可以知道重传哪些包)

**D-SACK**：使用了SACK来告诉「发送方」有哪些数据被重复接收了。重复接收是因为接收方返回的ACK包丢失了，导致客户端**超时重传**，发送了相同的数据包。(这里强调的是【超时重传】)

1. 假如接收方ACK丢失导致发送方**超时重传**相同的数据包，接收方发现接收到相同的数据包，于是在SACK字段中填入数据包区间，告诉发送方这区间的数据包已经被接受了，发送方查看返回的报文首段中ACK的序号已经超过SACK的区间了，就表示这个SACK的内容已经被接收方接收了，【从而知道是接收方的ACK报文丢失导致自己超时重传】。
2. 当由于网络延时，某个包在网络中滞留，后续包正常发送，此时发送方收到三个相同的ACK，因此**快速重传**滞留的包，而之前滞留的包最后到达了服务端，接收方发现数据被重复接收，接收方在SACK中填入数据包区间，发送方接收到包时，发现接收方收到了重复包，但发送方也知道快速重传触发的包不是丢失，也不是回应的ACK丢了，而是网络延时了。

D-SACK：

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的ACK包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

### 滑动窗口(针对请求-应答模型低效率的情况)

TCP 是每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了， 再发送下⼀个。

这样的传输⽅式有⼀个缺点：数据包的往返时间越⻓，通信的效率就越低。

**为此，引入窗口概念，窗口大小就是无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

【累计确认】和【累计应答】，就是说接收方对于之前某个报文的ACK包遗失了，也没关系，直接发送最新的ACK包给发送方，发送方也知道自己之前发送的报文都被接收了。

TCPWindow字段，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过TCP报文中的Window字段来告诉发送方。这个传输过程是【存在时延】的，所以接收窗口和发送窗口是约等于的关系。

### 流量控制(考虑接收方的处理能力)

TCP提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的【流量控制】。

实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。

当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。

TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。

**流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么**。

**拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络，造成网络瘫痪**。

## TCP实战抓包分析

### TCP三次握手异常情况实战分析

第一次握手SYN丢包：

当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 tcp_syn_retries 值后，客户端不再发送 SYN 包。

第二次握手SYN、ACK丢包：

当 TCP 第二次握手 SYN、ACK 包丢了后，客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。

客户端 SYN 包超时重传的最大次数，是由 tcp_syn_retries 决定的，默认值是 6 次；服务端 SYN、ACK 包时重传的最大次数，是由 tcp_synack_retries 决定的，默认值是 5 次。(5.8.0)

第三次握手ACK丢包：

会导致服务端重传SYN、ACK包，服务端在重传SYN、ACK包超过指定次数后，**会主动中止此次的TCP连接**。

客户端收到SYN、ACK包，进入ESTABLISHED状态，如果此时使用telnet命令向服务端推送数据，会一直超时重传相同的数据包，共重传15次，该次数由 tcp_retries2 参数决定，此时telnet会断开连接。

如果客户端连接建立后【没有进行任何发送操作】，什么时候才会断开处于 ESTABLISHED 状态的连接？【保活机制】。

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个「探测报文」，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

- net.ipv4.tcp_keepalive_time=7200：2小时内没有任何连接的活动，启动保活机制。
- net.ipv4.tcp_keepalive_intvl=75：每次探测间隔为75秒。
- net.ipv4.tcp_keepalive_probes=9：探测9次。

也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。

小结：

在建立 TCP 连接时，如果第三次握手的 ACK，服务端无法收到，则服务端就会短暂处于 SYN_RECV 状态，而客户端会处于 ESTABLISHED 状态。

由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 tcp_synack_retries 值（默认值 5 次）后，服务端就会断开 TCP 连接。

而客户端则会有两种情况：

1. 如果客户端没发送数据包，一直处于 ESTABLISHED 状态，然后经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接，于是客户端连接就会断开连接。
2. 如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 tcp_retries2 值（默认值 15 次）后，客户端就会断开 TCP 连接。

### TCP快速建立连接

如果第三次握手不携带数据，则一次HTTP请求需要2.5个RTT，如果第三次握手携带数据(HTTP GET)，则需要2个RTT，下次HTTP GET，同样需要2.5或2个RTT。

FAST OPEN第一次需要2个RTT(SYN/SYN+ACK+**COOKIE**/ACK+HTTP GET/DATA)，之后每一次连接只需要1个RTT(SYN+COOKIE+HTTP GET/SYN+ACK+DATA)。

**服务端在第二次握手产生一个Cookie（已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 Cookie ，所以第一次发起 HTTP GET 请求的时候，还是需要 2 个 RTT 的时延**；

在下次请求的时候，客户端在 SYN 包带上 Cookie 发给服务端，就提前可以跳过三次握手的过程，因为 Cookie 中维护了一些信息，服务端可以从 Cookie **获取 TCP 相关的信息**，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；

注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断重复 TCP Fast Open 直至服务器认为Cookie 无效（通常为过期）。

该 Cookie 是通过将服务器秘密持有的密钥应用于客户端的块密码生成的，生成了一个第三方难以伪造的认证标签，即使他们可以伪造源IP地址或从其他IP地址向同一服务器进行双向连接。

虽然它使用加密技术来生成 Cookie，但TFO并不是为了提供比它所取代的三方握手更多的安全性，也不会对产生的TCP连接提供任何形式的加密保护，或对任何一个端点提供身份保证。它也不打算抵御中间人攻击。如果需要抵御这种攻击，它可以与TLS或IPsec等加密协议结合使用。

### TCP流量控制

零窗口通知和窗口探测。

假设接收方处理数据的速度跟不上接收数据的速度，缓存就会被占满，从而导致接收窗口为 0，当发送方接收到零窗口通知时，就会停止发送数据。

接着，发送方会定时发送窗口大小探测报文，以便及时知道接收方窗口大小的变化。

这些窗口探测报文时间间隔是翻倍递增的。

如何在包里看出发送窗口的大小。

很遗憾，没有简单的办法，发送窗口虽然是由接收窗口决定，但是它又可以被网络因素影响，也就是拥塞窗口，实际上发送窗口是值是 min(拥塞窗口，接收窗口)。

发送窗口和 MSS 有什么关系。

发送窗口决定了一口气能发多少字节，而 MSS 决定了这些字节要分多少包才能发完。

发送方在一个窗口发出 n 个包，是不是需要 n 个 ACK 确认报文？不一定，因为 TCP 有累计确认机制，所以当收到多个数据包时，只需要应答最后一个数据包的 ACK 报文就可以了。

### TCP延迟确认与Nagle算法

**当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的⽐重就会⾮常低**。

常⻅的两种策略，来减少⼩报⽂的传输：

Nagle算法

1. 没有已发送未确认报文时，立刻发送数据。
2. 存在未确认报文时，直到「没有已发送未确认报文」或「数据长度达到 MSS 大小」时，再发送数据。

只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。

**也就是说Nagle算法会囤积正要发送的数据直到上一个发送数据的确认报文到达**。

Nagle 算法一定会有一个小报文，也就是在最开始的时候。

Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。

**可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的配置来关闭）**。

延迟确认(注意和滑动窗口中接收方的累计确认相区别))

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

当 TCP 延迟确认 和 Nagle 算法混合使用时，会导致时耗增长

**因为发送方的Nagle算法需要等待上一个报文的ACK报文，而接收方的延迟确认又延迟了上一个报文的ACK报文**。

很明显，这两个同时使用会造成额外的时延，这就会使得网络"很慢"的感觉。

1. 要不发送方关闭 Nagle 算法
2. 要不接收方关闭 TCP 延迟确认

## TCP半连接队列和全连接队列

SYN队列和ACCEPT队列。

全连接队列满载：

后续到达的客户端ACK包就被DROP，也就是说客户端此时处于连接状态，但是服务端这边已经放弃了连接。

除了DROP操作外，还可以选择服务端发送一个RST包给客户端，即通知客户端应当关闭此次连接。

如果客户端想要知道是不是服务端全连接队列满导致的连接丢失，可以设置 tcp_abort_on_overflow 参数为1，如果在客户端异常中可以看到很多connection reset by peer的错误，则可以确定是服务端TCP全连接队列溢出的问题。

但通常情况下应该设置为0，有利于应对突发流量，也就是服务端只是短期内导致全连接队列溢出，一段时间后，客户端再次接收到的报文由于含有ACK，因此仍会触发服务端成功建立连接，提高建立连接的成功率。

TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，前者是内核参数，后者是服务端listen函数的参数。

半连接队列满载：

客户端一直发送第一次握手的SYN包，但是接收到服务端的SYN、ACK包后，不向服务端发送ACK包，这样会使得服务端有大量的处于SYN_RECV状态的TCP连接，这其实也就是所谓的 SYN 洪泛、SYN 攻击、DDos 攻击。

满载时，后续连接的处理策略：

如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；

若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；

如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于(max_syn_backlog >> 2)，则会丢弃；

半连接队列最大值不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系。

开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接。

syncookies是这么做的：服务器根据当前状态计算出一个值，放在己方发出的SYN+ACK报文中发出，当客户端返回ACK报文时，取出该值验证，如果合法，就认为连接建立成功

几种防御 SYN 攻击的方法：

- 增大半连接队列；
- 开启tcp_syncookies功能，不开启的情况下，服务端对每一个SYN包的连接都立即分配存储空间，开启后，只有在第三次握手ACK中携带正确的cookie，才进行存储空间的分配。
- 减少 SYN+ACK 重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

## TCP内核参数

SYN全称也叫同步序列号，客户端发送SYN包时，序列号为随机初始化，服务端发送SYN、ACK包时，除了对客户端的序列号进行确认，返回ACK=客户端序列号+1，表示接下去希望收到这个序列号为起点的包，同时自己也会随机初始化一个序列号给到客户端，客户端发送ACK包时，里面就附带了ACK=服务端序列号+1的信息。

### 三次握手性能提升

- 客户端：适当调低SYN包的重试次数，尽快把错误暴露给上层应用。
- 服务端：调整半连接队列长度，涉及三个参数的改动，tcp_max_syn_backlog、somaxconn、backlog。
- 服务端：服务端SYN_RECV状态优化，网络繁忙时，可以增大SYN、ACK包的重试次数，反之可以调小次数。
- 服务端：调整全连接队列长度，min(backlog、somaxconn)。
- 绕过三次握手，使用TCP fast open，减少了握手带来的 1 个 RTT 的时间消耗，必须保证客户端和服务端同时开启。

### 四次挥手性能提升

- 主动方：如果有大量处于FIN_WAIT1的连接，代表没收到对方的ACK包，会重传FIN包，可以通过 tcp_orhan_retries 参数调整FIN包的重发次数。
- 主动方(针对孤儿连接)：通过 tcp_fin_timeout 调整FIN_WAIT2状态的时间，超时则直接关闭当前连接。
- 主动方(针对孤儿连接)：通过 tcp_max_orhans 调整最大孤儿连接个数，超出时连接就会直接释放。
- 主动方：优化 TIME_WAIT，1.复用连接，2.超时重置，3.跳过挥手阶段直接关闭。

### 传输数据性能提升

可以从窗口大小、缓冲区范围、缓冲区动态调节、内存范围等方面入手。

# 进程和线程

## 进程

### 概念

我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执⾏⽂件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，就被称为「进程」（Process）。

### 状态

创建态、就绪态、运行态、阻塞态、结束态。

提一点：被阻塞状态的进程占⽤着物理内存本身就是⼀种浪费物理内存的⾏为，如果有大量的处于阻塞状态的进程，这是我们所不希望的。所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运⾏的时候，再从硬盘换⼊到物理内存。

那么，就需要⼀个新的状态，**来描述进程没有占⽤实际的物理内存空间的情况**，这个状态就是挂起状态。这跟阻塞状态是不⼀样，阻塞状态是等待某个事件的返回。

挂起状态可以分为两种：

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏；

导致进程挂起的原因不只是因为进程所使⽤的内存空间不在物理内存，还包括如下情况：

- 通过 sleep 让进程间歇性挂起，其⼯作原理是设置⼀个定时器，到期后唤醒进程。
- ⽤户希望挂起⼀个程序的执⾏，⽐如在 Linux 中⽤ Ctrl+Z 挂起进程；

### 控制结构

⽤进程控制块（process control block，PCB）数据结构来描述进程的。PCB 是进程存在的唯⼀标识，这意味着⼀个进程的存在，必然会有⼀个 PCB，如果进程消失了，那么 PCB 也会随之消失。

PCB 包含：

- 进程描述信息
    - 进程标识符
    - 用户标识符
- 进程控制和管理信息
    - 当前状态
    - 优先级
- 资源分配清单
    - 有关物理内存地址空间或虚拟内存地址空间的信息，以及打开文件列表和所使用的 I/O 设备信息
- CPU 相关信息
    - 各个寄存器值，进程被切换时，寄存器值就会被保存在 PCB 中

PCB 组织形式：通常是通过链表的⽅式进⾏组织，把具有相同状态的进程链在⼀起，组成各种队列。

### 控制

### 上下文切换

先说 CPU 上下文切换：

CPU 寄存器和程序计数器是 CPU 在运⾏任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下⽂。

CPU 上下⽂切换就是先把前⼀个任务的 CPU 上下⽂（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下⽂到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运⾏新任务。

系统内核会存储保存下来的上下⽂信息，当此任务再次被分配给 CPU 运⾏时，CPU 会重新加载这些上下⽂，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运⾏。

上⾯说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下⽂切换分成：**进程上下⽂切换、线程上下⽂切换和中断上下⽂切换**。

再说进程上下文切换：

进程是由内核管理和调度的，所以进程的切换只能发⽣在内核态。

**进程的上下⽂切换不仅包含了虚拟内存、栈、全局变量等⽤户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**。

**进程上下文切换的场景**：

- 时间片耗尽
- 资源不足
- 睡眠函数
- 高优先级抢占
- 硬件中断

## 线程

### 为什么

假设你要编写⼀个视频播放器软件，那么该软件功能的核⼼模块有三个：从视频⽂件当中读取数据；对读取的数据进⾏解压缩；把解压缩后的视频数据播放出来；

需要一种新的实体，它满足以下特性：

- 实体之间可以并发运行
- 实体之间共享相同的地址空间

这个新的实体，就是线程( Thread )，线程之间可以并发运⾏且共享相同的地址空间。

### 什么是

**线程是进程当中的⼀条执⾏流程**。

同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的**控制流**是相对独⽴的。

**线程优点**：

- ⼀个进程中可以同时存在多个线程；
- 各个线程之间可以并发执⾏；
- 各个线程之间可以共享地址空间和⽂件等资源；

**线程缺点**：

- 当进程中的⼀个线程崩溃时，会导致其所属进程的所有线程崩溃。
    - 举个例⼦，对于游戏的⽤户设计，则不应该使⽤多线程的⽅式，否则⼀个⽤户挂了，会影响其他同个进程的线程。

### 比较

线程与进程的⽐较如下：

- 进程是**资源（包括内存、打开的⽂件等）分配**的单位，线程是 CPU **调度的单位**；
- 进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执⾏的时间和空间开销；

线程相⽐进程能减少开销，体现在：

- 线程的创建时间⽐进程快，因为进程在创建的过程中，还需要资源管理信息，⽐如内存管理信息、⽂件管理信息，⽽**线程在创建的过程中，不会涉及这些资源管理信息，⽽是共享它们**；
- 线程的终⽌时间⽐进程快，因为**线程释放的资源相⽐进程少很多**；
- 同⼀个进程内的线程切换⽐进程切换快，因为线程具有相同的地址空间（虚拟内存共享），**这意味着同⼀个进程的线程都具有同⼀个⻚表，那么在切换的时候不需要切换⻚表**。⽽对于进程之间的切换，切换的时候要把⻚表给切换掉，⽽⻚表的切换过程开销是⽐较⼤的；
- 由于同⼀进程的各线程间共享内存和⽂件资源，那么在**线程之间数据传递的时候，就不需要经过内核了**，这就使得线程之间的数据交互效率更⾼了；

### 上下文切换

所谓操作系统的任务调度，实际上的调度对象是线程，⽽**进程只是给线程提供了虚拟内存、全局变量等资源**。

**当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

### 实现

- ⽤户线程（User Thread）：在⽤户空间实现的线程，不是由内核管理的线程，是由⽤户态的线程库来完成线程的管理；
- 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；
- 轻量级进程（LightWeight Process）：在内核中来⽀持⽤户线程；

⽤户线程和内核线程的对应关系：多对一、一对一、多对多。

#### 如何理解用户线程，存在什么优势和缺陷？

⽤户线程是基于⽤户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库⾥⾯来实现的，对于操作系统⽽⾔是看不到这个 TCB 的，它只能看到整个进程的 PCB。

**⽤户线程的整个线程管理和调度，操作系统是不直接参与的，⽽是由⽤户级线程库函数来完成线程的管理，包括线程的创建、终⽌、同步和调度等**。

⽤户级线程的模型，也就类似前⾯提到的**多对⼀**的关系，即多个⽤户线程对应同⼀个内核线程。

优势和缺陷：

- 每个进程都需要有它私有的线程控制块（TCB）列表，⽤来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由⽤户级线程库函数来维护，**可⽤于不⽀持线程技术的操作系统**；
- **⽤户线程的切换也是由线程库函数来完成的，⽆需⽤户态与内核态的切换，所以速度特别快**；
- **由于操作系统不参与线程的调度，如果⼀个线程发起了系统调⽤⽽阻塞，那进程所包含的⽤户线程都不能执⾏了**。
- **当⼀个线程开始运⾏后，除⾮它主动地交出 CPU 的使⽤权，否则它所在的进程当中的其他线程⽆法运⾏，因为⽤户态的线程没法打断当前运⾏中的线程，它没有这个特权，只有操作系统才有，但是⽤户线程不是由操作系统管理的**。
- **由于时间⽚分配给进程，故与其他进程⽐，在多线程执⾏时，每个线程得到的时间⽚较少，执⾏会⽐较慢**；

#### 如何理解内核线程，存在什么优势和缺陷？

**内核线程是由操作系统管理的，线程对应的 TCB ⾃然是放在操作系统⾥的，这样线程的创建、终⽌和管理都是由操作系统负责**。

优势和缺陷：

- 在⼀个进程当中，如果某个内核线程发起系统调⽤⽽被阻塞，并不会影响其他内核线程的运⾏；
- 分配给线程，多线程的进程获得更多的 CPU 运⾏时间；
- 在⽀持内核线程的操作系统中，由内核来维护进程和线程的上下⽂信息，如 PCB 和 TCB；
- **线程的创建、终⽌和切换都是通过系统调⽤的⽅式来进⾏，因此对于系统来说，系统开销⽐较⼤**；

#### 如何理解轻量级进程，存在什么优势和缺陷？

**轻量级进程（Light-weight process，LWP）是内核⽀持的⽤户线程，⼀个进程可有⼀个或多个 LWP，每个 LWP 是跟内核线程⼀对⼀映射的，也就是 LWP 都是由⼀个内核线程⽀持**。

LWP 只能由内核管理并像普通进程⼀样被调度，Linux 内核是⽀持 LWP 的典型例⼦。

在⼤多数系统中，LWP与普通进程的区别也在于它只有⼀个最⼩的执⾏上下⽂和调度程序所需的统计信息。⼀般来说，⼀个进程代表程序的⼀个实例，⽽ LWP 代表程序的执⾏线程，因为⼀个执⾏线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。

LWP 与⽤户线程的对应关系就有三种：1:1、N:1、M:N。

1:1，一个用户线程对应到一个LWP再对应到一个内核线程，优点：实现并行，一个LWP阻塞不会影响其它LWP，缺点：一个用户线程就要创建一个内核线程，开销大。

N:1，多个用户线程对应到一个LWP在对应到一个内核线程，优点：用户线程开几个都没问题，且上下文切换发生在用户空间，切换效率高，缺点：一个线程阻塞会导致整个进程阻塞，无法充分利用多核CPU。

M:N，混搭上述两种模式，用户线程对应到多个LWP，每个LWP再一一对应到内核线程，优点：综合前二者的优点，大部分线程上下文切换发生在用户空间，且多个线程又可以充分利用多核CPU的资源。

## 调度

### 时机

当进程从⼀个运⾏状态到另⼀状态变化的时候，其实会触发⼀次调度。

### 原则

1. 为了提⾼ CPU 利⽤率，在发生 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择⼀个进程来运⾏。
2. 要提⾼系统的吞吐率，调度程序要权衡⻓任务和短任务进程的运⾏完成数量。
3. 如果进程的等待时间很⻓⽽运⾏时间很短，那周转时间就很⻓，这不是我们所期望的，调度程序应该避免这种情况发⽣。
4. 就绪队列中进程的等待时间也是调度程序所需要考虑的原则。
5. 对于交互式⽐较强的应⽤，响应时间也是调度程序需要考虑的原则。

### 算法

单核CPU常见调度算法：

1. 先来先服务
2. 最短作业优先
3. 高响应比优先
4. 时间片轮转调度
5. 最高优先级调度
6. 多级反馈队列调度

## PCB

PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

进程描述信息：

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

进程控制和管理信息：

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

资源分配清单：

- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

CPU 相关信息：

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

## 进程上下文切换

进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

### 上下文切换场景

- 时间片耗尽。
- 资源不足。
- 通过睡眠函数将自己主动挂起。
- 优先级高的进程到达。
- 发生硬件中断。

## 线程上下文切换

当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

## 线程实现

1. 用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的**线程库**来完成线程的管理；(多对一)
2. 内核线程：在内核中实现的线程，是由内核管理的线程；(一对一)
3. 轻量级进程：在内核中来支持用户线程；(多对多)

## 用户线程

用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。

### 优点

每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；

用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；

### 缺点

由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。

当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。

由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；

## 内核线程

内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。

### 优点

在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；

分配给线程，多线程的进程获得更多的 CPU 运行时间；

### 缺点

在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；

线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；

## 轻量级进程

轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。

## 进程调度

### 五种调度原则

- CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- 周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；
- 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

### 先来先服务

### 最短作业优先

### 高响应比优先

### 时间片轮转

### 最高优先级

### 多级反馈队列

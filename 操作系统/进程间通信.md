# 进程间通信

## 管道

管道传输数据是单向的，有匿名管道和命名管道两种。

管道这种通信⽅式效率低，不适合进程间频繁地交换数据。

所谓的管道，就是内核⾥⾯的⼀串缓存。

创建的⼦进程会复制⽗进程的⽂件描述符，这样就做到了两个进程各有两个「 `fd[0]` 与 `fd[1]` 」，两个进程就可以通过各⾃的 fd 写⼊和读取同⼀个管道⽂件实现跨进程通信了。

- ⽗进程关闭读取的 `fd[0]`，只保留写⼊的 `fd[1]`；
- ⼦进程关闭写⼊的 `fd[1]`，只保留读取的 `fd[0]`；

到这里，仅仅解析了使用管道在父进程和子进程之间的通信。

而在shell中，A 进程和 B 进程都是 shell 创建出来的⼦进程，A 和 B 之间不存在⽗⼦关系，它俩的⽗进程都是 shell。

对于匿名管道，它的通信范围是存在⽗⼦关系的进程。因为管道没有实体，也就是没有管道⽂件，只能通过 fork 来复制⽗进程 fd ⽂件描述符，来达到通信的⽬的。

对于命名管道，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信。

不管是匿名管道还是命名管道，**进程写⼊的数据都是缓存在内核中，另⼀个进程读取数据时候⾃然也是从内核中获取**，同时通信数据都遵循先进先出原则，不⽀持 lseek 之类的⽂件定位操作。

## 消息队列

消息队列是保存在内核中的消息链表。

- 消息队列不适合⽐较⼤数据的传输，因为在内核中每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所包含的全部消息体的总⻓度也是有上限。
- 消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销，因为进程写⼊数据到内核中的消息队列时，会发⽣从⽤户态拷⻉数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态拷⻉数据到⽤户态的过程。

## 共享内存(最快)

共享内存解决了消息队列中上下文切换的问题。

**共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写⼊的东⻄，另外⼀个进程⻢上就能看到了，都不需要拷⻉来拷⻉去，传来传去，⼤⼤提⾼了进程间通信的速度。

## 信号量

使得共享的资源，在任意时刻只能被⼀个进程访问。正好，信号量就实现了这⼀保护机制。

**信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据**。

信号量初始化为`1`，表示这是一个互斥信号量，每个进程访问共享变量之前，都需要进行P操作，访问结束后进行V操作。

信号量初始化为`0`，表示这是一个同步信号量，B进程访问数据前执行P操作，A进程生成数据后执行V操作唤醒B进程，B进程读取数据。

## 信号

上⾯说的进程间通信，都是常规状态下的⼯作模式。**对于异常情况下的⼯作模式，就需要⽤「信号」的⽅式来通知进程**。

信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。

**信号是进程间通信机制中唯⼀的异步通信机制**，因为可以在任何时候发送信号给某⼀进程，⼀旦有信号产⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式：

1. 执行默认操作。
2. 捕捉信号。
3. 忽略信号。

## socket

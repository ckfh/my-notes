# 笔记

## HotSpot细节

- 根节点枚举：找到所有可用于可达性分析的根节点，若是逐个检查每个变量是否为起源引用会消耗巨大时间，因此借助了名为OopMap的数据结构，虚拟机可以直接知道哪些地方存放着对象引用，可以直接到这些地方开始查找。
- 安全点：用来挂起线程，准备进行垃圾回收。
- 安全区域：不会改变对象引用的代码块，如果代码运行至该区域，虚拟机不会去注意这些线程，线程执行要离开安全区域时会等待虚拟机是否完成了垃圾回收才离开。
- 记忆集和卡表：前者是抽象，后者是具体实现，用来记录从非收集区域指向收集区域的指针集合的数据结构。卡表会标记一块固定大小的内存区域是否存在跨代引用指针，如果存在，则不允许回收，防止后续代码调用出现问题。
- 写屏障：在对象赋值时维护卡表的正确性，它属于机器码层面，把维护卡表的动作放到每一个赋值操作之中。写屏障可以看作在虚拟机层面对”引用类型字段赋值“这个动作的AOP切面，分为写前屏障和写后屏障，在写后屏障会完成卡表的更新。由于存在伪共享，两个线程中代码的写屏障刚好对同一个缓存行进行操作，在写回主内存时，就会导致卡表的重复更新，因此在更新卡表前判断卡表元素是否已经变脏，如果已经变脏则不需要更新卡表。
- ”并发“的可达性分析：为了防止可达性标记随着对象的增多，造成用户线程停顿的时间越长。首先，我们必须在保障一致性的快照上进行可达性分析，（一个原本存活的对象错误标记为已消亡，将造成致命的后果）。借助”三色法“可以将可达性分析的扫描过程比喻成一股以灰色为波峰的波纹从黑向白的推进过程。要解决并发扫描时的对象消失问题，有两种解决方案：1.增量更新，如果并发过程中，黑色对象插入新的指向白色对象的引用关系时，需要记录下来重新扫描一次（相当于将其置为灰色）。2.原始快照，当灰色对象要删除指向白色对象的引用关系时，需要记录下来重新扫描，也就是将这个时候引用关系进行快照，这样之后才能从灰色对象继续向白色对象进行扫描。

## G1

1. 基于region。
2. 停顿预测模型。
3. Mixed GC。
4. 把连续的Java堆划分为多个大小相等的独立region，每一个region可以根据需要，扮演新生代的Eden空间，survivor空间，或者老年代空间。
5. humongous区域。
6. 根据收集停顿时间回收价值收益最大的region。
7. 每个region都需要维护卡表，内存消耗更高。
8. 并发标记基于原始快照模式，设计了名为TMAS的指针，用于并发回收时的新对象分配。
9. 以衰减均值为理论基础建立可靠的停顿预测模型。

# 笔记

## 逃逸分析

方法逃逸：对象被作为调用参数从一个方法传递到另外一个方法。

线程逃逸：对象被其它线程访问到，例如赋值给其它线程可以访问的实例变量。

如果能证明一个对象不会逃逸到方法或线程之外，或者逃逸程度比较低，则可能为这个对象实例采取不同程度的优化。

栈上分配：堆是用来存放对象的，这就要涉及堆内存的分配与回收。如果一个对象可以直接在栈上分配，随着栈帧入栈被创建，出栈被销毁，这就减轻了虚拟机垃圾回收的压力。如果确定一个对象不会逃逸出线程之外，那么让这个对象在栈上分配就是一个不错的选择。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的。栈上分配可以支持方法逃逸，但不支持线程逃逸。

标量替换：基本类型无法被分解，这称为标量；聚合量则是一个数据可以再度被分解，对象就是典型的聚合量。如果逃逸分析能证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序执行时就不会创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。对象拆分后，可以让对象的成员变量直接在栈上分配和读写。可以将标量替换视为栈上分配的一种特例，但它要求更高，不允许方法逃逸。

同步消除：一个对象如果不会发生线程逃逸，那么就不会产生竞争，施加在对象上的同步措施可以被消除。

## 自动拆装箱原理

自动拆装箱其实是Java编译器提供的语法糖之一，它会在.java文件被编译为.class文件时，自动生成和转换一些代码，减轻程序员的编码负担。

```java
// JDK5之前这段代码是无法编译通过的:
Integer x = 10;
int y = x;
```

```java
// 在JDK5之后编译器会将上述代码转换成“类似”如下形式的字节码:
Integer x = Integer.valueOf(10);
int y = x.intValue();
```

## JDK8内存结构图

<img src="./image/Java8内存结构图.jpg">

## HotSpot细节

- 根节点枚举：找到所有可用于可达性分析的根节点，若是逐个检查每个变量是否为起源引用会消耗巨大时间，因此借助了名为OopMap的数据结构，虚拟机可以直接知道哪些地方存放着对象引用，可以直接到这些地方开始查找。
- 安全点：用来挂起线程，准备进行垃圾回收。
- 安全区域：不会改变对象引用的代码块，如果代码运行至该区域，虚拟机不会去注意这些线程，线程执行要离开安全区域时会等待虚拟机是否完成了垃圾回收才离开。
- 记忆集和卡表：前者是抽象，后者是具体实现，用来记录从非收集区域指向收集区域的指针集合的数据结构。卡表会标记一块固定大小的内存区域是否存在跨代引用指针，如果存在，则不允许回收，防止后续代码调用出现问题。
- 写屏障：在对象赋值时维护卡表的正确性，它属于机器码层面，把维护卡表的动作放到每一个赋值操作之中。写屏障可以看作在虚拟机层面对”引用类型字段赋值“这个动作的AOP切面，分为写前屏障和写后屏障，在写后屏障会完成卡表的更新。由于存在伪共享，两个线程中代码的写屏障刚好对同一个缓存行进行操作，在写回主内存时，就会导致卡表的重复更新，因此在更新卡表前判断卡表元素是否已经变脏，如果已经变脏则不需要更新卡表。
- ”并发“的可达性分析：为了防止可达性标记随着对象的增多，造成用户线程停顿的时间越长。首先，我们必须在保障一致性的快照上进行可达性分析，（一个原本存活的对象错误标记为已消亡，将造成致命的后果）。借助”三色法“可以将可达性分析的扫描过程比喻成一股以灰色为波峰的波纹从黑向白的推进过程。要解决并发扫描时的对象消失问题，有两种解决方案：1.增量更新，如果并发过程中，黑色对象插入新的指向白色对象的引用关系时，需要记录下来重新扫描一次（相当于将其置为灰色）。2.原始快照，当灰色对象要删除指向白色对象的引用关系时，需要记录下来重新扫描，也就是将这个时候引用关系进行快照，这样之后才能从灰色对象继续向白色对象进行扫描。

## G1

1. 基于region。
2. 停顿预测模型。
3. Mixed GC。
4. 把连续的Java堆划分为多个大小相等的独立region，每一个region可以根据需要，扮演新生代的Eden空间，survivor空间，或者老年代空间。
5. humongous区域。
6. 根据收集停顿时间回收价值收益最大的region。
7. 每个region都需要维护卡表，内存消耗更高。
8. 并发标记基于原始快照模式，设计了名为TMAS的指针，用于并发回收时的新对象分配。
9. 以衰减均值为理论基础建立可靠的停顿预测模型。

## 写屏障

通过记忆集来缩减GC Roots扫描范围的问题，而卡表是记忆集的一种具体实现，卡表的维护问题可以通过“写后屏障”技术来解决。

“写屏障”可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。

应用写屏障后，虚拟机就会在所有的引用字段赋值操作后生成相应的指令，通过该指令完成卡表状态的更新。

为了避免伪共享造成多次对同一个卡表进行更新，可以选择在更新卡表状态前进行一次判断，如果卡表已经变脏，那就不需要再次变脏。

# 笔记

## To load and execute

1. `Edit MyApp.java file`
2. `javac MyApp.java`
3. `java MyApp`（此时会创建`JVM`实例）

## JVM实例如何加载并执行你的.class文件（流程)

<img src="./image/类加载过程.jpg">

首先是类加载器(`class loader`)，它负责加载你的`.class`文件以及系统内置的`.class`文件，比如`String.class`、`Object.class`。

类加载器将加载后的`.class`文件即字节码指令传递给执行引擎(`execution engine`)。

随后执行引擎去执行字节码，为了执行字节码或者说指令，执行引擎必须和`OS`交互才能执行指令（字节码对应的机器指令集），为此，执行引擎使用了本地方法调用(`native method calls`)，最终将字节码转化为执行操作的机器码。

## JVM架构

<img src="./image/JVM架构.jpg">

### 类加载子系统（class loader subsystem）

<img src="./image/类加载子系统.jpg">

`load`阶段负责将字节码加载到内存中，它可以从任何来源读取`.class`文件，比如：`.class`文件、包含`.class`文件的`jar`包。

(面试点)`load`阶段将执行三个类加载器：

1. 启动类加载器：负责加载`Java`的内部类，内部类位于和`JVM`实现一起发行的`rt.jar`中。
2. 扩展类加载器：负责加载`jre/lib/ext`文件夹下的其它应用程序的`jar`文件。
3. 系统类加载器：负责加载类路径环境变量所指定位置的类，`CLASSPATH`变量、`-cp`指令。

`ClassNotFoundException`就是发生在这个阶段，当类加载器找不到字节码对应的类时，就会发生该异常。

`link`阶段分为三个阶段：

1. 验证：对类加载器提交的字节码进行验证，查看其是否为一个有效的`Java`字节码。
2. 准备：为类文件中的静态变量即类变量分配内存，注意这里它只进行内存"分配"，就是分配好内存，初始化为默认值，例如：`public static boolean isCorrect = true`，它将为其分配内存，并把它初始化为默认值`false`（`JVM`规范）。
3. 解析：解析当前类的符号引用，例如引用另外的其它两个类或者常量池中的两个值，这些符号会被转变为实际的引用。

以上三个阶段在执行过程上会有所重叠，例如一个类在进行解析，那么下一个类就可以进行验证。

在解析阶段可能发生`ClassDefNotFound`异常，比如我要加载一个`X`类，它通过了之前的加载阶段以及上述的验证和准备阶段，但是`X`类引用了另一个叫做`Y`的类，系统会尝试加载这个`Y`类，如果没找到，就会发生上述异常，对于`X`类来说，`ClassDefNotFound`对找不到`Y`的异常`ClassNotFoundException`进行了包装。

`initialize`阶段使用静态初始化器对类变量进行初始化，例如上述所提到的`isCorrect`变量的实际值`true`将设置到其内存区域。

### 运行时数据区（runtime data areas）

<img src="./image/运行时数据区.jpg">

方法区：存放类数据（对应类的元数据`metadata`）的地方，`Class`类就用于访问方法区中的数据，静态变量、字节码、类级别的常量池等等都在该区域当中，方法区位于系统分配给`JVM`的内存中，方法区也称为永久代，默认为其分配`64MB`，可以使用`-XX MaxPermSize`来调整永久代的大小，假设加载一个包含有一百万个类的应用程序，但是没有设置永久代的大小的话，可能会遇到`OutOfMemoryError`错误。

`Java8`开始去除了方法区，现在被称为元空间（`metaspace`），具体的做法就是将方法区迁移到本地`OS`的一块单独内存里，这块内存就被称为元空间，默认情况下，`Java8`的元空间没有大小限制，只要`OS`允许，它的大小可以一直增长，直到内存满了，或者将其转移到虚拟内存或类似虚拟内存的地方。

堆：存放对象数据的地方，每实例化一个对象，该对象就会在堆中被创建，任何与类有关的内容，都会在堆中创建，例如：实例变量，堆是非常重要的一块内存区域，可以使用`-Xms`调整最小值，用`-Xmx`调整最大值，默认情况下，它的最小值为物理内存的四分之一。

## GC 垃圾回收策略

- 标记-清除
  - 将需要回收的内存区域进行标记（是标记出需要回收的还是标记出不需要回收的，这两种办法都可以），然后清除要回收的对象（根据前面的方法进行区分），会有两个问题。一是效率不高，标记的时间随着回收对象数量的增加而增加，二是会产生许多不连续的内存碎片。
- 标记-复制
  - 将内存区域划分为两部分，标记之后，将存活对象移动至另一部分，清空当前部分使用的所有内存。
- 标记-整理
  - 标记后让所有存活对象向一端移动。
- 分代收集
  - 根据对象存活周期将内存分为几块，一般是分为新生代和老年代，这样就可以根据各个年代对象的特点选择不同的垃圾回收算法。比如新生代，每次收集都有大量对象死去，可以选择“标记-复制”算法，只需付出少量复制成本即可完成垃圾回收，而老年代则可以选择“标记-清除”或者“标记-整理”。

## i++ 是原子的吗？如果不是如何变为原子性

不是，对应到字节码指令可以分为三步，“取值-计算-写回”，可以将其放入同步代码块，每次只允许一个操作对象进行操作。

## 对象是否可回收

- 引用计数法：对象在某个地方被引用，那么其本身的计数加一，但是对于循环引用问题无法有效解决。
- 可达性分析：从一些被称为“根节点”的对象开始，遍历引用链，如果某对象和任意的根节点都没有引用链相连，或者说从根节点到该对象不可达时，这些对象将被判定为可回收。
  - 可作为根节点的对象可以理解为是那些“当前运行时绝对不会被回收的对象”：
    - 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如**当前正在运行**的方法堆栈中使用到的参数、局部变量、临时变量等。
    - 在方法区中类静态属性引用的对象。
    - 在方法区中常量引用的对象。
    - 在本地方法栈中引用的对象。
    - 虚拟机内部引用对象，如基本数据类型对应的 Class 对象，一些常驻的异常对象等，还有系统类加载器。
    - 所有被同步锁持有的对象。
    - 反应虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

## 再谈引用

- 强引用：宁愿抛出内存溢出异常也不会回收内存的一类对象。
- 软引用：当内存空间不足时，会尝试回收此类对象，如果回收后仍没有足够的内存空间，此时才会抛出内存溢出异常。
- 弱引用：当垃圾收集器开始工作，无论内存空间是否足够，都会回收此类对象。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。设置虚引用的唯一目的只是为了能在这个对象被回收时能收到一个系统通知。




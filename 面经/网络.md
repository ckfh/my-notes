## HTTP 和 HTTPS

1. 端口不同，前者 80，后者 443；
2. 后者在应用层 HTTP 协议和传输层 TCP 协议之间加了一个 SSL/TLS 协议，保证传输的安全性；
3. 前者只需要三次握手后便可以开始进行传输，后者在三次握手后还需要进行 SSL/TLS 握手过程才可进入加密报文传输；
4. 后者需要向 CA 申请数字证书，来保证服务器身份是可靠的。

## SSL/TLS 握手过程

1. 客户端发送支持的加密套件、支持的协议版本、随机数 C，得到服务端 ACK；
2. 服务端发送选择的加密套件、选择的协议版本、随机数 S；
3. 服务端发送数字证书；
4. 服务端发送结束消息，得到客户端 ACK；
5. 客户端验证数字证书，取出公钥，对生成的 pre-master 加密，发送；
6. 客户端和服务端使用随机数 C 和随机数 S 和 pre-master 在本地算出会话密钥；
7. 客户端发送通知消息，通知接下去使用会话密钥加密；
8. 客户端发送之前所有握手数据的摘要，得到服务端 ACK；
9. 服务端发送通知消息，通知接下去使用会话密钥加密；
10. 服务端发送之前所有握手数据的摘要，得到客户端 ACK。

## TCP 优化相关

- 三次握手
  - 调整 SYN 报文的重传次数；
  - 调整 SYN 半连接队列长度，需要三个参数来共同决定；
  - 调整 SYN+ACK 报文的重传次数；
  - 调整 accept 队列长度；
  - 绕过三次握手。
- 四次挥手
  - 调整 FIN 报文重传次数；
  - 调整 FIN_WAIT2 状态的时间；
  - 调整孤儿连接的上限个数；
  - 调整 time_wait 状态的上限个数；
  - 复用 time_wait 状态的连接。
- 数据传输
  - 扩大窗口大小；
  - 调整发送缓冲区范围；
  - 调整接收缓冲区范围；
  - 打开接收缓冲区动态调节；
  - 调整内存范围。

## TCP 快连接

发送一个 HTTP 报文最快也得经过一个 RTT 才能进行发送，即在 TCP 第三次握手时将数据附在上面。

如果使用 TCP 快连接技术，则在第一次建立连接时让服务端返回一个 Cookie 给到客户端进行本地存储。

随后当客户端发起第二次连接时，便可以将 Cookie 和 HTTP GET 包直接附在 SYN 请求上，而服务端也直接将响应包附在 SYN+ACK 请求上返回，这就是 TCP 快连接技术。

Cookie 维护了一些信息，服务端可以直接从其中获取 TCP 相关信息。

## TCP 粘包和半包问题

因为 TCP 协议是一个基于流式的协议，消息没有定义边界，上层协议所发送的一个个数据包在 TCP 层会被组合或者拆分，变成一个数据流进行发送。

因此，如果应用层本身不对消息的边界进行处理，那么经过 TCP 协议合并或者拆分后的数据，在接收时将无法区分一个个完整的数据包。

### 粘包现象

发送 ABC 和 DEF，最后收到 ABCDEF。

原因：

- 接收方设置的 ByteBuf 太大，Netty 默认是 1024；
- TCP 协议滑动窗口，当接收方处理速度过慢并且窗口大小足够时，一个完整报文将被缓存，缓存了多个报文就会造成粘包；
- TCP 协议层开启了 Nagle 算法，该算法是为了解决多次发送的报文，由于消息体数据太小，而首部又固定为 20 个字节，造成了网络利用率的下降，会将多个报文进行合并，直到消息体数据比例足够大时才发送。

### 半包现象

发送 ABCDEF，最后收到 ABC 和 DEF。

原因：

- 接收方设置的 ByteBuf 太小，小于实际到达的数据量；
- TCP 协议滑动窗口，此时接收方只能接收一半的数据报文，剩下的数据报文只能等待上一个 ACK 到达后才能继续发送；
- 发送方 MSS 限制，数据会被切分发送。

## 四次挥手

1. 客户端发送 FIN 报文，进入 FIN_WAIT1 状态；
2. 服务端收到 FIN 报文，发送 ACK 报文进入 CLOSED_WAIT 状态；
3. 服务端收到 ACK 报文，进入 FIN_WAIT2 状态；
4. 服务端将剩余数据发送完毕，发送 FIN 报文（发送 FIN 报文意味着此时不再有数据需要进行发送），进入 LAST_ACK 状态；
5. 客户端收到 FIN 报文，发送 ACK 报文，进入 TIME_WAIT 状态，等待 2MSL 后进入 CLOSE 状态；
6. 服务端收到 ACK 报文，进入 CLOSE 状态。

### 为什么挥手需要四次

通常服务端在收到客户端发送的 FIN 报文时，还有一些数据未发送，因此先回一个 ACK 报文，等待自己这端的数据都发送完毕后才发送 FIN 报文，因此需要 4 次。

但是，如果说你没有数据要发送，那么也可以直接发送 ACK+FIN 报文给到客户端，这样只需要三次就完成了双端的关闭。

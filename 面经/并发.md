## 线程的创建方式

1. 继承 Thread 类；
2. 实现 Runnable 接口；
3. 想获取线程返回值，可以使用 Callable 接口，获得一个 Future 对象。

## 线程状态以及如何启动线程

线程状态可分为：new、runnable、terminated、blocked、waiting、timed_waiting。

其中 runnable 包含操作系统线程状态中的运行态、就绪态、**阻塞态**，即由于 BIO 导致的线程阻塞，在 Java 中无法区分，仍然认为是 runnable 状态。

blocked 就是线程由于同步代码获取不到锁，而进入到 monitor 对象的 entryset 当中等待。

waiting 是线程获取到锁，但运行条件不满足，调用 wait 方法进入到 monitor 对象的 waitset 当中等待，此时会将锁释放出来，当线程再次被唤醒，尝试竞争锁，如果竞争成功，则进入 runnable 状态，如果竞争失败，则进入 blocked 状态。

waiting 状态还有可能是当前线程调用了 join 方法，当目标线程运行结束或当前线程被中断，则进入 runnable 状态。

waiting 状态还有可能是调用 park() 方法，当其它线程调用 unpark 或者当前线程被中断，则进入 runnable 状态。

timed_waiting 则是调用 wait(long n)/join(long n)/sleep(long n)/parkNanos(long nanos)/parkUntil(long millis) 等超时时间的方法后进入的状态。

线程启动借助 Thread 类的 start() 方法。

## Sleep 和 Wait 区别

- 类不同，前者属于 Thread 类，后者是 Object 类；
- 使用范围不同，前者任意地方，后者只能在同步代码块中；
- **前者不会释放锁，后者会释放锁**；
- 前者时间到时被自动唤醒，后者必须通过 notify() 方法唤醒；
- 作用不同，前者用于暂停线程，后者用于线程交互。

## Java ”锁“事

<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png">

## synchronized 关键字和 Lock 接口实现锁的区别

<img src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png">

## SynchronizedList 和 SynchronizedMap

SynchronizedList 本质上就是将所修饰的 List 类的每项操作都包含在一个同步代码块中，但有一个例外，就是 iterator() 方法，官方建议，如果要对 SynchronizedList 进行遍历，必须由用户自己施加同步措施，同步锁对象为  SynchronizedList() 方法返回的对象，来防止遍历过程中的增加和删除。

SynchronizedMap 同理，同样在遍历 key、value、entry 集合时，也需要用户自己进行同步操作，锁对象是 SynchronizedMap() 方法返回的对象。

参考：

[[Collections.synchronizedList使用](https://www.cnblogs.com/hongdada/p/10931891.html)](https://www.cnblogs.com/hongdada/p/10931891.html)

## 如何理解线程安全和不安全

线程安全指的是当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

- 绝对线程安全：强调调用者无需额外操作；
- 相对线程安全：单次操作保证安全，多次操作不保证安全。

## 如何创建线程池

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

- corePoolSize：核心线程数；
- maximumPoolSize：最大线程数，最大线程数和核心线程数之间的差值就是救济线程数；
- keepAliveTime：救急线程存活时间；
- unit：存活时间单位；
- workQueue：任务阻塞队列，当核心线程都被启用，且阻塞队列有空余时，任务将被放入阻塞队列中等待被执行；
- threadFactory：线程工厂，提供合适的线程名称；
- handler：拒绝策略，当核心线程、救急线程都在执行任务，并且阻塞队列容量为零时，将启动拒绝策略。
  - 拒绝新到达的任务并抛出异常；
  - 拒绝新到达的任务不抛出异常；
  - 舍弃队头任务，将新任务放入队尾；
  - 由递交任务的线程自己执行任务。

## 线程池状态

- RUNNING：能接受新任务，也能处理阻塞队列中的任务；
- SHUTDOWN：不接受新任务，但会处理阻塞队列中的任务；
- STOP：不接受新任务，也不处理阻塞队列中的任务，并中断正在执行的任务；
- TIDYING：所有任务都已终止，**有效线程数**为 0。
- TERMINATED

<img src="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png">

## execute() 和 submit() 区别

区别在于后者将提供一个 Future 类对象，你可以通过该对象来管理你所提交的任务。

使用 cancel(boolean mayInterruptIfRunning) 方法来尝试取消任务，如果任务尚未开始，则任务将不会被执行，如果任务已经启动，则可以根据参数 mayInterruptIfRunning 来确定是否中断正在执行的线程以尝试停止该任务。

使用 get() 方法来阻塞等待任务完成。

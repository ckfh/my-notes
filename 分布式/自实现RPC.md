# 笔记

## 实现了基于JDK原生序列化与动态代理的远程调用

### 个人理解

使用dubbo框架时，接口引用就好像被”自动注入“了一个实现类，我们调用接口方法时，能够正常调用方法并返回结果，但实际上这个实现类的定义并不在客户端模块中。

自定义实现时，由于没有框架的帮助，我们需要自己来给接口引用“注入”实现类，但是这个实现类定义在本地是不存在的，我们无法实例化并引用。

**接口无法实例化，实现类定义又不存在**，静态实现行不通，因此想到了动态代理，在运行期间动态创建一个接口实例。

当调用接口方法时，实际上是在调用InvocationHandler的invoke方法。

讲道理，我们完全可以在InvocationHandler的invoke方法里复现远程实现类的逻辑，但这完全就是多次一举，更何况当远程实现类需要依赖远程其它功能时，难道也要一一复现吗。

所以就想到了socket通信，将方法定义和参数发送给远程应用，远程应用找到指定方法传参调用后将结果发回给本地。

通过Proxy.newProxyInstance()创建接口实例 => 接口的方法调用 => InvocationHandler的invoke方法 => 进程通信 => 获得结果返回。

### 要点

1. 因为使用的是对象流来封装socket对象提供的字节流，因此传输对象必须实现Serializable接口，如果传输对象本身携带了其它对象参数，这些对象同样需要实现Serializable接口。
2. 客户端发送RpcRequest对象到服务端，在其中封装接口名称、方法名称、方法参数类型、方法具体参数，从服务端接收RpcResponse对象，在其中封装状态码、状态消息、返回值。
3. 在客户端调用接口方法前，我们需要手动”注入“接口实例，否则方法调用将失败。但是本地不存在实现类的定义，因此借助动态代理在运行期间构建接口实例。
4. 获取到动态代理对象后，调用接口方法转为调用InvocationHandler的invoke方法，在invoke方法内部完成socket通信，传输RpcRequest对象，接收RpcResponse对象。
5. 服务端在注册一个服务实例后，立马开始监听，一旦有客户端请求到达，启用线程池线程，传入服务实例和socket对象，执行线程run方法。
6. 在run方法内部完成socket通信，接收RpcRequest对象，获取参数，利用反射完成方法调用，将返回值封装到RpcResponse对象中，传输RpcResponse对象。

## 支持多个服务的注册

上述章节中服务一旦注册便立马开启服务端的监听，即一个服务器只能注册一个服务，此章节将服务的注册和服务端启动分离，即服务端只负责启动，不负责注册，使得服务端可以提供多个服务。

### 要点

1. 为了分离服务注册功能，需要一张服务注册表，它能够根据服务名称(接口的完整类名)获取到服务的具体实现，此处暂定一个接口只能有一个对象提供服务。
2. 为了降低耦合度，将注册表作为服务端实例的参数，在创建服务端实例时，传入一个注册表对象作为该服务端的服务注册表，后续服务端将其传给线程池线程进行处理。
3. 服务端线程RequestHandlerThread负责接收RpcRequest对象，根据接口名称从注册表中获取服务实例，并调用RequestHandler对象，传入请求对象和服务实例。
4. 由RequestHandler通过反射进行方法调用。

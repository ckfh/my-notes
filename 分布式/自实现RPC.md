# 笔记

## 最简单的实现

### 个人理解

使用dubbo框架时，接口引用就好像被”自动注入“了一个实现类，我们调用接口方法时，能够正常调用方法并返回结果，但实际上这个实现类的定义并不在客户端模块中。

自定义实现时，由于没有框架的帮助，我们需要自己来给接口引用“注入”实现类，但是这个实现类定义在本地是不存在的，我们无法实例化并引用。

**接口无法实例化，实现类定义又不存在**，静态实现行不通，因此想到了动态代理，在运行期间动态创建一个接口实例。

当调用接口方法时，实际上是在调用InvocationHandler的invoke方法。

讲道理，我们完全可以在InvocationHandler的invoke方法里复现远程实现类的逻辑，但这完全就是多次一举，更何况当远程实现类需要依赖远程其它功能时，难道也要一一复现吗。

所以就想到了socket通信，将方法定义和参数发送给远程应用，远程应用找到指定方法传参调用后将结果发回给本地。

通过Proxy.newProxyInstance()创建接口实例 => 接口的方法调用 => InvocationHandler的invoke方法 => 进程通信 => 获得结果返回。

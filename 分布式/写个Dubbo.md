# 笔记

## 实现了基于JDK原生序列化与动态代理的远程调用

### 个人理解

使用dubbo框架时，接口引用就好像被”自动注入“了一个实现类，我们调用接口方法时，能够正常调用方法并返回结果，但实际上这个实现类的定义并不在客户端模块中。

自定义实现时，由于没有框架的帮助，我们需要自己来给接口引用“注入”实现类，但是这个实现类定义在本地是不存在的，我们无法实例化并引用。

**接口无法实例化，实现类定义又不存在**，静态实现行不通，因此想到了动态代理，在运行期间动态创建一个接口实例。

当调用接口方法时，实际上是在调用InvocationHandler的invoke方法。

讲道理，我们完全可以在InvocationHandler的invoke方法里复现远程实现类的逻辑，但这完全就是多次一举，更何况当远程实现类需要依赖远程其它功能时，难道也要一一复现吗。

所以就想到了socket通信，将方法定义和参数发送给远程应用，远程应用找到指定方法传参调用后将结果发回给本地。

通过Proxy.newProxyInstance()创建接口实例 => 接口的方法调用 => InvocationHandler的invoke方法 => 进程通信 => 获得结果返回。

### 要点

1. 因为使用的是对象流来封装socket对象提供的字节流，因此传输对象必须实现Serializable接口，如果传输对象本身携带了其它对象参数，这些对象同样需要实现Serializable接口。
2. 客户端发送RpcRequest对象到服务端，在其中封装接口名称、方法名称、方法参数类型、方法具体参数，从服务端接收RpcResponse对象，在其中封装状态码、状态消息、返回值。
3. 在客户端调用接口方法前，我们需要手动”注入“接口实例，否则方法调用将失败。但是本地不存在实现类的定义，因此借助动态代理在运行期间构建接口实例。
4. 获取到动态代理对象后，调用接口方法转为调用InvocationHandler的invoke方法，在invoke方法内部完成socket通信，传输RpcRequest对象，接收RpcResponse对象。
5. 服务端在注册一个服务实例后，立马开始监听，一旦有客户端请求到达，启用线程池线程，传入服务实例和socket对象，执行线程run方法。
6. 在run方法内部完成socket通信，接收RpcRequest对象，获取参数，利用反射完成方法调用，将返回值封装到RpcResponse对象中，传输RpcResponse对象。

## 支持多个服务的注册

上述章节中服务一旦注册便立马开启服务端的监听，即一个服务器只能注册一个服务，此章节将服务的注册和服务端启动分离，即服务端只负责启动，不负责注册，使得服务端可以提供多个服务。

### 要点

1. 为了分离服务注册功能，需要一张服务注册表，它能够根据服务名称(接口的完整类名)获取到服务的具体实现，此处暂定一个接口只能有一个对象提供服务。
2. 为了降低耦合度，将注册表作为服务端实例的参数，在创建服务端实例时，传入一个注册表对象作为该服务端的服务注册表，后续服务端将其传给线程池线程进行处理。
3. 服务端线程RequestHandlerThread负责接收RpcRequest对象，根据接口名称从注册表中获取服务实例，并调用RequestHandler对象，传入请求对象和服务实例。
4. 由RequestHandler通过反射进行方法调用。

## 随手记

Dubbo是一个RPC框架，该框架可以让我们快速开发基于RPC的分布式应用程序同时还保证了连通性、健壮性、伸缩性、升级性。

RPC(Remote Procedure Call)是一种概念，即远程过程调用，它体现了一种编程思想，是抽象的。

RPC的意义在于让我们调用远程服务时就像调用本地服务那样简单，好像这个服务就是本地存在的。

要实现RPC功能，首先需要解决的就是服务应用之间的通信问题，通过通信，双方交换信息，实现服务调用及结果返回。

RPC实际上是进程间通信的一种，Java跨进程通信就涉及到网络编程，而涉及网络编程，就涉及到TCP(Socket)和UDP(Datagram)编程，通过TCP和UDP可以实现节点和节点之间的数据传输。

更进一步，服务应用之间通过自定义上层协议，通过自定义一个完善的应用层协议，可以帮助我们更好地完成网络通信。

而Java网络编程中的王者框架，Netty，它基于异步、事件驱动的方式，帮我们规避掉了并发网络编程中的诸多问题，尽而快速开发可维护、高性能的服务器和客户端。

所以RPC告诉我们一种设计理念，而我们需要自己编程来实现这个理念。

通信时上层协议选择HTTP协议可以吗，当然可以，只要能够顺利地将请求服务信息封装好发送出去，拿到响应后取出请求结果也是完成一次了RPC过程。

但是HTTP协议更多地是用于web服务场景下，在一些特定场景下，首先HTTP协议头中的诸多字段实际上是冗余的，而且对于HTTP协议的报文格式，它比起二进制格式来说更增加通信开销。

应该针对具体的服务场景和服务特点来选择协议，比如浏览器请求某网站显示页面，其中包含了HTML页面，这明显就是HTTP协议最适合的场景，比如Redis，它就是单纯的一条命令来获取数据，数据内容也没有HTML页面那么复杂，因此Redis就采用了自己的一种协议，通过简单的长度加命令的格式就完成了客户端和服务端之间的交互。

但是对于异构系统通信来说HTTP协议是最适合的存在。

注意：编解码器使用的不一定是相同的序列化方式，因为两者没有必要的联系。

编码器负责消息出站，解码器负责消息入站。

消息出站的序列化方式由消息传递方指定。

消息入站的序列化方式是从协议中获取序列化方式代码手动找到指定的反序列化方法。

(BUG)解码器之前没有设置LengthFieldBasedFrameDecoder，如果消息发生粘包或半包，此时剩余数据不足解码器解码出来的数据内容长度，将导致消息内容缺失。

增加了LengthFieldBasedFrameDecoder之后，只有包含指定内容长度的数据才能被后续的解码器接收。

Nacos1.4.1提供了服务实例的健康检测机制，自动清除无法继续提供服务的节点信息，防止客户端获取到已经关闭的服务端信息。就是所谓的保活，一小段时间联系不上某个服务器就会自动注销。

向Nacos注册服务时，服务提供端只要提供服务接口名称以及地址端口。

服务端启动时，除了向注册中心注册所要提供的服务，还要在本地记录已提供的服务，方便服务端进行方法反射调用时找到指定方法和实例。

服务端和客户端可以指定不同的序列化器用来序列化消息对象到字节数组，而对方在接收到字节数组后，会根据协议格式获取到对方的序列化器，调用反序列化方法即可得到具体消息对象。

流程：

start=>Netty客户端=>HelloService.hello(HelloObject object)=>RpcClientProxy.invoke(...)=>NettyClient.sendRequest(RpcRequest rpcRequest)=>NacosServiceDiscovery.lookupService(String serviceName)=>ChannelProvider.get(InetSocketAddress inetSocketAddress, CommonSerializer serializer)=>writeAndFlush=>Netty服务端=>NettyServerHandler.channelRead0(ChannelHandlerContext ctx, RpcRequest msg)=>RequestHandler.handle(RpcRequest rpcRequest)=>writeAndFlush=>Netty客户端=>NettyClientHandler.channelRead0(ChannelHandlerContext ctx, RpcResponse msg)=>CompletableFuture.get()=>RpcResponse.getData()=>end

JACKSON不只可以用来转XML，还可以转JSON，还可以转BYTE数组，而且JACKSON可以理解为它是将JSON字符串转成了BYTE数组。

查看源码可以知道JACKSON转JSON和转BYTE数组内部用的都是同一个方法对Java对象进行了转换，然后在BYTE方法的最后转成了字节数组。

所以说序列化传输本质上还是需要BYTE数组才行。

序列化就是将对象转为BYTE数组，这样才能在网络中进行传输。反序列化就是将BYTE数组转为对象，这样才能在应用程序中被进一步使用。

Java自带的对象输入输出流就是用于序列化的工具。

常见的错误有：

- 找不到定义类
- 找得到定义类，但字段域匹配错误，这通常发生在类的定义发生了改变，比如类结构后期进行了升级，添加了新的字段，但是发送方和接收方的类定义没有进行同步。
    - 为了避免该错误，通常会定义serialVersionUID，它通过类的信息来构造，即使我们自己没有定义，JDK也会自动帮我们生成，如果serialVersionUID值不匹配，会自动阻止不匹配的class版本。

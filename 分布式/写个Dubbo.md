# 笔记

## 实现了基于JDK原生序列化与动态代理的远程调用

### 个人理解

使用dubbo框架时，接口引用就好像被”自动注入“了一个实现类，我们调用接口方法时，能够正常调用方法并返回结果，但实际上这个实现类的定义并不在客户端模块中。

自定义实现时，由于没有框架的帮助，我们需要自己来给接口引用“注入”实现类，但是这个实现类定义在本地是不存在的，我们无法实例化并引用。

**接口无法实例化，实现类定义又不存在**，静态实现行不通，因此想到了动态代理，在运行期间动态创建一个接口实例。

当调用接口方法时，实际上是在调用InvocationHandler的invoke方法。

讲道理，我们完全可以在InvocationHandler的invoke方法里复现远程实现类的逻辑，但这完全就是多次一举，更何况当远程实现类需要依赖远程其它功能时，难道也要一一复现吗。

所以就想到了socket通信，将方法定义和参数发送给远程应用，远程应用找到指定方法传参调用后将结果发回给本地。

通过Proxy.newProxyInstance()创建接口实例 => 接口的方法调用 => InvocationHandler的invoke方法 => 进程通信 => 获得结果返回。

### 要点

1. 因为使用的是对象流来封装socket对象提供的字节流，因此传输对象必须实现Serializable接口，如果传输对象本身携带了其它对象参数，这些对象同样需要实现Serializable接口。
2. 客户端发送RpcRequest对象到服务端，在其中封装接口名称、方法名称、方法参数类型、方法具体参数，从服务端接收RpcResponse对象，在其中封装状态码、状态消息、返回值。
3. 在客户端调用接口方法前，我们需要手动”注入“接口实例，否则方法调用将失败。但是本地不存在实现类的定义，因此借助动态代理在运行期间构建接口实例。
4. 获取到动态代理对象后，调用接口方法转为调用InvocationHandler的invoke方法，在invoke方法内部完成socket通信，传输RpcRequest对象，接收RpcResponse对象。
5. 服务端在注册一个服务实例后，立马开始监听，一旦有客户端请求到达，启用线程池线程，传入服务实例和socket对象，执行线程run方法。
6. 在run方法内部完成socket通信，接收RpcRequest对象，获取参数，利用反射完成方法调用，将返回值封装到RpcResponse对象中，传输RpcResponse对象。

## 支持多个服务的注册

上述章节中服务一旦注册便立马开启服务端的监听，即一个服务器只能注册一个服务，此章节将服务的注册和服务端启动分离，即服务端只负责启动，不负责注册，使得服务端可以提供多个服务。

### 要点

1. 为了分离服务注册功能，需要一张服务注册表，它能够根据服务名称(接口的完整类名)获取到服务的具体实现，此处暂定一个接口只能有一个对象提供服务。
2. 为了降低耦合度，将注册表作为服务端实例的参数，在创建服务端实例时，传入一个注册表对象作为该服务端的服务注册表，后续服务端将其传给线程池线程进行处理。
3. 服务端线程RequestHandlerThread负责接收RpcRequest对象，根据接口名称从注册表中获取服务实例，并调用RequestHandler对象，传入请求对象和服务实例。
4. 由RequestHandler通过反射进行方法调用。

## 随手记

Dubbo是一个RPC框架，该框架可以让我们快速开发基于RPC的分布式应用程序同时还保证了连通性、健壮性、伸缩性、升级性。

RPC(Remote Procedure Call)是一种概念，即远程过程调用，它体现了一种编程思想，是抽象的。

RPC的意义在于让我们调用远程服务时就像调用本地服务那样简单，好像这个服务就是本地存在的。

要实现RPC功能，首先需要解决的就是服务应用之间的通信问题，通过通信，双方交换信息，实现服务调用及结果返回。

RPC实际上是进程间通信的一种，Java跨进程通信就涉及到网络编程，而涉及网络编程，就涉及到TCP(Socket)和UDP(Datagram)编程，通过TCP和UDP可以实现节点和节点之间的数据传输。

更进一步，服务应用之间通过自定义上层协议，通过自定义一个完善的应用层协议，可以帮助我们更好地完成网络通信。

而Java网络编程中的王者框架，Netty，它基于异步、事件驱动的方式，帮我们规避掉了并发网络编程中的诸多问题，尽而快速开发可维护、高性能的服务器和客户端。

所以RPC告诉我们一种设计理念，而我们需要自己编程来实现这个理念。

通信时上层协议选择HTTP协议可以吗，当然可以，只要能够顺利地将请求服务信息封装好发送出去，拿到响应后取出请求结果也是完成一次了RPC过程。

但是HTTP协议更多地是用于web服务场景下，在一些特定场景下，首先HTTP协议头中的诸多字段实际上是冗余的，而且对于HTTP协议的报文格式，它比起二进制格式来说更增加通信开销。

应该针对具体的服务场景和服务特点来选择协议，比如浏览器请求某网站显示页面，其中包含了HTML页面，这明显就是HTTP协议最适合的场景，比如Redis，它就是单纯的一条命令来获取数据，数据内容也没有HTML页面那么复杂，因此Redis就采用了自己的一种协议，通过简单的长度加命令的格式就完成了客户端和服务端之间的交互。

但是对于异构系统通信来说HTTP协议是最适合的存在。

注意：编解码器使用的不一定是相同的序列化方式，因为两者没有必要的联系。

编码器负责消息出站，解码器负责消息入站。

消息出站的序列化方式由消息传递方指定。

消息入站的序列化方式是从协议中获取序列化方式代码手动找到指定的反序列化方法。

~~(BUG)解码器之前没有设置LengthFieldBasedFrameDecoder，如果消息发生粘包或半包，此时剩余数据不足解码器解码出来的数据内容长度，将导致消息内容缺失~~。

直接让解码器继承 ReplayingDecoder ，就可以解决上述出现的问题了。

Nacos1.4.1提供了服务实例的健康检测机制，自动清除无法继续提供服务的节点信息，防止客户端获取到已经关闭的服务端信息。就是所谓的保活，一小段时间联系不上某个服务器就会自动注销。

向Nacos注册服务时，服务提供端只要提供服务接口名称以及地址端口。

服务端启动时，除了向注册中心注册所要提供的服务，还要在本地记录已提供的服务，方便服务端进行方法反射调用时找到指定方法和实例。

服务端和客户端可以指定不同的序列化器用来序列化消息对象到字节数组，而对方在接收到字节数组后，会根据协议格式获取到对方的序列化器，调用反序列化方法即可得到具体消息对象。

流程：

start=>Netty客户端=>HelloService.hello(HelloObject object)=>RpcClientProxy.invoke(...)=>NettyClient.sendRequest(RpcRequest rpcRequest)=>NacosServiceDiscovery.lookupService(String serviceName)=>ChannelProvider.get(InetSocketAddress inetSocketAddress, CommonSerializer serializer)=>writeAndFlush=>Netty服务端=>NettyServerHandler.channelRead0(ChannelHandlerContext ctx, RpcRequest msg)=>RequestHandler.handle(RpcRequest rpcRequest)=>writeAndFlush=>Netty客户端=>NettyClientHandler.channelRead0(ChannelHandlerContext ctx, RpcResponse msg)=>CompletableFuture.get()=>RpcResponse.getData()=>end

JACKSON不只可以用来转XML，还可以转JSON，还可以转BYTE数组，而且JACKSON可以理解为它是将JSON字符串转成了BYTE数组。

查看源码可以知道JACKSON转JSON和转BYTE数组内部用的都是同一个方法对Java对象进行了转换，然后在BYTE方法的最后转成了字节数组。

所以说序列化传输本质上还是需要BYTE数组才行。

序列化就是将对象转为BYTE数组，这样才能在网络中进行传输。反序列化就是将BYTE数组转为对象，这样才能在应用程序中被进一步使用。

Java自带的对象输入输出流就是用于序列化的工具。

常见的错误有：

- 找不到定义类
- 找得到定义类，但字段域匹配错误，这通常发生在类的定义发生了改变，比如类结构后期进行了升级，添加了新的字段，但是发送方和接收方的类定义没有进行同步。
    - 为了避免该错误，通常会定义serialVersionUID，它通过类的信息来构造，即使我们自己没有定义，JDK也会自动帮我们生成，如果serialVersionUID值不匹配，会自动阻止不匹配的class版本。

线程池工厂类是用来提供给 Socket 编程中服务端为监听到的每个连接建立线程用的。

NacosUtil.address = address;因为！！！你两个server进程，注意是进程！是互相不影响的，你不是两个线程，你是两个进程，两个进程本来就会各自持有一个NacosUtil对象，连内存区域都不是一起的。

实现了 JSON、Kryo、Hessian 和 Protobuf 的序列化：

- JSON 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似 XML，JSON 比 XML 更小、更快更容易解析。JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。
- Kryo 是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象=>字节=>对象的拷贝。Kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。
- Hessian 是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java、Python、C++、.Net、C#、D、Erlang、PHP、Ruby、Object-C 等，它的序列化和反序列化也是非常高效。传输速度较慢，序列化后的体积较大。
- Protobuf（Protocol Buffers）是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 Protocol Compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。

服务扫描要点：首先拿到启动类，判断是否有ServiceScan注解，如果注解内没有值，则默认以启动类所在包及其子包作为服务类所在的位置，借助反射工具拿到类对象集合，逐一判断是否有Service注解，如果有则创建对应的服务类对象，之后查看Service注解是否有值，如果有值，则将其作为服务类对象的接口名称进行服务注册，如果没有值，则获取服务类对象的所有接口，逐一进行服务注册。

Socket读取和写入流的辅助类ObjectReader和ObjectWriter：每读取4个字节到字节数组时，需要进行bytes到int的转换，这里的转换不是说将数组中的每个字节转换成int，而是说要将整个字节数组理解为一个整体，索引0的字节就代表4个字节中的第一个字节，依此类推，最后组成一个完整的4个字节后，然后转换成整数才能进行对比。同理将一个整数转换为4个字节的字节数组时，也是将整数进行无符号右移，然后强转为byte类型时会自动截断掉超出一个字节位数外的部分。

反射调用返回结果分析：要么返回结果对象，要么返回失败响应对象，并且都会被封装在成功响应对象内部，因为只要通信成功，就是返回200状态码。

用CompletableFuture代替Future：是因为希望Future本身能充当一个容器的作用，也就是Set功能，这个在CompletableFuture和Netty Promise都是有提供的。

获取启动类名称是借助了Throwable对象的getStackTrace()方法，因为方法调用是以栈的形式先进后出调用，只要获取到最底部的StackTraceElement，然后通过getClassName()就能拿到启动类名。

# 笔记

## 进程调度

进程调度算法的评价标准：

- CPU利用率=忙碌的时间/总时间
- 系统吞吐率=总共完成了多少作业/总共花了多少时间
- 周转时间
    - 周转时间=作业完成时间-作业提交时间
    - 平均周转时间=各作业周转时间之和/作业数
    - 带权周转时间=作业周转时间/作业实际运行时间
    - 平均带权周转时间=各作业带权周转时间之和/作业数
- 等待时间
    - 等待时间=等待被服务的时间之和
    - 平均等待时间=各个作业等待时间的平均值
- 响应时间=从用户提交请求到首次产生响应所用的时间

进程调度算法：

先来先服务

- 优点：公平，实现简单
- 缺点：对长作业有利，对长作业之后的短作业不利。

不会导致饥饿，因为长作业迟早也有运行结束的一刻，此时短作业就可以得到运行。

短作业优先

有可抢占版本。

- 优点：”最短的“平均等待和周转时间。
- 缺点：不公平，对短作业有利，长作业不利。可能产生饥饿现象，另外运行时间由用户提供，不一定真实，不一定能做到真正的短作业优先。

高响应比优先

响应比=(等待时间+要求服务时间)/要求服务时间

综合考虑了等待时间和运行时间(要求服务时间)，等待时间相同时，要求服务时间短的优先(短作业优先的优点)，要求服务时间相同时，等待时间长的优先(先来先服务的优点)，对于长作业来说，随着等待时间越来越就，响应比越来越大，从而避免了长作业饥饿的问题。

## 指令流水线

指令流水线是为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式。

例如一条指令要执行要经过3个阶段：取指令、译码、执行，每个阶段都要花费一个机器周期，如果没有采用流水线技术，那么这条指令执行需要3个机器周期；如果采用了指令流水线技术，那么当这条指令完成“取指”后进入“译码”的同时，下一条指令就可以进行“取指”了，这样就提高了指令的执行效率。

## 死锁

互斥条件：该资源任意一个时刻只由一个线程占用。(这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）)

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。(一次性申请所有的资源)

不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。(占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源)

循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。(靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件)

## I/O多路复用

一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个CPU并发多个进程，所以也叫做时分多路复用。

### select/poll

它们都只会告诉你有几个通道准备好了，但是不会告诉你具体是哪几个通道。所以，一旦知道有通道准备好以后，自己还是需要进行一次扫描。

将文件描述符集合从用户态拷贝到内核态，内核态遍历检查是否有网络事件发生，如果有事件发生，则标记为可读或者可写，然后将集合从内核态再拷贝回用户态，用户态遍历检查找到可读或者可写的socket，然后进行处理。(2次遍历➕2次拷贝)

select的文件描述符集合有长度限制，而poll没有。

### epoll

能直接返回具体的准备好的通道。

在内核中用红黑树跟踪所有待检测的文件描述符，把需要监控的socket添加到红黑树中，epoll基于事件驱动，内核里维护了一个链表记录就绪事件，当某个socket有事件就绪，通过回调函数将其加入到链表当中，当用户调用epoll_wait()时，只会返回有事件就绪的文件描述符。

而就绪链表仍需要从内核态拷贝到用户态再进行遍历。

epoll支持两种事件触发方式：边缘触发和水平触发。

边缘触发：当监控的socket有可读事件发生时，服务器只会从epoll_wait()中苏醒一次，即使进程本身没有调用read函数从内核中读取数据，也依然只苏醒一次，因此要保证程序一次性将内核缓冲区的数据读取完。

水平触发：当监控的socket有可读事件发生时，服务器不断地从epoll_wait()中苏醒，直到内核缓冲区数据被read函数读取完才结束。

水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。

**JavaNIO底层用的就是水平触发模式，事件发生后，要么处理，要么取消，否则下次该事件仍会触发**。

一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少epoll_wait的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

select/poll只有水平触发模式，epoll默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

## I/O模型

I/O模型分为两大类：

1. 同步I/O(阻塞I/O、非阻塞I/O、基于非阻塞I/O的多路复用)
2. 异步I/O

阻塞等待需要等待两个步骤：1.内核将数据准备好。2.数据从内核态拷贝到用户态。

阻塞I/O就是应用进程步骤1和2都需要等待。

非阻塞I/O就是应用进程可以跳过步骤1只需要等待步骤2，但是执行步骤2之前会不断轮询数据是否已经准备好。

基于非阻塞I/O的多路复用也是跳过步骤1只需要等待步骤2，但是它不需要自己轮询数据是否准备好，而是由内核来通知进程数据是否准备好。

上面三个步骤的共同特点就是，将数据从内核态拷贝到用户态这一步骤都需要进程自己来完成，因此被分类为同步I/O。

而异步I/O就是拷贝数据这一步骤也不需要，内核直接帮你拷贝到位，然后通知进程，进程直接读取数据即可。

## 进程通信

1. 管道(匿名/有名)
2. 消息队列
3. 共享内存
4. socket(跨主机)
5. 信号量用来实现进程同步
6. 信号用来向进程发出控制指令

## 王道笔记

### 进程

- 进程互斥，为临界区代码前后增加一对PV操作。
- 进程同步，遵循“前V后P”的原则，即先执行的进程对某个信号量进行V操作，后执行的进程对相同信号量进行P操作。
- 多生产和消费指的是抢占的资源多样，不是生产和消费者多个。
- 生产者-消费者问题展示了如何进行进程之间的互斥与同步操作。
- 多生产者-消费者问题展示了进程之间对多类型资源的互斥与同步操作。
- 吸烟者问题展示了“可生产多种产品的单生产者-多消费者”问题。
- 读者-写者问题展示了利用计数器来解决复杂的进程互斥问题。
- 哲学家进餐问题展示了如何避免进程因持有多个临界资源而导致的死锁问题。
- 引入管程的目的无非就是要更方便地实现进程互斥和同步。
- 发生死锁时一定有循环等待，有循环等待时不一定死锁，其意思在于，如果某个进程实际上有可替代的同类资源，它只要去申请可用的同类资源，就可以解除循环等待状态。
- 不安全状态不一定会发生死锁，其意思在于如果不安全状态下没有进程提出导致死锁的请求就不会发生死锁，而发生了死锁则一定处于不安全状态。
- 在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。
- 死锁避免和死锁预防的区别：死锁预防是设法破坏产生死锁的四个必要条件之一，严格防止死锁的出现；而死锁避免则不那么严格地限制产生死锁的必要条件存在。因为即使死锁的必要条件存在，也不一定发生死锁，死锁避免是在系统运行过程中注意避免死锁的最终发生。

### 内存

- 进程：PCB（进程信息）|程序段（指令）|数据段（数据）
- 内存地址和存储单元的关系，内存是由一个个存储单元组成的，而内存地址从0开始，每个地址对应一个存储单元。
- 现代操作系统利用动态重定位的方式来实现程序逻辑地址到物理地址的转换，所谓动态重定位是指在运行包含逻辑地址的指令时，将逻辑地址与起始地址相加得到物理地址，而起始地址则存放在重定位寄存器中。
- 中级调度(内存调度)：决定将哪个处于挂起态的进程重新调入内存运行，这需要该进程在被挂起时，保留进程PCB，并在PCB当中记录外存当中的地址，这样才能够在需要调度时重新调入。
- 内部碎片是指分配给需要10MB内存的进程20MB的内存空间，多出的10MB内存空间就是内部碎片。
- 外部碎片是指内存中某些空闲分区由于太小而难以利用。
- 分页、分段、段页都是内存空间的非连续分配管理方式。
- 分页就是将内存空间划分为固定大小的页，这些页用来存储进程的一部分，因此页比起固定分区当中分区大小要小的多。
- 一个用户进程被分为多个页，每个页都有一个页号，且其对应到内存空间中的内存块号/页框号。
- 一个进程对应一张页表，进程的每一页对应页表当中的一个页表项，每个页表项由“页号”和“块号”组成，页表记录了进程页面和实际存放的内存块之间的对应关系。
- 页表项长度相同，且页号是“隐含”的。我们只要知道页表存放的起始地址和页表项的长度，即可找到各个页号对应的页表项存放的位置。
- 基本地址变换机构会有两次访问内存的操作，第一次是访问页表拿到内存块号，第二次是访问目标内存单元。
- 快表就是增加一个寄存器，用于记录最近使用过的页表项，这是基于程序运行的局部性原理提出的概念。
- 如果快表命中，则直接访问内存当中的存储单元，未命中则先访问内存中的页表，再访问存储单元。
- 单级页表的缺点在于需要连续内存来分配页表，这和内存空间的离散分配管理方式是有冲突的，无法发挥其优点，且由程序的局部性原理，我们没必要让整个页表都常驻内存。
- 因此将单级页表离散化，按页面大小分组，为了记录分组后的单级页表，需要一个页目录表记录，这种结构也称为两级页表，而对于局部性原理的解决方式，则是在需要访问目标页面的时候，才将目标页面从外存调入内存（只有在内存当中才可以通过CPU利用指令查找内存块号），如果访问的目标页面不在内存时，这种情况被称为缺页中断，然后从外存调入内存。
- 二级页表访存逻辑地址换算流程：0号|1号|偏移量，为了访问一级页表的0号页表项，需要在一级页表的起始物理地址的基础上加上页表项索引乘以页表项长度得到0号页表项的起始物理地址，从该物理地址开始取出页表项大小的数据，该数据存放的是一个块号，这是二级页表所在的块号，因此根据该块号找到二级页表的起始地址，再根据起始地址加上页表项索引乘以页表项长度得到1号页表项的起始物理地址，从该物理地址开始取出页表项大小的数据，该数据存放的是一个块号，这是存储单元所在的块号，根据块号的起始地址加上偏移量即可得到目标存储单元的物理地址，从物理地址当中取出指令或运算数据。
- 段长指的是一个段的大小为多少，通过段内地址的位数可知最大段长，而通过物理内存大小可知基址的编码位数，两个拼接在一起就可以得到段表项的长度。
- 通过段号找到基址，再根据基址和段内偏移计算实际物理地址。
- 根据从进程PCB当中恢复段表寄存器当中的内容，即段表起始地址|段表长度，当执行某条逻辑指令时，里面包含了逻辑地址A，它的内容是段号|段内地址，根据段号和段表长度判断是否越界，如果没有越界则根据起始地址加上段表项长度乘以段号，拿到对应的段表项，此时再根据段内地址是否超出段长，如果没有超出段长，则根据段表项当中的基址，以及段内地址得到存储单元的实际物理地址。
- 分页地址空间是一维的，分段地址空间是二维的，这是从用户的角度所看到的，这是因为后者分段后，每个分段的起始地址都是0，因此既需要段号也需要段内地址，而前者即使分页后，整个内存的地址就是从0开始到结束，因此用户只要给出一个逻辑地址就能访问其中的一个存储单元。
- 段页式存储将采用一个段表寄存器用于存放段表起始地址以及段表长度，进程执行某条指令，指令当中包含逻辑地址，该逻辑地址的结构为段号|页号|页内偏移量，首先利用段表长度判断段号是否越界，之后根据段表起始地址，加上段表项长度乘以段号得到该段号对应的段表项的物理地址，取出段表项，该段表项中存放有页表长度|页表存放块号，利用页表长度判断页号是否越界，之后根据页表存放块号乘以页面大小得到该段的页表起始地址，再加上页号乘以页表项长度得到页表项的物理地址，取出页表项，该页表项中存放着内存块号，再根据内存块号和页内偏移量得到存储单元的物理地址。
- 段页式存储是二维的，用户只要给出段号和段内偏移，而系统会将段内偏移拆分为页号和页内偏移。
- 连续分配和非连续分配都是传统存储管理的方式，它们结合交换和覆盖技术能提高内存利用率以及从逻辑上扩充内存容量。
- 虚拟内存就是为了解决传统存储管理的一次性和驻留性问题，基于程序的局部性原理提出的一种技术。
- 时间局部性：指令可能再次访问；空间局部性：存储单元可能再次访问。
- 为了实现虚拟内存技术，操作系统需要提供请求调页(或请求调段)，这是当访问信息不在内存时，需要从外存调入内存，而页面置换(或段置换)功能，是当内存不够时，将暂时用不到的信息换到外存。

### 文件

- 计算机所有的操作都是在CPU上执行的，例如打开文件这个操作，系统会将文件所在目录调入内存得到目录信息，然后检索对应文件名，再将对应文件调入内存并打开，可以想象成打开文件这个操作本质上也是一个进程在CPU上执行，例如Windows的文件资源管理器，会在CPU当中建立相应的进程。
- 文件的物理结构(文件分配方式)是指文件数据应该怎样存放在外存中。
- 显式链接支持随机访问的意思是支持物理块的随机访问，虽然查询FAT表是顺序查，但是查询过程中并不需要真正访问实际的外存物理块，等待找到目标物理块时再进行外存访问。
- 很重要的一点是FAT表在开机时就会被读取并常驻内存。
- 文件是要被读取到内存当中操作的。
- 磁盘的盘面被划分成一个个磁道，一个个磁道又被划分成一个个扇区，一个扇区就是一个”磁盘块“，各个扇区存放的数据量相同，因此最内侧的扇区数据密度是最大的。
- 读写扇区必须由磁头划过相应的扇区。
- 盘面其实有多个，相互叠加，每个盘面上都有磁头在负责读写扇区，所有的磁头都是连在同一个磁壁上的，因此是”共进退“的形式。
- 所有盘面中对应的一圈圈磁道组成了一个柱面。
- (柱面号，盘面号，扇区号)定位任意一个”磁盘块“。
- CPU是不参与I/O操作的，但它会在I/O操作之前将相应的指令存放到I/O控制器中，由I/O控制器完成对IO设备的操作。
- 因此当进程需要等待IO操作的结果时，就不需要将其放在CPU上等待，而是阻塞该进程。
- 程序控制方式和中断驱动方式都需要CPU寄存器来作为中介，因此引出了DMA直接存储器存取方式。
- 前二者都是一个字一个字的输入和输出，后者是一个块一个块的输入和输出。

## 大端存储和小端存储

- 大端存储：将字节高位放置于低地址，将字节低位放置于高地址。
- 小端存储：将字节低位放置于低地址，将字节高位放置于低地址。

地址高低：0x00到0x03，就是地址从低到高。
字节高低：0x12345678，从后向前字节由低到高。

**如果字节按照大端模式进行存储，则其存放方式符合人类的阅读思维**。

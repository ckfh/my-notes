# 二分查找

## 658.找到K个最接近的元素

直观地，我们可以将数组中的元素按照与目标 x 的差的绝对值排序，排好序后前 k 个元素就是我们需要的答案。

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        // 按元素和目标值差的绝对值进行排序:
        List<Integer> ret = Arrays.stream(arr).boxed().sorted((a, b) -> a.equals(b) ? 0 : Math.abs(a - x) - Math.abs(b - x)).collect(Collectors.toList());
        // 绝对值最小的前 k 个元素就是最接近的 k 个元素:
        ret = ret.subList(0, k);
        // 二次排序的理由是题目要求结果数组有序:
        Collections.sort(ret);
        return ret;
    }
}
```

```java
class Solution {
    /**
     * 二分查找，范围从 0 到 nums.length - k 开始，
     * 如果 x 减去中间值大于中间索引加 k 的值减 x，则舍弃左半部分，
     * 否则舍弃右半部分，最后得到的左端点开始的 k 个元素就是最接近的 k 个元素。
     * 其实就是在可能的范围内不断缩小范围，直到找出最接近的 k 个元素。
     */
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> res = new ArrayList<>();
        int left = 0;
        int right = arr.length - k;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (x - arr[mid] > arr[mid + k] - x) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        for (int i = left; i < left + k; ++i) {
            res.add(arr[i]);
        }
        return res;
    }
}
```

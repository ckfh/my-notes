# 数组和字符串

## 数组简介

### 724.寻找数组的中心索引

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            // 判断左边和是否等于右边和:
            if (leftSum == sum - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        return -1;
    }
}
```

### 35.搜索插入位置

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int index = Arrays.binarySearch(nums, target);
        return index >= 0 ? index : -(index + 1);
    }
}
// 复现Java工具类中提供的二分查找方法:
class Solution {
    public int searchInsert(int[] nums, int target) {
        int index = this.helper(nums, target);
        return index >= 0 ? index : -(index + 1);
    }

    private int helper(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start <= end) {
            // 注意点一，使用移位来代替除法，可以避免加法溢出导致的错误结果:
            int mid = (start + end) >>> 1;
            int midVal = nums[mid];
            if (midVal < target) {
                start = mid + 1;
            } else if (midVal > target) {
                end = mid - 1;
            } else {
                return mid;
            }
        }
        // 注意点二，如果找不到目标值，则返回(-(insertion point) - 1):
        return -(start + 1);
    }
}
```

### 56.合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<Interval> list = new ArrayList<>();
        for (int[] interval : intervals) {
            list.add(new Interval(interval[0], interval[1]));
        }
        // 注意点一，对所有区间按照起点进行升序排序:
        Collections.sort(list);
        // 注意点二，这里使用具体实现LinkedList是为了使用getLast()方法:
        LinkedList<Interval> resultList = new LinkedList<>();
        for (Interval interval : list) {
            if (resultList.isEmpty() || resultList.getLast().right < interval.left) {
                // 当前区间左端点比最后区间右端点大，直接加入列表:
                resultList.add(interval);
            } else {
                // 当前区间左端点不比最后区间右端点大，修改最后区间右端点为两个区间中右端点的最大值:
                resultList.getLast().right = Math.max(resultList.getLast().right, interval.right);
            }
        }
        int[][] result = new int[resultList.size()][2];
        for (int i = 0; i < resultList.size(); i++) {
            result[i] = new int[]{resultList.get(i).left, resultList.get(i).right};
        }
        return result;
    }
}

class Interval implements Comparable<Interval> {
    int left;
    int right;

    public Interval(int left, int right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int compareTo(Interval o) {
        return this.left - o.left;
    }
}
```

## 二维数组简介

### 48.旋转图像

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] result = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                result[j][n - i - 1] = matrix[i][j];
            }
        }
        System.arraycopy(result, 0, matrix, 0, n);
    }
}
```

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 以对角线为轴交换元素:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
        // 以中轴线为轴交换元素:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][n - j - 1];
                matrix[i][n - j - 1] = tmp;
            }
        }
    }
}
```

### 73.矩阵置零

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean isCol = false;
        int m = matrix.length;
        int n = matrix[0].length;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                // 记录第一列是否需要置零:
                isCol = true;
            }
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        // 其它行列是否置零只要查看所在行列的第一个元素是否为零:
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        // 起始元素为零作为第一行置零的标记:
        if (matrix[0][0] == 0) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
        // 第一列置零使用单独的标记:
        if (isCol) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

### 498.对角线遍历

```java
class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return new int[]{};
        }
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[] res = new int[rows * cols];
        int row = 0;
        int col = 0;
        for (int i = 0; i < res.length; i++) {
            res[i] = matrix[row][col];
            if ((row + col) % 2 == 0) {
                // 偶数层向上遍历
                if (col == cols - 1) {
                    // 向上遍历碰到右边墙壁，往下移动一格准备奇数层向下遍历
                    row++;
                } else if (row == 0) {
                    // 向上遍历碰到上边墙壁，往右移动一格准备奇数层向下遍历
                    col++;
                } else {
                    // 向上遍历
                    row--;
                    col++;
                }
            } else {
                // 奇数层向下遍历
                if (row == rows - 1) {
                    // 向下遍历碰到下边墙壁，往右移动一格准备偶数层向上遍历
                    col++;
                } else if (col == 0) {
                    // 向下遍历碰到左边墙壁，往下移动一格准备偶数层向上遍历
                    row++;
                } else {
                    // 向下遍历
                    row++;
                    col--;
                }
            }
        }
        return res;
    }
}
```

## 字符串简介

### 14.最长公共前缀

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return "";
        }
        if (strs.length == 1) {
            return strs[0];
        }
        String commonPrefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            int j = 0;
            for (; j < commonPrefix.length() && j < strs[i].length(); j++) {
                if (commonPrefix.charAt(j) != strs[i].charAt(j)) {
                    break;
                }
            }
            commonPrefix = commonPrefix.substring(0, j);
            if ("".equals(commonPrefix)) {
                return "";
            }
        }
        return commonPrefix;
    }
}
```

### 5.最长回文子串

```java
class Solution {
    // 暴力解法
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int maxLen = 1;
        int begin = 0;
        char[] charArray = s.toCharArray();
        // 枚举所有长度严格大于 1 的子串，注意 maxLen 初始值为 1
        // 注意这里两个索引变量的最大值
        for (int i = 0; i < len - 1; i++) {
            for (int j = i + 1; j < len; j++) {
                if (j - i + 1 > maxLen && isPalindrome(charArray, i, j)) {
                    // 注意这里先判断长度是否更长，可以帮助我们节省掉很多不必要的过程
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }

    private boolean isPalindrome(char[] charArray, int left, int right) {
        while (left < right) {
            if (charArray[left] != charArray[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

```java
public class Solution {
    // 中心扩散法
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int maxLen = 1;
        String res = s.substring(0, 1);
        // 中心位置枚举到 len - 2 即可
        for (int i = 0; i < len - 1; i++) {
            String oddStr = centerSpread(s, i, i);
            String evenStr = centerSpread(s, i, i + 1);
            String maxLenStr = oddStr.length() > evenStr.length() ? oddStr : evenStr;
            if (maxLenStr.length() > maxLen) {
                maxLen = maxLenStr.length();
                res = maxLenStr;
            }
        }
        return res;
    }

    private String centerSpread(String s, int left, int right) {
        // left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数
        // right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数
        int len = s.length();
        int i = left;
        int j = right;
        while (i >= 0 && j < len) {
            if (s.charAt(i) == s.charAt(j)) {
                i--;
                j++;
            } else {
                break;
            }
        }
        // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j
        return s.substring(i + 1, j);
    }
}
```

```java
public class Solution {
    // 动态规划
    // 状态：dp[i][j] 表示子串 s[i..j] 是否为回文子串
    // 转移方程：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
    // 边界条件：j - 1 - (i + 1) + 1 < 2，整理得 j - i < 3
    // 比起暴力解法，动态规划快就快在每一步的计算都尽可能地使用了前面的计算结果
    // 初始化：dp[i][i] = true，对角线即单个字符肯定是回文子串，但实际上在填表时对角线并不会被参考
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i, j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        char[] charArray = s.toCharArray();
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        // 动态规划实际上就是在填一个二维表格
        // 这里是先按列后按行进行填表，这是因为 dp[i][j] 参考它左下方的值
        for (int j = 1; j < len; j++) {
            for (int i = 0; i < j; i++) {
                if (charArray[i] != charArray[j]) {
                    // 两端的字符不相等，则 s[i, j] 不是回文串
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        // 当 j - 1 - (i + 1) + 1 < 2 时，则 s[i, j] 肯定是回文串
                        dp[i][j] = true;
                    } else {
                        // 当子串边界不满足上述条件时，还需要根据 s[i+1, j-1] 是否是回文串进行判断
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

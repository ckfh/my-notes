# 数组和字符串

## 数组简介

### 724.寻找数组的中心索引

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            // 判断左边和是否等于右边和:
            if (leftSum == sum - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        return -1;
    }
}
```

### 35.搜索插入位置

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int index = Arrays.binarySearch(nums, target);
        return index >= 0 ? index : -(index + 1);
    }
}
// 复现Java工具类中提供的二分查找方法:
class Solution {
    public int searchInsert(int[] nums, int target) {
        int index = this.helper(nums, target);
        return index >= 0 ? index : -(index + 1);
    }

    private int helper(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start <= end) {
            // 注意点一，使用移位来代替除法，可以避免加法溢出导致的错误结果:
            int mid = (start + end) >>> 1;
            int midVal = nums[mid];
            if (midVal < target) {
                start = mid + 1;
            } else if (midVal > target) {
                end = mid - 1;
            } else {
                return mid;
            }
        }
        // 注意点二，如果找不到目标值，则返回(-(insertion point) - 1):
        return -(start + 1);
    }
}
```

### 56.合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<Interval> list = new ArrayList<>();
        for (int[] interval : intervals) {
            list.add(new Interval(interval[0], interval[1]));
        }
        // 注意点一，对所有区间按照起点进行升序排序:
        Collections.sort(list);
        // 注意点二，这里使用具体实现LinkedList是为了使用getLast()方法:
        LinkedList<Interval> resultList = new LinkedList<>();
        for (Interval interval : list) {
            if (resultList.isEmpty() || resultList.getLast().right < interval.left) {
                // 当前区间左端点比最后区间右端点大，直接加入列表:
                resultList.add(interval);
            } else {
                // 当前区间左端点不比最后区间右端点大，修改最后区间右端点为两个区间中右端点的最大值:
                resultList.getLast().right = Math.max(resultList.getLast().right, interval.right);
            }
        }
        int[][] result = new int[resultList.size()][2];
        for (int i = 0; i < resultList.size(); i++) {
            result[i] = new int[]{resultList.get(i).left, resultList.get(i).right};
        }
        return result;
    }
}

class Interval implements Comparable<Interval> {
    int left;
    int right;

    public Interval(int left, int right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int compareTo(Interval o) {
        return this.left - o.left;
    }
}
```

## 二维数组简介

### 48.旋转图像

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] result = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                result[j][n - i - 1] = matrix[i][j];
            }
        }
        System.arraycopy(result, 0, matrix, 0, n);
    }
}
```

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 以对角线为轴交换元素:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
        // 以中轴线为轴交换元素:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][n - j - 1];
                matrix[i][n - j - 1] = tmp;
            }
        }
    }
}
```

### 73.矩阵置零

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean isCol = false;
        int m = matrix.length;
        int n = matrix[0].length;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                // 记录第一列是否需要置零:
                isCol = true;
            }
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        // 其它行列是否置零只要查看所在行列的第一个元素是否为零:
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        // 起始元素为零作为第一行置零的标记:
        if (matrix[0][0] == 0) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
        // 第一列置零使用单独的标记:
        if (isCol) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

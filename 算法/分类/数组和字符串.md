# 数组和字符串

## 数组简介

### 724.寻找数组的中心索引

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            // 判断左边和是否等于右边和:
            if (leftSum == sum - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        return -1;
    }
}
```

### 35.搜索插入位置

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int index = Arrays.binarySearch(nums, target);
        return index >= 0 ? index : -(index + 1);
    }
}
// 复现Java工具类中提供的二分查找方法:
class Solution {
    public int searchInsert(int[] nums, int target) {
        int index = this.helper(nums, target);
        return index >= 0 ? index : -(index + 1);
    }

    private int helper(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start <= end) {
            // 注意点一，使用移位来代替除法，可以避免加法溢出导致的错误结果:
            int mid = (start + end) >>> 1;
            int midVal = nums[mid];
            if (midVal < target) {
                start = mid + 1;
            } else if (midVal > target) {
                end = mid - 1;
            } else {
                return mid;
            }
        }
        // 注意点二，如果找不到目标值，则返回(-(insertion point) - 1):
        return -(start + 1);
    }
}
```

### 56.合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<Interval> list = new ArrayList<>();
        for (int[] interval : intervals) {
            list.add(new Interval(interval[0], interval[1]));
        }
        // 注意点一，对所有区间按照起点进行升序排序:
        Collections.sort(list);
        // 注意点二，这里使用具体实现LinkedList是为了使用getLast()方法:
        LinkedList<Interval> resultList = new LinkedList<>();
        for (Interval interval : list) {
            if (resultList.isEmpty() || resultList.getLast().right < interval.left) {
                // 当前区间左端点比最后区间右端点大，直接加入列表:
                resultList.add(interval);
            } else {
                // 当前区间左端点不比最后区间右端点大，修改最后区间右端点为两个区间中右端点的最大值:
                resultList.getLast().right = Math.max(resultList.getLast().right, interval.right);
            }
        }
        int[][] result = new int[resultList.size()][2];
        for (int i = 0; i < resultList.size(); i++) {
            result[i] = new int[]{resultList.get(i).left, resultList.get(i).right};
        }
        return result;
    }
}

class Interval implements Comparable<Interval> {
    int left;
    int right;

    public Interval(int left, int right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int compareTo(Interval o) {
        return this.left - o.left;
    }
}
```

## 二维数组简介

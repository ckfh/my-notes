# 常考排序

## 快速排序

```Java
public class QuickSort {
    public static void getSortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int start, int end) {
        if (start < end) {
            int pivot = partition(nums, start, end);
            quickSort(nums, 0, pivot - 1);
            quickSort(nums, pivot + 1, end);
        }
    }

    private static int partition(int[] nums, int start, int end) {
        // 选取最后一个元素作为基准pivot
        int p = nums[end];
        int i = start;
        for (int j = start; j < end; j++) {
            if (nums[j] < p) {
                swap(nums, i, j);
                i++;
            }
        }
        swap(nums, i, end);
        return i;
    }

    private static void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

## 归并排序

```Java
public class MergeSort {
    public static int[] getSortArray(int[] nums) {
        return mergeSort(nums);
    }

    private static int[] mergeSort(int[] nums) {
        if (nums.length <= 1)
            return nums;
        int mid = nums.length / 2;
        // 分段
        int[] left = mergeSort(Arrays.copyOfRange(nums, 0, mid));
        int[] right = mergeSort(Arrays.copyOfRange(nums, mid, nums.length));
        // 合并
        return merge(left, right);
    }

    private static int[] merge(int[] left, int[] right) {
        int l = 0;
        int r = 0;
        int i = 0;
        // 建立一个临时数组来合并两个数组
        int[] result = new int[left.length + right.length];
        while (l < left.length && r < right.length) {
            // 注意索引不能越界，谁小先合并谁
            if (left[l] < right[r])
                result[i++] = left[l++];
            else
                result[i++] = right[r++];
        }
        // 至少有一个数组被合并完毕，将另一数组剩余部分合并
        System.arraycopy(left, l, result, i, left.length - l);
        System.arraycopy(right, r, result, i, right.length - r);
        return result;
    }
}
```

## 堆排序

```Java
public class HeapSort {
    public static void heapSort(int[] nums) {
        // 从完全二叉树中最后一个拥有叶子节点的节点开始往前依次访问其它节点直到头结点
        // 将无序数组构建为一个大顶堆，每访问一个节点就判断一次是否需要下沉
        for (int i = nums.length / 2 - 1; i >= 0; i--)
            HeapSort.sink(nums, i, nums.length);
        // 构建大顶堆后开始对数组进行排序
        // 交换根节点和最后一个节点后，继续保持根节点到最后一个节点之前的树结构为大顶堆即可完成排序
        // 因为每次都把大顶堆的根节点放到数组的最后，因此对数组进行的是一个升序排序
        for (int i = nums.length - 1; i >= 1; i--) {
            HeapSort.swap(nums, 0, i);
            HeapSort.sink(nums, 0, i);
        }
    }

    private static void sink(int[] nums, int i, int length) {
        // 节点需和自己的孩子节点比较，如果小于孩子节点则交换值，交换之后继续和之后的孩子节点进行比较
        while (true) {
            // 左孩子节点
            int l = i * 2 + 1;
            // 右孩子节点
            int r = i * 2 + 2;
            // 保存当前节点及其孩子节点之间最大值的索引
            int index = i;
            // 如果有左孩子并且节点值大，取左孩子节点
            if (l < length && nums[l] > nums[index])
                index = l;
            // 如果有右孩子并且节点值大，取右孩子节点
            if (r < length && nums[r] > nums[index])
                index = r;
            // 如果当前节点最大，则不用下沉
            if (index == i)
                break;
            // 如果当前节点较小，交换值，继续下沉 index 节点
            HeapSort.swap(nums, i, index);
            i = index;
        }
    }

    private static void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

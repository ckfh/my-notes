# 常考排序

## 快速排序

```Java
public class QuickSort {
    public static void getSortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int start, int end) {
        if (start < end) {
            int pivot = partition(nums, start, end);
            quickSort(nums, 0, pivot - 1);
            quickSort(nums, pivot + 1, end);
        }
    }

    private static int partition(int[] nums, int start, int end) {
        // 选取最后一个元素作为基准pivot
        int p = nums[end];
        int i = start;
        for (int j = start; j < end; j++) {
            if (nums[j] < p) {
                swap(nums, i, j);
                i++;
            }
        }
        swap(nums, i, end);
        return i;
    }

    private static void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

## 归并排序

```Java
public class MergeSort {
    public static int[] getSortArray(int[] nums) {
        return mergeSort(nums);
    }

    private static int[] mergeSort(int[] nums) {
        if (nums.length <= 1)
            return nums;
        int mid = nums.length / 2;
        // 分段
        int[] left = mergeSort(Arrays.copyOfRange(nums, 0, mid));
        int[] right = mergeSort(Arrays.copyOfRange(nums, mid, nums.length));
        // 合并
        return merge(left, right);
    }

    private static int[] merge(int[] left, int[] right) {
        int l = 0;
        int r = 0;
        int i = 0;
        // 建立一个临时数组来合并两个数组
        int[] result = new int[left.length + right.length];
        while (l < left.length && r < right.length) {
            // 注意索引不能越界，谁小先合并谁
            if (left[l] < right[r])
                result[i++] = left[l++];
            else
                result[i++] = right[r++];
        }
        // 至少有一个数组被合并完毕，将另一数组剩余部分合并
        System.arraycopy(left, l, result, i, left.length - l);
        System.arraycopy(right, r, result, i, right.length - r);
        return result;
    }
}
```

## 堆排序

```Java
```

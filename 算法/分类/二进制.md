# 二进制

## TIPS

![移位运算01](./image/二进制-移位运算01.jpg)

![移位运算02](./image/二进制-移位运算02.jpg)

![位运算](./image/二进制-位运算.jpg)

![基本操作](./image/二进制-基本操作.jpg)

## 136.只出现一次的数字

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```Java
// 同一个数字异或两次就变成了0，最后剩下的就是只出现一次的数字
public int singleNumber(int[] nums) {
    int ans = nums[0];
    for (int i = 1; i < nums.length; i++)
        ans ^= nums[i];
    return ans;
}
```

## 137.只出现一次的数字Ⅱ

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

```Java
// 转化为二进制后查看每一列1的个数，如果某列1的个数不为3的倍数，是因为只出现1次的数字贡献出了自己的二进制1
// 因此只要对不为3的倍数列写1，对为3的倍数列写0，就得到了这个只出现1次的数字
public int singleNumber(int[] nums) {
    int ans = 0;
    // 整数范围由32位二进制数表示，最高位为符号位
    for (int i = 0; i < 32; i++) {
        int count = 0;
        for (int num : nums) {
            // 统计每列1的个数，将数字右移i列后和1与运算，为1表示该数二进制在该列取值为1
            count += (num >> i) & 1;
        }
        // 取余为1表明该列不为3的倍数，按照i列左移回去后和答案数字取或运算或者异或运算即可得到答案数字
        ans |= (count % 3) << i;
    }
    return ans;
}
```

## 260.只出现一次的数字Ⅲ

> 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。

```Java
// 通过要找的两个数字的二进制某一位不同，将原数组分为两组，然后组内分别进行异或，最后要找的数字就是两组分别异或的结果
public int[] singleNumber(int[] nums) {
    int diff = 0;
    for (int num : nums)
        diff ^= num;
    // diff = Integer.highestOneBit(diff); // 取最高位1作为不同
    diff = (diff & (diff - 1)) ^ diff;  // 取最低位1作为不同
    int[] ans = {0, 0};
    for (int num : nums) {
        if ((diff & num) == 0)
            ans[0] ^= num; // 当前位是0的组
        else
            ans[1] ^= num; // 当前位是1的组
    }
    return ans;
}
```

## 191.位1的个数

> 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

```Java
// 不断移除最后一个1直到整数为0，记录移除操作的次数
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}
// 依次判断最低位是否为1，只需和1相与即可，之后整数需要进行不带符号的右移运算即符号位跟着动
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        count += n & 1;
        n >>>= 1;
    }
    return count;
}
```

## 338.比特位计数

> 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

```Java
// 简单粗暴：对每个数字都计算它的汉明重量。
// 动态规划：640(1010000000)/512(1000000000)，通过移除640的最后一个1可以得到512，
// 因此640的1的个数可在512的1的个数加1得到，既然之后的个数可以通过之前的个数来得到，就没有必要依次计算每个数的个数。
public int[] countBits(int num) {
    int[] result = new int[num + 1];
    // 数组循环从1开始，因为0移除最后一个1还是0，自身1的个数为0
    for (int i = 1; i <= num; i++) {
        // 在移除最后一个1后对应的数字中1的个数加1得到当前数字中1的个数
        result[i] = result[i & (i - 1)] + 1;
    }
    return result;
}
```

## 190.颠倒二进制位

> 颠倒给定的 32 位无符号整数的二进制位。

```Java
// 依次得到要给定整数的最低位，保存到结果变量中，结果变量每得到一位后左移腾出位置保存下一位\
// 最先得到的最低位变成了最高位，实现颠倒操作
public int reverseBits(int n) {
    int res = 0;
    for (int count = 0; count < 32; count++) {
        res <<= 1;      // 左移一位空出位置，位置补0
        res |= (n & 1); // 添加最低位可以通过位或操作完成
        n >>= 1;        // 给定数字右移一位去掉已经处理过的最低位
    }
    return res;
}
```

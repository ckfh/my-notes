# 笔记

## 队列：先入先出的数据结构

### 622.设计循环队列

```java
class MyCircularQueue {
    private int head;
    private int tail;
    private int size;
    private int[] data;

    public MyCircularQueue(int k) {
        this.head = -1;
        this.tail = -1;
        this.size = k;
        this.data = new int[this.size];
    }

    public boolean enQueue(int value) {
        if (this.isFull()) {
            return false;
        }
        if (this.isEmpty()) {
            this.head = 0;
        }
        this.tail = (this.tail + 1) % this.size;
        this.data[this.tail] = value;
        return true;
    }

    public boolean deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        // 出队仅存元素后，初始化头尾指针：
        if (this.head == this.tail) {
            this.head = -1;
            this.tail = -1;
            return true;
        }
        this.head = (this.head + 1) % this.size;
        return true;
    }

    public int Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.head];
    }

    public int Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.tail];
    }

    public boolean isEmpty() {
        return this.head == -1;
    }

    public boolean isFull() {
        return ((this.tail + 1) % this.size) == this.head;
    }
}
```

## 队列和广度优先搜索

### 队列和BFS

广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。

### 广度优先搜索-模板

在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。

有两种情况你不需要使用哈希集：

  1. 你完全确定没有循环，例如，在树遍历中；
  2. 你确实希望多次将结点添加到队列中。

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    Set<Node> used;     // store all the used nodes
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    add root to used;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                if (next is not in used) {
                    add next to queue;
                    add next to used;
                }
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

### 200.岛屿数量

```java
/**
 * 从左上角开始访问，如果=='1'，添加到队列中，开始，弹出一个节点，访问水平和垂直节点，如果有'1'则继续加入到队列中，
 * 直到队列为空，这一组'1'组成了一个岛屿，为了防止重复访问，需要为每个访问过的坐标标记已访问，已经被访问过的节点不需要再添加到队列中，
 * 直到队列为空，每完成这样一个过程，岛屿数量加一。
 * 注意点：访问的坐标如果超出范围记得进行处理，坐标已被访问可以将其置为'0'。
 * 问题解决：同一个坐标被访问了两次，一旦将坐标添加到队列中，直接将其置为'0'，因为之后是按照坐标进行访问的。
 */
class Solution {
    public int numIslands(char[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int length = grid[0].length;
        int width = grid.length;
        Queue<Point> queue = new LinkedList<>();
        int answer = 0;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < length; j++) {
                if (grid[i][j] == '1') {
                    queue.add(new Point(i, j));
                    grid[i][j] = '0';
                    while (!queue.isEmpty()) {
                        Point point = queue.poll();
                        if (point.x - 1 >= 0 && grid[point.x - 1][point.y] == '1') {
                            queue.add(new Point(point.x - 1, point.y));
                            grid[point.x - 1][point.y] = '0';
                        }
                        if (point.x + 1 < width && grid[point.x + 1][point.y] == '1') {
                            queue.add(new Point(point.x + 1, point.y));
                            grid[point.x + 1][point.y] = '0';
                        }
                        if (point.y - 1 >= 0 && grid[point.x][point.y - 1] == '1') {
                            queue.add(new Point(point.x, point.y - 1));
                            grid[point.x][point.y - 1] = '0';
                        }
                        if (point.y + 1 < length && grid[point.x][point.y + 1] == '1') {
                            queue.add(new Point(point.x, point.y + 1));
                            grid[point.x][point.y + 1] = '0';
                        }
                    }
                    answer++;
                }
            }
        }
        return answer;
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

### 752.打开转盘锁

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        Queue<String> queue = new LinkedList<>();
        Set<String> deadNumbers = new HashSet<>(Arrays.asList(deadends));
        Set<String> visited = new HashSet<>();
        int step = -1;

        if (!deadNumbers.contains("0000")) {
            queue.offer("0000");
            visited.add("0000");
        }

        while (!queue.isEmpty()) {
            step++;
            // 注意点一：不能把queue.size()放到循环判断里，因为队列在循环当中是动态变化的，可能导致无法结束循环。
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String number = queue.poll();
                if (target.equals(number)) {
                    return step;
                }
                for (int index = 0; index < 4; index++) {
                    // 注意点二：取值为-1和1，可以采取如下形式的循环。
                    for (int increase = -1; increase <= 1; increase += 2) {
                        String turn = this.turnLock(number, index, increase);
                        if (!visited.contains(turn) && !deadNumbers.contains(turn)) {
                            queue.offer(turn);
                            visited.add(turn);
                        }
                    }
                }
            }
        }
        return -1;
    }

    public String turnLock(String number, int index, int increase) {
        // 注意点三：数字在0-9内循环，可以用以下计算方式。
        int n = (number.charAt(index) - '0' + increase + 10) % 10;
        return number.substring(0, index) + n + number.substring(index + 1);
    }
}
```

### 279.完全平方数

```java
class Solution {
    public int numSquares(int n) {
        // 注意点一：每一级队列使用set进行表示，目的是为了消除结果值的冗余：
        Set<Integer> queue = new HashSet<>();
        // 注意点二：完全平方数用顺序结构进行表示：
        List<Integer> squares = new ArrayList<>();
        for (int i = 1; i * i <= n; i++) {
            squares.add(i * i);
        }
        int step = 0;
        queue.add(n);
        while (!queue.isEmpty()) {
            step++;
            Set<Integer> nextQueue = new HashSet<>();
            for (Integer remainder : queue) {
                for (Integer square : squares) {
                    if (remainder.equals(square)) {
                        return step;
                    } else if (remainder < square) {
                        // 注意点三：因为是顺序结构，故当剩余数比此时的完全平方数还要小时，忽略后面的完全平方数：
                        break;
                    } else {
                        nextQueue.add(remainder - square);
                    }
                }
            }
            queue = nextQueue;
        }
        return step;
    }
}
```

## 栈：后入先出的数据结构

### 155.最小栈

```java
class MinStack {
    private Deque<Integer> stack1;
    private Deque<Integer> stack2;

    public MinStack() {
        this.stack1 = new ArrayDeque<>();
        this.stack2 = new ArrayDeque<>();
    }

    public void push(int x) {
        this.stack1.push(x);
        if (this.stack2.isEmpty()) {
            this.stack2.push(x);
        } else if (x <= this.getMin()) {
            // 注意点一：等于情况必须考虑
            this.stack2.push(x);
        }
    }

    public void pop() {
        if (!this.stack1.isEmpty()) {
            int n1 = this.stack1.pop();
            // 如果出栈的是当前最小元素，则最小栈也需要跟着出栈元素。
            if (n1 == this.getMin()) {
                this.stack2.pop();
            }
        }
    }

    public int top() {
        if (!this.stack1.isEmpty()) {
            return this.stack1.peek();
        }
        throw new RuntimeException("stack is empty.");
    }

    public int getMin() {
        if (!this.stack2.isEmpty()) {
            return this.stack2.peek();
        }
        throw new RuntimeException("stack is empty.");
    }
}
```

### 20.有效的括号

```java
class Solution {
    public boolean isValid(String s) {
        if (s.length() == 0) {
            return true;
        }
        Deque<Character> stack = new ArrayDeque<>();
        Map<Character, Character> map = new HashMap<>();
        map.put('(', ')');
        map.put('[', ']');
        map.put('{', '}');
        char[] brackets = s.toCharArray();
        for (char bracket : brackets) {
            if (bracket == '(' || bracket == '{' || bracket == '[') {
                stack.push(bracket);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                if (bracket != map.get(stack.pop())) {
                    // 右括号和此时出栈左括号对应的右括号不匹配：
                    return false;
                }
            }
        }
        // 注意点：如果最后栈中还有字符剩余，则匹配失败：
        return stack.isEmpty();
    }
}
```

### 739.每日温度

维护一个单调栈，栈的内容是单调递减的温度数组下标。

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int[] answer = new int[T.length];
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < T.length; i++) {
            while (!stack.isEmpty() && T[i] > T[stack.peek()]) {
                answer[stack.peek()] = i - stack.peek();
                stack.pop();
            }
            stack.push(i);
        }
        return answer;
    }
}
```

### 150.逆波兰表达式求值

```java
// 使用栈求解后缀表达式，数字进栈，运算符弹出2个元素计算结果再进栈。
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new ArrayDeque<>();
        // 注意点：先弹出的数作为n2即加数、减数、乘数、除数，后弹出的数作为n1即加数、被减数、乘数、被除数
        Integer n1;
        Integer n2;
        for (String token : tokens) {
            switch (token) {
                case "+":
                    n2 = stack.pop();
                    n1 = stack.pop();
                    stack.push(n1 + n2);
                    break;
                case "-":
                    n2 = stack.pop();
                    n1 = stack.pop();
                    stack.push(n1 - n2);
                    break;
                case "*":
                    n2 = stack.pop();
                    n1 = stack.pop();
                    stack.push(n1 * n2);
                    break;
                case "/":
                    n2 = stack.pop();
                    n1 = stack.pop();
                    stack.push(n1 / n2);
                    break;
                default:
                    stack.push(Integer.parseInt(token));
                    break;

            }
        }
        return stack.pop();
    }
}
// 使用数组模拟栈，加快运算速度。
class Solution {
    public int evalRPN(String[] tokens) {
        int[] stack = new int[tokens.length / 2 + 1];
        // index始终指向最新结果的下一个索引
        int index = 0;
        for (String token : tokens) {
            switch (token) {
                case "+":
                    stack[index - 2] += stack[--index];
                    break;
                case "-":
                    stack[index - 2] -= stack[--index];
                    break;
                case "*":
                    stack[index - 2] *= stack[--index];
                    break;
                case "/":
                    stack[index - 2] /= stack[--index];
                    break;
                default:
                    stack[index++] = Integer.parseInt(token);
                    break;
            }
        }
        return stack[0];
    }
}
```

## 栈和深度优先搜索

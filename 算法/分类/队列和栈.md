# 笔记

## 队列：先入先出的数据结构

### 622.设计循环队列

```java
class MyCircularQueue {
    private int head;
    private int tail;
    private int size;
    private int[] data;

    public MyCircularQueue(int k) {
        this.head = -1;
        this.tail = -1;
        this.size = k;
        this.data = new int[this.size];
    }

    public boolean enQueue(int value) {
        if (this.isFull()) {
            return false;
        }
        if (this.isEmpty()) {
            this.head = 0;
        }
        this.tail = (this.tail + 1) % this.size;
        this.data[this.tail] = value;
        return true;
    }

    public boolean deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        // 出队仅存元素后，初始化头尾指针：
        if (this.head == this.tail) {
            this.head = -1;
            this.tail = -1;
            return true;
        }
        this.head = (this.head + 1) % this.size;
        return true;
    }

    public int Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.head];
    }

    public int Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.tail];
    }

    public boolean isEmpty() {
        return this.head == -1;
    }

    public boolean isFull() {
        return ((this.tail + 1) % this.size) == this.head;
    }
}
```

## 队列和广度优先搜索

### 队列和BFS

广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。

### 广度优先搜索-模板

在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。

有两种情况你不需要使用哈希集：

  1. 你完全确定没有循环，例如，在树遍历中；
  2. 你确实希望多次将结点添加到队列中。

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    Set<Node> used;     // store all the used nodes
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    add root to used;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                if (next is not in used) {
                    add next to queue;
                    add next to used;
                }
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

### 200.岛屿数量

```java
/**
 * 从左上角开始访问，如果=='1'，添加到队列中，开始，弹出一个节点，访问水平和垂直节点，如果有'1'则继续加入到队列中，
 * 直到队列为空，这一组'1'组成了一个岛屿，为了防止重复访问，需要为每个访问过的坐标标记已访问，已经被访问过的节点不需要再添加到队列中，
 * 直到队列为空，每完成这样一个过程，岛屿数量加一。
 * 注意点：访问的坐标如果超出范围记得进行处理，坐标已被访问可以将其置为'0'。
 * 问题解决：同一个坐标被访问了两次，一旦将坐标添加到队列中，直接将其置为'0'，因为之后是按照坐标进行访问的。
 */
class Solution {
    public int numIslands(char[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int length = grid[0].length;
        int width = grid.length;
        Queue<Point> queue = new LinkedList<>();
        int answer = 0;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < length; j++) {
                if (grid[i][j] == '1') {
                    queue.add(new Point(i, j));
                    grid[i][j] = '0';
                    while (!queue.isEmpty()) {
                        Point point = queue.poll();
                        if (point.x - 1 >= 0 && grid[point.x - 1][point.y] == '1') {
                            queue.add(new Point(point.x - 1, point.y));
                            grid[point.x - 1][point.y] = '0';
                        }
                        if (point.x + 1 < width && grid[point.x + 1][point.y] == '1') {
                            queue.add(new Point(point.x + 1, point.y));
                            grid[point.x + 1][point.y] = '0';
                        }
                        if (point.y - 1 >= 0 && grid[point.x][point.y - 1] == '1') {
                            queue.add(new Point(point.x, point.y - 1));
                            grid[point.x][point.y - 1] = '0';
                        }
                        if (point.y + 1 < length && grid[point.x][point.y + 1] == '1') {
                            queue.add(new Point(point.x, point.y + 1));
                            grid[point.x][point.y + 1] = '0';
                        }
                    }
                    answer++;
                }
            }
        }
        return answer;
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

## 752.打开转盘锁

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        Queue<String> queue = new LinkedList<>();
        Set<String> deadNumbers = new HashSet<>(Arrays.asList(deadends));
        Set<String> visited = new HashSet<>();
        int step = -1;

        if (!deadNumbers.contains("0000")) {
            queue.offer("0000");
            visited.add("0000");
        }

        while (!queue.isEmpty()) {
            step++;
            // 注意点一：不能把queue.size()放到循环判断里，因为队列在循环当中是动态变化的，可能导致无法结束循环。
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String number = queue.poll();
                if (target.equals(number)) {
                    return step;
                }
                for (int index = 0; index < 4; index++) {
                    // 注意点二：取值为-1和1，可以采取如下形式的循环。
                    for (int increase = -1; increase <= 1; increase += 2) {
                        String turn = this.turnLock(number, index, increase);
                        if (!visited.contains(turn) && !deadNumbers.contains(turn)) {
                            queue.offer(turn);
                            visited.add(turn);
                        }
                    }
                }
            }
        }
        return -1;
    }

    public String turnLock(String number, int index, int increase) {
        // 注意点三：数字在0-9内循环，可以用以下计算方式。
        int n = (number.charAt(index) - '0' + increase + 10) % 10;
        return number.substring(0, index) + n + number.substring(index + 1);
    }
}
```

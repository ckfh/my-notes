# 链表

## 单链表

### 707.设计链表

```java
class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
    }
}

class MyLinkedList {
    int size;
    ListNode dummy;

    /**
     * Initialize your data structure here.
     */
    public MyLinkedList() {
        this.size = 0;
        this.dummy = new ListNode(0);
    }

    /**
     * Get the value of the index-th node in the linked list. If the index is invalid, return -1.
     */
    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode node = this.dummy;
        for (int i = 0; i < index + 1; i++) {
            node = node.next;
        }
        return node.val;
    }

    /**
     * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
     */
    public void addAtHead(int val) {
        this.addAtIndex(0, val);
    }

    /**
     * Append a node of value val to the last element of the linked list.
     */
    public void addAtTail(int val) {
        this.addAtIndex(size, val);
    }

    /**
     * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
     */
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        ListNode pred = this.dummy;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        ListNode node = new ListNode(val);
        node.next = pred.next;
        pred.next = node;
    }

    /**
     * Delete the index-th node in the linked list, if the index is valid.
     */
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = this.dummy;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}
```

```Java
public class n82 {
    /*
     * 创建一个哑巴节点作为链表新的头结点
     * 从哑巴节点开始，如果next和next.next不为空
     * 如果next.val和next.next.val相等，则记录val为删除值
     * 如果next不为空且next.val等于删除值，则当前节点指向next.next
     */
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)
            return null;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        while (head.next != null && head.next.next != null) {
            if (head.next.val == head.next.next.val) {
                // 记录一个需要被移除的节点值
                int rmVal = head.next.val;
                // 最外层循环已经帮助判断了下节点及下下节点不为空
                while (head.next != null && head.next.val == rmVal)
                    head.next = head.next.next;
            } else
                head = head.next;
        }
        return dummy.next;
    }
}
```

```Java
public class n83 {
    /*
     * 循环链表，直到为空，每循环一个节点，如果其下一节点不为空，
     * 则比较双方的值，值相同，则当前节点的next指向next节点的next节点。
     * 再次进行上述比较，重复直到双方的值不相同为止。
     */
    public ListNode deleteDuplicates(ListNode head) {
        for (ListNode cNode = head; cNode != null; cNode = cNode.next) {
            while (cNode.next != null && cNode.val == cNode.next.val)
                cNode.next = cNode.next.next;
        }
        return head;
    }
}
```

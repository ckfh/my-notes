# 链表

## 单链表

### 707.设计链表

```java
class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
    }
}

class MyLinkedList {
    int size;
    ListNode dummy;

    public MyLinkedList() {
        this.size = 0;
        this.dummy = new ListNode(0);
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode node = this.dummy;
        for (int i = 0; i < index + 1; i++) {
            node = node.next;
        }
        return node.val;
    }

    public void addAtHead(int val) {
        this.addAtIndex(0, val);
    }

    public void addAtTail(int val) {
        this.addAtIndex(size, val);
    }

    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        ListNode pred = this.dummy;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        ListNode node = new ListNode(val);
        node.next = pred.next;
        pred.next = node;
    }

    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pred = this.dummy;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}
```

## 双指针技巧

### 141.环形链表

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            if (fast == slow) {
                break;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return fast == slow;
    }
}
```

### 142.环形链表Ⅱ

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null)
            return null;
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            if (slow == fast) {
                // 相遇:
                slow = head;
                // fast向前走一步后，再开始同步走:
                fast = fast.next;
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return null;
    }
}
```

### 160.相交链表

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA;
        ListNode pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

### 19.删除链表的倒数第N个节点

可以使用两趟扫描，一趟找长度，一趟找坐标。

用一趟扫描进行优化，快慢指针，快指针先走n+1步，然后快慢指针同时走，当快指针到达末尾时，慢指针的下一个位置就是要删除的节点。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        for (int i = 0; i < n + 1; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

## 经典问题

### 206.反转链表

```Java
public class n82 {
    /*
     * 创建一个哑巴节点作为链表新的头结点
     * 从哑巴节点开始，如果next和next.next不为空
     * 如果next.val和next.next.val相等，则记录val为删除值
     * 如果next不为空且next.val等于删除值，则当前节点指向next.next
     */
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)
            return null;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        while (head.next != null && head.next.next != null) {
            if (head.next.val == head.next.next.val) {
                // 记录一个需要被移除的节点值
                int rmVal = head.next.val;
                // 最外层循环已经帮助判断了下节点及下下节点不为空
                while (head.next != null && head.next.val == rmVal)
                    head.next = head.next.next;
            } else
                head = head.next;
        }
        return dummy.next;
    }
}
```

```Java
public class n83 {
    /*
     * 循环链表，直到为空，每循环一个节点，如果其下一节点不为空，
     * 则比较双方的值，值相同，则当前节点的next指向next节点的next节点。
     * 再次进行上述比较，重复直到双方的值不相同为止。
     */
    public ListNode deleteDuplicates(ListNode head) {
        for (ListNode cNode = head; cNode != null; cNode = cNode.next) {
            while (cNode.next != null && cNode.val == cNode.next.val)
                cNode.next = cNode.next.next;
        }
        return head;
    }
}
```

# 动态规划

## 120.三角形最小路径和

> 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

```Java
// 动态规划，自底向上：从倒二行开始，访问每个元素及其下一行的相邻元素，将较小的相邻元素累加到自身，重复该操作直到第一行为止。
// 最后返回的结果是第一行的唯一元素，其节点值就是该三角形的最小路径和。
```

递归和动规的关系：

- 递归是一种程序的实现方式：函数的自我调用；
- 动态规划：是一种解决问题的思想，大规模问题的结果，是由小规模问题的结果运算得来的。动态规划可用递归来实现。

使用场景（满足两个条件）：

- 满足以下条件之一：
  - 求最大/最小值
  - 求是否可行
  - 求可行个数
- 满足不能排序或者交换

四点要素：

  1. 状态state：灵感，创造力，存储小规模问题的结果。
  2. 方程function：状态之间的联系，怎么通过小的状态，来算大的状态。
  3. 初始化initialization：最极限的小状态是什么，起点。
  4. 答案answer：最大的那个状态是什么，终点。

常见的四种类型：

  1. Matrix DP
  2. Sequence
  3. Two Sequences DP
  4. Backpack

## 64.最小路径和（矩阵类型）

> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

```Java
// 状态：f[x][y]是从起点走到x，y的最短路径
// 方程：f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]
// 初始化：f[0][0] = A[0][0]、f[i][0] = sum(0, 0 -> i, 0)、f[0][i] = sum(0, 0 -> 0, i)
// 答案：f[m-1][n-1]

// 他人解法
public int minPathSum(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0)
        return 0;
    // 直接复用原来的矩阵列表，对于第1列的最短路径，只能从上走到下
    for (int i = 1; i < grid.length; i++)
        grid[i][0] = grid[i][0] + grid[i - 1][0];
    // 对于第1行的最短路径，只能从左走到右
    for (int i = 1; i < grid[0].length; i++)
        grid[0][i] = grid[0][i] + grid[0][i - 1];
    // 对于其它行其它列，只要选择从上方和从左方来的路径中最短的那一条加上自己的路径值即可
    for (int i = 1; i < grid.length; i++)
        for (int j = 1; j < grid[i].length; j++)
            grid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j];
    // 最后返回右下角的值就是最小路径和
    return grid[grid.length - 1][grid[0].length - 1];
}

// 个人解法，超出边界的索引路径值设为无穷大
public int minPathSum(int[][] grid) {
    for (int i = 0; i < grid.length; i++)
        for (int j = 0; j < grid[0].length; j++)
            if (i != 0 || j != 0)
                grid[i][j] = Math.min(gridValue(grid, i - 1, j), gridValue(grid, i, j - 1)) + grid[i][j];
    return grid[grid.length - 1][grid[0].length - 1];
}
public int gridValue(int[][] grid, int x, int y) {
    if (x < 0 || y < 0)
        return Integer.MAX_VALUE;
    else
        return grid[x][y];
}
```

## 62.不同路径（矩阵类型）

> 一个机器人位于一个mxn网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？

```Java
// 状态：f[x][y]是从起点走到x，y的不同路径数
// 方程：f[x][y] = f[x-1][y] + f[x][y-1]
// 初始化：f[0][0~n] = 1、f[0~m][0] = 1
// 答案：f[m-1][n-1]

public int uniquePaths(int m, int n) {
    int tmp = m;
    m = n;
    n = tmp;
    int[][] f = new int[m][n];
    // 第一行只能从左走到右，因此每个索引只有1条路径
    for (int i = 0; i < n; i++)
        f[0][i] = 1;
    // 第一列只能从上走到下，因此每个索引只有1条路径
    for (int i = 1; i < m; i++)
        f[i][0] = 1;
    // 其它行其它列的路径数，只要将从上方和从左方来的路径数求和即可
    for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
            f[i][j] = f[i - 1][j] + f[i][j - 1];
    // 最后返回右下角的值就是不同路径数
    return f[m - 1][n - 1];
}
```

## 63.不同路径Ⅱ（矩阵类型）

> 现在考虑网格中有障碍物。

```Java
// 状态：f[x][y]是从起点走到x，y的不同路径数
// 方程：A[x][y]=0，f[x][y] = f[x-1][y] + f[x][y-1]；A[x][y]=1，则f[x][y] = 0
// 初始化：f[0][0~n] = 1、f[0~m][0] = 1
// 答案：f[m-1][n-1]

public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int[][] nums = new int[obstacleGrid.length][obstacleGrid[0].length];
    // 初始化第一行，如果出现障碍则跳出循环，剩余的路径数都为0：
    for (int i = 0; i < obstacleGrid[0].length; i++) {
        if (obstacleGrid[0][i] == 1)
            break;
        nums[0][i] = 1;
    }
    // 初始化第一列，仍从0开始，其余同上：
    for (int i = 0; i < obstacleGrid.length; i++) {
        if (obstacleGrid[i][0] == 1)
            break;
        nums[i][0] = 1;
    }
    // 有障碍则路径数为0，无障碍则路径数等于上加左：
    for (int i = 1; i < obstacleGrid.length; i++) {
        for (int j = 1; j < obstacleGrid[0].length; j++) {
            if (obstacleGrid[i][j] == 1)
                nums[i][j] = 0;
            else
                nums[i][j] = nums[i - 1][j] + nums[i][j - 1];
        }
    }
    return nums[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
}
```

## 70.爬楼梯（序列类型）

> 假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬1或2个台阶。

```Java
// 注意n-2级走1+1的情况是被包含在n-1级走1的情况里的，因此从n-2级走到n级也只有一种走法：
public int climbStairs(int n) {
    if (n == 1 || n == 0)
        return n;
    int[] nums = new int[n + 1];
    nums[1] = 1;
    nums[2] = 2;
    for (int i = 3; i <= n; i++)
        nums[i] = nums[i - 1] + nums[i - 2];
    return nums[n];
}
```

## 55.跳跃游戏（序列类型）

> 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

```Java
// 状态：f[i]表示是否能从0跳到i
// 方程：f[i]=OR(f[j], j<i&&j能跳到i)
// 初始化：f[0]=true
// 答案：f[n-1]

public boolean canJump(int[] nums) {
    boolean[] f = new boolean[nums.length];
    f[0] = true;
    for (int i = 1; i < nums.length; i++)
        for (int j = 0; j < i; j++)
            // 如果数组索引值加上元素值大于等于当前索引值，则表示能从j跳到i：
            // 另外j本身也是一个可能到达的起跳点：
            if ((j + nums[j]) >= i && f[j]) {
                f[i] = true;
                break;
            }
    return f[nums.length - 1];
}
```

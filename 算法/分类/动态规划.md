# 动态规划

## 120.三角形最小路径和

> 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

```Java
// 动态规划，自底向上：从倒二行开始，访问每个元素及其下一行的相邻元素，将较小的相邻元素累加到自身，重复该操作直到第一行为止。
// 最后返回的结果是第一行的唯一元素，其节点值就是该三角形的最小路径和。
```

递归和动规的关系：

- 递归是一种程序的实现方式：函数的自我调用；
- 动态规划：是一种解决问题的思想，大规模问题的结果，是由小规模问题的结果运算得来的。动态规划可用递归来实现。

使用场景（满足两个条件）：

- 满足以下条件之一：
  - 求最大/最小值
  - 求是否可行
  - 求可行个数
- 满足不能排序或者交换

四点要素：

  1. 状态state：灵感，创造力，存储小规模问题的结果。
  2. 方程function：状态之间的联系，怎么通过小的状态，来算大的状态。
  3. 初始化initialization：最极限的小状态是什么，起点。
  4. 答案answer：最大的那个状态是什么，终点。

常见的四种类型：

  1. Matrix DP
  2. Sequence
  3. Two Sequences DP
  4. Backpack

## 64.最小路径和（矩阵类型）

> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

```Java
// 状态：f[x][y]是从起点走到x，y的最短路径
// 方程：f[x][y] = min(f[x-1][y], f[x][y-1]) + A[x][y]
// 初始化：f[0][0] = A[0][0]、f[i][0] = sum(0, 0 -> i, 0)、f[0][i] = sum(0, 0 -> 0, i)
// 答案：f[m-1][n-1]

// 他人解法
public int minPathSum(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0)
        return 0;
    // 直接复用原来的矩阵列表，对于第1列的最短路径，只能从上走到下
    for (int i = 1; i < grid.length; i++)
        grid[i][0] = grid[i][0] + grid[i - 1][0];
    // 对于第1行的最短路径，只能从左走到右
    for (int i = 1; i < grid[0].length; i++)
        grid[0][i] = grid[0][i] + grid[0][i - 1];
    // 对于其它行其它列，只要选择从上方和从左方来的路径中最短的那一条加上自己的路径值即可
    for (int i = 1; i < grid.length; i++)
        for (int j = 1; j < grid[i].length; j++)
            grid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j];
    // 最后返回右下角的值就是最小路径和
    return grid[grid.length - 1][grid[0].length - 1];
}

// 个人解法，超出边界的索引路径值设为无穷大
public int minPathSum(int[][] grid) {
    for (int i = 0; i < grid.length; i++)
        for (int j = 0; j < grid[0].length; j++)
            if (i != 0 || j != 0)
                grid[i][j] = Math.min(gridValue(grid, i - 1, j), gridValue(grid, i, j - 1)) + grid[i][j];
    return grid[grid.length - 1][grid[0].length - 1];
}
public int gridValue(int[][] grid, int x, int y) {
    if (x < 0 || y < 0)
        return Integer.MAX_VALUE;
    else
        return grid[x][y];
}
```

## 62.不同路径（矩阵类型）

> 一个机器人位于一个mxn网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？

```Java
// 状态：f[x][y]是从起点走到x，y的不同路径数
// 方程：f[x][y] = f[x-1][y] + f[x][y-1]
// 初始化：f[0][0~n] = 1、f[0~m][0] = 1
// 答案：f[m-1][n-1]

public int uniquePaths(int m, int n) {
    int tmp = m;
    m = n;
    n = tmp;
    int[][] f = new int[m][n];
    // 第一行只能从左走到右，因此每个索引只有1条路径
    for (int i = 0; i < n; i++)
        f[0][i] = 1;
    // 第一列只能从上走到下，因此每个索引只有1条路径
    for (int i = 1; i < m; i++)
        f[i][0] = 1;
    // 其它行其它列的路径数，只要将从上方和从左方来的路径数求和即可
    for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
            f[i][j] = f[i - 1][j] + f[i][j - 1];
    // 最后返回右下角的值就是不同路径数
    return f[m - 1][n - 1];
}
```

# 探索二叉树

**树的问题就是遍历问题，是前序中序后序还是深度广度**。

## 114.二叉树的前序遍历

```Java
// 递归版：
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }

    private void traversal(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        list.add(root.val);
        traversal(root.left, list);
        traversal(root.right, list);
    }
}
// 迭代版：
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }

    private void traversal(TreeNode root, List<Integer> list) {
        if (root != null) {
            Deque<TreeNode> stack = new ArrayDeque<>();
            stack.push(root);
            while (!stack.isEmpty()) {
                TreeNode cur = stack.pop();
                list.add(cur.val);
                // 先进后出，先进栈右孩子再进栈左孩子，先出栈左孩子进行访问再出栈右孩子进行访问，符合前序遍历的要求：
                // 出栈顺序依次是中左右：
                if (cur.right != null) {
                    stack.push(cur.right);
                }
                if (cur.left != null) {
                    stack.push(cur.left);
                }
            }
        }
    }
}
```

## 94.二叉树的中序遍历

```Java
// 递归版：
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }

    private void traversal(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        traversal(root.left, list);
        list.add(root.val);
        traversal(root.right, list);
    }
}
// 迭代版：
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }
    // 先打印左子树，然后打印每棵子树的头节点，最后打印右子树：
    private void traversal(TreeNode root, List<Integer> list) {
        if (root != null) {
            Deque<TreeNode> stack = new ArrayDeque<>();
            while (!stack.isEmpty() || root != null) {
                if (root != null) {
                    // 先不断压入左孩子：
                    stack.push(root);
                    root = root.left;
                } else {
                    // 左孩子为空，弹出栈顶元素进行访问，切换到右孩子：
                    root = stack.pop();
                    list.add(root.val);
                    root = root.right;
                }
            }
        }
    }
}
```

## 145.二叉树的后序遍历

```Java
// 官方版：
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> result = new LinkedList<>();
        if (root != null) {
            Deque<TreeNode> stack = new ArrayDeque<>();
            stack.push(root);
            while (!stack.isEmpty()) {
                TreeNode node = stack.pop();
                // 出栈顺序依次是中右左，倒序加入到结果列表中，用到了LinkedList自己实现的addFirst()方法：
                result.addFirst(node.val);
                if (node.left != null) {
                    stack.push(node.left);
                }
                if (node.right != null) {
                    stack.push(node.right);
                }
            }
        }
        return result;
    }
}
// 递归版：
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }

    private void traversal(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        traversal(root.left, list);
        traversal(root.right, list);
        list.add(root.val);
    }
}
// 双栈迭代版：
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }

    private void traversal(TreeNode root, List<Integer> list) {
        if (root != null) {
            Deque<TreeNode> stack1 = new ArrayDeque<>();
            Deque<TreeNode> stack2 = new ArrayDeque<>();
            stack1.push(root);
            // 每一个从栈一中弹出的节点都放进栈二中：
            // 栈一的出栈顺序是中右左，故栈二的出栈顺序是左右中，符合后序遍历的要求：
            while (!stack1.isEmpty()) {
                root = stack1.pop();
                stack2.push(root);
                if (root.left != null) {
                    stack1.push(root.left);
                }
                if (root.right != null) {
                    stack1.push(root.right);
                }
            }
            while (!stack2.isEmpty()) {
                list.add(stack2.pop().val);
            }
        }
    }
}
// 单栈迭代版：
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        this.traversal(root, result);
        return result;
    }

    private void traversal(TreeNode root, List<Integer> list) {
        if (root != null) {
            Deque<TreeNode> stack = new ArrayDeque<>();
            // root表示最近从栈中弹出并打印的元素：
            stack.push(root);
            // c表示此时的栈顶元素：
            TreeNode c = null;
            while (!stack.isEmpty()) {
                // 取栈顶元素：
                c = stack.peek();
                if (c.left != null && root != c.left && root != c.right) {
                    // 如果最近打印元素不是当前栈顶元素的左右孩子节点，就表示该节点左子树还没被打印（左右中）：
                    stack.push(c.left);
                } else if (c.right != null && root != c.right) {
                    // 上述条件不成立表示左子树已被打印，继续判断右子树是否被打印（左右中）：
                    stack.push(c.right);
                } else {
                    // 如果上述条件都不成立，表示节点的左右子树已经被打印完毕，弹出栈顶元素并打印：
                    list.add(stack.pop().val);
                    root = c;
                }
            }
        }
    }
}
```

## 二叉树迭代遍历模板

[模板](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/)

## 102.二叉树的层序遍历

[参考](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/)

```Java
public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if (root != null) {
            queue.offer(root);
        }
        while (!queue.isEmpty()) {
            // 获取当前层的元素个数：
            int n = queue.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                // for循环访问当前层的所有元素：
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            ans.add(level);
        }
        return ans;
    }
}
```

通常，我们可以通过 “自顶向下（前序递归）” 或 “自底向上（后序递归）” 的递归来解决树问题。

**“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点**。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：

```text
1. return specific value for null node
2. update the answer if needed                      // anwer <-- params
3. left_ans = top_down(root.left, left_params)      // left_params <-- root.val, params
4. right_ans = top_down(root.right, right_params)   // right_params <-- root.val, params
5. return the answer if needed                      // answer <-- left_ans, right_ans
```

例如，思考这样一个问题：给定一个二叉树，请寻找它的最大深度。

我们知道根节点的深度是1。 **对于每个节点，如果我们知道某节点的深度，那我们将知道它子节点的深度。 因此，在调用递归函数的时候，将节点的深度传递为一个参数，那么所有的节点都知道它们自身的深度。 而对于叶节点，我们可以通过更新深度从而获取最终答案**。 这里是递归函数 maximum_depth(root, depth) 的伪代码：

```text
1. return if root is null
2. if root is a leaf node:
3.      answer = max(answer, depth)         // update the answer if needed
4. maximum_depth(root.left, depth + 1)      // call the function recursively for left child
5. maximum_depth(root.right, depth + 1)     // call the function recursively for right child
```

```Java
private int answer; // don't forget to initialize answer before call maximum_depth
private void maximum_depth(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    if (root.left == null && root.right == null) {
        answer = Math.max(answer, depth);
    }
    // 我能确定当前节点的深度为depth，通过depth+1我能够确定子节点的深度：
    maximum_depth(root.left, depth + 1);
    maximum_depth(root.right, depth + 1);
}
```

“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：

```text
1. return specific value for null node
2. left_ans = bottom_up(root.left)          // call function recursively for left child
3. right_ans = bottom_up(root.right)        // call function recursively for right child
4. return answers                           // answer <-- left_ans, right_ans, root.val
```

如果我们知道一个根节点，以其左子节点为根的最大深度为l和以其右子节点为根的最大深度为r，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 x = max（l，r）+ 1。

**这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案**。 因此，我们可以使用“自底向上“的方法。下面是递归函数 maximum_depth(root) 的伪代码：

```text
1. return 0 if root is null                 // return 0 for null node
2. left_depth = maximum_depth(root.left)
3. right_depth = maximum_depth(root.right)
4. return max(left_depth, right_depth) + 1  // return depth of the subtree rooted at root
```

```Java
public int maximum_depth(TreeNode root) {
    if (root == null) {
        return 0; // return 0 for null node
    }
    // 我如果知道以左右子节点各自为根节点的树的深度，那么当前节点的深度就是两者深度最大值加一：
    int left_depth = maximum_depth(root.left);
    int right_depth = maximum_depth(root.right);
    return Math.max(left_depth, right_depth) + 1; // return depth of the subtree rooted at root
}
```

当遇到树问题时，请先思考一下两个问题：

  1. 你能确定一些参数，从该节点自身解决出发寻找答案吗？
  2. 你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？

如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。

## 104.二叉树的最大深度

```Java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

## 101.对称二叉树

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，**随后 p 右移时，q 左移，p 左移时，q 右移**。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return this.check(root, root);
    }

    private boolean check(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            // 节点都为空：
            return true;
        }
        if (p == null || q == null) {
            // 一个节点为空，一个节点不为空：
            return false;
        }
        // 节点都不为空：
        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
    }
}
```

**首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法**。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return this.check(root, root);
    }

    private boolean check(TreeNode u, TreeNode v) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(u);
        queue.offer(v);
        while (!queue.isEmpty()) {
            u = queue.poll();
            v = queue.poll();
            if (u == null && v == null) {
                continue;
            }
            if (u == null || v == null) {
                return false;
            }
            if (u.val != v.val) {
                return false;
            }
            queue.offer(u.left);
            queue.offer(v.right);

            queue.offer(u.right);
            queue.offer(v.left);
        }
        return true;
    }
}
```

## 112.路径总和

个人思路：自顶向下递归，每个节点累加自己的节点值到总和上，如果是叶子节点，判断路径总和是否等于目标值，并尝试修改全局变量，不是叶子节点则把当前总和继续传递给自己的左右孩子节点。

```Java
class Solution {
    private boolean answer = false;

    public boolean hasPathSum(TreeNode root, int sum) {
        this.pathSum(root, 0, sum);
        return this.answer;
    }

    private void pathSum(TreeNode root, int sum, int target) {
        if (root == null) {
            return;
        }
        sum += root.val;
        if (root.left == null && root.right == null) {
            if (sum == target) {
                this.answer = true;
            }
        }
        pathSum(root.left, sum, target);
        pathSum(root.right, sum, target);
    }
}
```

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

## 106.从中序与后序遍历序列构造二叉树

个人思路：倒序遍历后序序列建立二叉树，根据中序序列判断左右。缺点：太慢，每次插入都要从头节点开始递归寻找叶子节点。

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> map = new HashMap<>(inorder.length);
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        TreeNode root = null;
        for (int i = postorder.length - 1; i >= 0; i--) {
            root = this.build(root, postorder[i], map);
        }
        return root;
    }

    private TreeNode build(TreeNode root, int nodeVal, Map<Integer, Integer> map) {
        if (root == null) {
            root = new TreeNode(nodeVal);
            return root;
        }
        if (map.get(nodeVal) > map.get(root.val)) {
            root.right = build(root.right, nodeVal, map);
        } else {
            root.left = build(root.left, nodeVal, map);
        }
        return root;
    }
}
```

官方版的快就快在每次递归都是从当前节点到叶子节点。

```Java
class Solution {
    int postIndex;
    int[] postorder;
    int[] inorder;
    HashMap<Integer, Integer> indexMap = new HashMap<>();
    // 参数是中序序列中当前子树的左右边界
    public TreeNode helper(int inLeft, int inRight) {
        // 左大于右，子树为空
        if (inLeft > inRight) {
            return null;
        }
        // 取后序序列的最后一个节点作为根节点
        int rootVal = this.postorder[this.postIndex];
        TreeNode root = new TreeNode(rootVal);
        this.postIndex--;
        // 根据根节点在中序序列中的索引，将数组范围分为左右两部分，递归创建左右子树
        int index = this.indexMap.get(rootVal);
        root.left = helper(inLeft, index - 1);
        root.right = helper(index + 1, inRight);
        // 返回根节点
        return root;
    }

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;
        this.inorder = inorder;
        this.postIndex = postorder.length - 1;

        int idx = 0;
        for (Integer val : inorder) {
            this.indexMap.put(val, idx++);
        }
        return helper(0, inorder.length - 1);
    }
}
```

## 105.从前序与中序遍历序列构造二叉树

将上述中序加后序的构造思路改造一下即可。

```Java
class Solution {
    int[] preorder;
    int[] inorder;
    int preIndex;
    Map<Integer, Integer> indexMap = new HashMap<>();

    private TreeNode helper(int inLeft, int inRight) {
        if (inLeft > inRight) {
            return null;
        }
        int rootVal = this.preorder[this.preIndex];
        TreeNode root = new TreeNode(rootVal);
        this.preIndex++;
        int index = this.indexMap.get(rootVal);
        root.left = helper(inLeft, index - 1);
        root.right = helper(index + 1, inRight);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        this.preIndex = 0;
        for (int i = 0; i < inorder.length; i++) {
            this.indexMap.put(inorder[i], i);
        }
        return this.helper(0, inorder.length - 1);
    }
}
```

## 116.填充每个节点的下一个右侧节点指针

个人思路：层序遍历（按层输出），出队元素的右侧节点指针就是此时的队头元素。

```Java
class Solution {
    public Node connect(Node root) {
        Queue<Node> queue = new LinkedList<>();
        if (root != null) {
            queue.offer(root);
        }
        while (!queue.isEmpty()) {
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                Node node = queue.poll();
                // 因为出队的同时也在进队孩子节点，需要防止每层的最右节点连接到下一层的最左的节点：
                if (i != n - 1) {
                    node.next = queue.peek();
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return root;
    }
}
```

## 117.填充每个节点的下一个右侧节点指针Ⅱ

思路同上一题，上一题是完美二叉树，该题是普通二叉树。

```Java
```

## 236.二叉树的最近公共祖先

该题递归思路：以后序遍历为模板，先访问左右节点再处理当前节点（**你用来处理当前节点的方式同样也是用来处理左右节点的方式**）；自底向上处理到根节点；

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 优先处理特殊情况（叶子节点的左右孩子、目标节点）：
        if (root == null || root == p || root == q) {
            return root;
        }
        // 访问左右节点：
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 处理当前节点：
        // 左右为空表示左右子树都不存在目标节点，返回 null：
        if (left == null && right == null) {
            return null;
        }
        // 一侧不为空表示一侧存在目标节点，返回目标节点：
        if (left == null || right == null) {
            return left != null ? left : right;
        }
        // 左右都不为空表示该节点是最近公共祖先，返回自己：
        return root;
    }
}
```

另外一种思路：通过比较两个目标节点的父节点得出最近公共祖先。

```Java
class Solution {
    Map<Integer, TreeNode> parent = new HashMap<>();
    Set<Integer> visited = new HashSet<>();
    // 深度遍历，节点值作为键，父节点作为值：
    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        if (root.left != null) {
            parent.put(root.left.val, root);
            dfs(root.left);
        }
        if (root.right != null) {
            parent.put(root.right.val, root);
            dfs(root.right);
        }
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        this.dfs(root);
        // 从 p 节点开始不断向上访问各个祖先节点，使用一个 set 记录祖先节点的值：
        while (p != null) {
            visited.add(p.val);
            p = parent.get(p.val);
        }
        // 从 q 节点开始不断向上访问各个祖先节点，每访问一个节点就判断是否为 p 节点的祖先节点：
        // 第一个公共祖先节点就是最近公共祖先：
        while (q != null) {
            if (visited.contains(q.val)) {
                return q;
            }
            q = parent.get(q.val);
        }
        return root;
    }
}
```

## 297.二叉树的序列化与反序列化

先序遍历。

```Java
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) {
            return "#!";
        }
        String res = root.val + "!";
        res += serialize(root.left);
        res += serialize(root.right);
        return res;
    }

    public TreeNode deserialize(String data) {
        String[] values = data.split("!");
        Queue<String> queue = new LinkedList<>();
        for (String value : values) {
            queue.offer(value);
        }
        return this.reconPreOrder(queue);
    }

    private TreeNode reconPreOrder(Queue<String> queue) {
        String value = queue.poll();
        if ("#".equals(value)) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(value));
        root.left = reconPreOrder(queue);
        root.right = reconPreOrder(queue);
        return root;
    }
}
```

层次遍历。

```Java
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) {
            return "#!";
        }
        StringBuilder res = new StringBuilder(root.val + "!");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            if (root.left != null) {
                res.append(root.left.val).append("!");
                queue.offer(root.left);
            } else {
                res.append("#!");
            }
            if (root.right != null) {
                res.append(root.right.val).append("!");
                queue.offer(root.right);
            } else {
                res.append("#!");
            }
        }
        return res.toString();
    }

    public TreeNode deserialize(String data) {
        String[] values = data.split("!");
        int index = 0;
        TreeNode root = this.generateNodeByString(values[index++]);
        Queue<TreeNode> queue = new LinkedList<>();
        if (root != null) {
            queue.offer(root);
        }
        TreeNode node = null;
        while (!queue.isEmpty()) {
            node = queue.poll();
            node.left = this.generateNodeByString(values[index++]);
            node.right = this.generateNodeByString(values[index++]);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return root;
    }

    private TreeNode generateNodeByString(String val) {
        if ("#".equals(val)) {
            return null;
        }
        return new TreeNode(Integer.parseInt(val));
    }
}
```

# 分治法

```Java
/*
 * 递归返回条件
 * 分段处理
 * 合并结果
 */
ResultType traversal(TreeNode root) {
    // null or leaf
    if root == null {
        // do something and return
    }

    // Divide
    ResultType left = traversal(root.Left)
    ResultType right = traversal(root.Right)

    // Conquer
    ResultType result = Merge from left and right

    return result
}
```

```Java
// 二叉树的最大深度
public int maxDepth(TreeNode root) {
    if (root == null)
        return 0;

    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);

    return Math.max(leftDepth, rightDepth) + 1;
}
```

```Java
// 平衡二叉树
public boolean isBalanced(TreeNode root) {
    return maxDepth(root) != -1;
}

private int maxDepth(TreeNode root) {
    if (root == null)
        return 0;

    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);

    // 只有在第三者条件成立时前二者才会第一次取值为-1表示有节点不平衡
    // 一般在工程上，一个变量不要具有二义性，比如这里返回>0表示树的高度，返回-1表示树不平衡
    if (leftDepth == -1 || rightDepth == -1 || Math.abs(leftDepth - rightDepth) > 1)
        return -1;

    return Math.max(leftDepth, rightDepth) + 1;
}
```

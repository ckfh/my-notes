# 笔记

## 单线程

Redis服务器执行客户端发送的指令时是串行的，因为它是单线程模型，因此一个客户端在一段时间内发送的多条指令会与其它客户端发送的多条指令串行执行，但是无法保证谁先谁后，因此如果想保证客户端发送的多条指令必须是连续执行的话，就需要使用事务。

Redis单指令为什么是原子性的，因为redis是单线程的，所有指令都是串行执行的。

应该说，redis的单线程保证了单条指令的原子性，但是不保证多条指令的原子性，因为在这其中可能穿插有其它客户端的指令。

## 事务

数据库系统原子性：要么都执行，要么都不执行，中间不会被其它客户端请求所打扰，出现错误将导致回滚。

Redis原子性：要么都执行，要么都不执行，中间不会被其它客户端指令所打扰，出现错误将根据错误的类型确定指令是否执行。

[事务支持](https://redis.io/topics/transactions)

参考官方对于事务的定义以及什么错误会不执行事务，什么错误会执行部分事务，以及为什么不支持回滚。

命令语法出现问题，比如GETSET key value少了value值，那么整个事务都不会执行。

命令语法没有问题，但是操作不正确，比如对一个字符内容的字符串进行INCR key操作，本身命令使用是正确的，但是对字符加一是错误的，因此除了该命令失败以外，其它命令都会执行。

## 基本数据结构

- geo：附近的人；
- hll：统计不重复元素个数，记录网站历史访问用户，不重复，有1%以下的误差；
- bm：适合有两类状态的数据统计，比如上班打卡，到或者没到。因为是用bit作为存储，因此即使是统计14亿人的某个状态也只需要160MB左右的存储空间，而使用bit存储已经是最小的存储单元了，其它常见的存储类型都是以字节为单位的。

## 数据持久化

## 主从复制

### 哨兵机制

## 缓存三问

[参考](https://juejin.cn/post/6943214731679236104)

### 缓存雪崩

原因：

1. 大量数据同时过期。
2. Redis故障宕机。

方案：

- 均匀设置过期实践，避免同一时间过期。
- 互斥锁，保证同一时间只有一个应用在构建缓存。
- 双key策略，主key设置过期实践，备key永久，主key过期时，返回备key的内容。
- 后台更新缓存，定时更新、消息队列通知更新。

### 缓存击穿

原因：

1. 频繁访问的热点数据过期。

方案：

- 服务熔断。
- 请求限流。
- 构建高可靠集群。

### 缓存穿透

原因：

1. 访问的数据既不在缓存，也不在数据库。

方案：

- 非法请求的限制。
- 缓存空值或默认值。
- 使用布隆过滤器快速判断数据是否存在。

布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。

布隆过滤器会通过 3 个操作完成标记：

- 第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
- 第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。
- 第三步，将每个哈希值在位图数组的对应位置的值设置为 1；

**当应用要查询数据 x 是否在数据库时，通过布隆过滤器只要查到位图数组中的 N 个位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中**。

布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时存在哈希冲突的可能性，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，**存在误判的情况**。

所以，**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。

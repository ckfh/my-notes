Online Job Scheduling in Distributed Machine Learning Clusters

离线优化算法：
一个在某段时间间隔内到达的JOB，需要做出以下决定：
1、是否接受该JOB，用一个二进制变量表示，未被接受的JOB可以排在一个队列中或在一个时间段后重新提交。
2、在到达时间后的每个时间段内，所持有的WORKER数量。
3、在到达时间后的每个时间段内，所持有的SERVER数量。
频繁地调整所持有的WORKER和SERVER数量是不切实际的，因此一个时间段通常比一个EPOCH的时间要长。
每个JOB都有一个非负值的效用，它是和完成时间有关的一个函数值。
离线优化算法的目标是最大化整体效用同时满足各种约束条件。

在线算法：
为了规避离线优化算法当中的非常规约束，需要将离线优化算法的目标函数重新整理成一个整数的线性规划。
它给予每个JOB一个可行的执行时间表，时间表中有完成时间，WORKER和SERVER数目。

资源：有多个物理服务器，每个物理服务器上可以部署多个WORKER（SERVER），
每个WORKER（SERVER）都占有部分的物理服务器上存在的真实物理资源，GPU、CPU、带宽等等。

每当一个任务到达，计算该任务的最佳调度方案，如果得到的回报（效用减去占用的资源）为正数，则接受该任务。
为了实现上述的方案，需要解决以下三个问题：
1、如何找到最佳调度方案，枚举指数级别的调度方案是不实际的，而是设计一个高效的子程序，找到这个调度方案。
2、计算所占有的资源成本，即用某资源的单位成本乘以所占用的某资源大小。

算法一：
输入：系统可用的最大时间段、资源大小；
输出：是否接受该JOB，WORKER和SERVER的分配方案；
{
	初始时：worker和server的分配皆为零，因此当前占有的资源也为零，资源的价格也以资源数为零时进行计算。
	每当到达一个新的作业，使用算法二计算JOB的最佳时间表和回报；
	如果回报为正数：
	{
		接受该JOB；
		从时间表中获取不同时间段内的worker和server的分配方案；
		更新此时全体作业占用的资源数；
		更新资源被占用后，资源的价格；
		下一个作业指定最佳时间表时，将取决于当时的资源数以及资源对应的价格；
		！！！因此资源的价格是会变化的。
		！！！可以理解为资源数限制了作业的worker分配，而价格则是限制了低效用作业的安排。
	}
}

价格函数符合以下几种规则：
{
	价格函数在一开始时要足够小，以便能够接受更多的JOB。
	一开始时，作业还不占有任何资源，此时价格函数是L1和L2，这两个是最小的单位JOB效用。

	!!!当作业分配的资源增加时，价格会呈指数级增长，以便过滤早到的低效用的工作，为晚到的高效用工作预留资源。
    价格会在算法2中排序服务器时被使用，因为服务器上有多种资源，因此计算时是统计所有资源的一个价格之和。

	某资源被耗尽时，对应的价格要足够高，以便不再接受需要该资源的作业。
	因此当某个服务器上的某个资源被全部占用时，将不再接受需要这部分资源的作业，价格函数此时等于U1R和U2R，
	！！！表示在该资源上已经取得了最大的作业效用。
	在作业到达之前，价格函数所需的几项参数都是未知的，因此只能基于过去的经验估计这些参数，多多少少会影响调度方案的生成。

	!!!价格函数所体现的是一个资源的利用程度，资源利用率越高则可用资源越少，因此价格应该越高。
}

如何解决非常规约束：
{
	！！！既然未知的完成时间是一个非常规约束，那我们就去固定这个完成时间，
	！！！即假设某个任务在指定的完成时间段完成要如何去安排它的调度方案。
	①如果指定了作业的完成时间段，则意味着作业的效用也被确定，这样优化问题就变成了求取最小的资源成本。

	所有数据块都被训练一次后称为一个epoch，而在达到指定epoch的数量后，作业停止训练。
	一旦指定了完成时间段，就需要给出一种能在到达时间和完成时间之间将全部数据块都训练epoch次数的方案。
	训练一个数据块比起一个时间间隔要来得短，可以假设在一个时间间隔内可以训练整数个的数据块。
	将epoch数目乘以数据块的数目作为一个作业的总体工作量，我们可以将这个总体工作量分散到不同的时间段当中。
	②如果我们知道每个时间段各自需要完成多少的工作量，那问题就进一步简化成求在每个时间段内达到指定工作量所需的最小资源成本。
}

如何寻找最佳的调度方案
{
	基于上述的优化，寻找最佳调度方案的流程如下：
	①枚举一个作业从到达时间到系统给定时间内的所有时间段作为结束时间。
	②对于给定的结束时间，使用一个（动态规划）计算分配工作量的最佳方案。
	③使用（贪心算法）决定每个时间段的部署方案。
	最后只有回报值最高的方案被选为最佳调度方案。
}

算法二：
输入：系统时间段，截止到调用函数为止的资源使用率以及资源价格；
输出：最佳调度表和回报；
{
	初始化：回报为0，无调度表，WORKER和SERVER都为0
	（枚举）结束时间段
	{
		调用DP_COST（当前结束时间段，总体工作量）获取资源成本以及调度表
		计算回报
		如果当前结束时间段所给到的回报更大，则其调度表作为最佳调度表。
	}

	DP_COST：
	{
		本质上是实现这样的一个规划方程：
		在每一个时间段上都去寻找调用cost_t后获得的一个最小成本，将成本和作为该作业的资源成本。

		枚举工作量（工作量可量化，即epoch数目乘以数据块数目）：
		以当前枚举的工作量以及结束时间段调用cost_t得到cost_t返回值，调度方案；
		递归调用DP_COST，其参数是之前的时间段以及剩余工作量；
		
		!!!实际上就是在每一个时间段内去枚举其可能的工作量并调用cost_t函数（比如最后一个时间段枚举到1单位的工作量，
		则前一个时间段只能枚举(TOTAL-1)单位的工作量，根据枚举出的工作量大小以及自身所处的时间段
		调用cost_t函数获取一个返回值以及该时间段内的部署方案，

		当尝试用一个枚举出来的工作量以及自身所处的时间段作为结束时间去拿到的一个资源成本时，
		如果该资源成本加上之前时段的资源成本要小于已经计算的最小资源成本（之前枚举的
		则更新最小资源成本，将当前拿到的部署方案合并到之前时段的部署方案当中作为调度方案。
		其中被计算出来的资源成本将被存储，在后续的计算中重复使用。
	}

	COST_t(时段，工作量)：
	{
		初始化：w、s数量为0；
		根据价格相关函数升序排序可用服务器资源（从最便宜到最贵）；
		计算工作量对应的执行时间；

		循环可用资源最大程度地部署worker，所谓“最大程度”就是将服务器上的可用资源全部用完，直到无法部署worker；
		最大程度有三种选择：一：当前服务器上的可用资源都用于部署worker（遵从最少资源部署，因为超过了某资源限制，其它资源多余也无法部署）；二：部署的worker和之前服务器上部署的worker之和不超过数据块数目；三：仍剩余的执行时间所需worker数目。
		每在一台服务器上部署worker，便将当前工作量对应的执行时间扣除对应的worker数量的执行时间。
		循环完毕时，如果执行时间仍大于零，则表示仍需要部署worker（资源不足），返回无穷大的成本。

		对server仍是相同的策略，它的最大程度也是三种选择：一、和worker一致；二：带宽要满足worker；三：不超过worker数目；
		以上条件一旦满足一个，就确定了当前服务器所部署的server个数。
		循环结束时，带宽不足以支撑worker，返回无穷大的成本；

		如果以上流程没有提前截止，则返回当前时间段完成指定工作量对应的资源成本以及部署方案。
	}

	1.给你一个时间段和一个工作量，你要在这个时间段内将这个工作量消耗完毕，即使时间段没有用完；
	2.怎么消耗工作量，当然是部署worker，假设要求该时间段内必须训练50个epoch，部署得过少则会导致在该时间段内无法完成；
	3.为什么要过滤一些低效用的作业，假设有10个单位的资源，先到达一个2单位资源的长时间作业，后到达一个9单位资源的短时间作业，
	如果以人工的方式去考虑调度，则我们更倾向于先调度9单位资源的短时间作业，因此就需要有一些手段来完成这个目的；
	4.设定一个价格函数。
}

价格函数
{
	效用函数（sigmoid函数）：
	变量：作业的实际结束时间；
	常量：作业的目标结束时间、作业的优先级、作业对时间的敏感程度；
	!!!根据sigmoid函数的图像，当一个作业的实际完成时间比起目标完成时间越小时，它所得到的效用则越大。
	
	价格函数（指数函数）：
	变量：当前时段某服务器上某资源的使用量；
	常量：某服务器上可用于部署w和s的某资源的总容量；

	当某个资源的使用率达到1时，此时价格函数的值是一个”最大每单位资源效用“。

	一个作业如果在全程时段内都使用最大可用的worker数目（数据块数目）进行训练时，此时作业将以理论上的最短时间完成训练，
	而在效用函数中带入每个作业的最短完成时间得到的将是每个作业的最大效用。
	用最大效用除以该作业部署一个worker所需的资源得到的便是该作业的”最大每单位资源效用“，
	而在所有作业当中的“最大每单位资源效用（单个作业）”的最大值就是“最大每单位资源效用（全体作业中）”。
	
	当某个资源的使用率为0时，此时价格函数的值是一个“最小每单位时间单位资源效用（全体作业中）”。

	一个作业的最长完成时间实际上就是在系统给定的最大完成时间，此时作业的效用将达到最低。
	
	!!!注意完成时间和运行时间是不一样的

	不是说将到达的时间加上运行时间得到的就是完成时间，因为运行时间可以是分散的，它可以集中在一个时段内运行完毕，
	也可以在连续多个时段内分多次运行完毕，此时两者的完成时间是完全不同的。
	!!!注意上述的作业的最短运行时间是可以作为完成时间的。

	最低效用/(作业所需的运行时间×一个worker所需的资源)=作业最低效用。
}


结合价格函数、动态规划、贪心算法可以理解论文的idea就是为每次到达的作业尽可能地分配资源利用率低的服务器上的资源（平均策略？
且过滤掉一些低效用作业，为后续高效用作业预留资源。


离线算法和在线算法共用一个效用函数，是一个sigmoid函数，其中涉及到的参数有：
作业优先级；
衰减因子（根据作业对时间的敏感程度定义）；
作业的实际完成时间；
作业的目标完成时间。

离线算法说简单点就是静态算法，一次性接收一批作业，然后计算接受要哪些作业，不要哪些作业，
要的这些作业必须达到一个最大效用且满足各种要求，这个最大效用是有关完成时间的一个函数值。
而不要的那些作业可以加入下一批到达作业当中一起调度。
离线算法需要枚举各种可行的方案，并计算总体效用，虽说最后肯定能找到效用最大的调度方案，
但是其本身的时间复杂度非常高（指数级别）。
论文当中使用了两天的时间来获得10个作业的一个最优调度方案。

在线算法和离线算法都考虑一个作业在在到达时间段和完成时间段中的每个时间段内使用不同数量的w/s进行训练，
虽说频繁地切换w/s的数量是不切实际的，这会引入非常大的开销，因此数量上的切换只在每个时间段的开始，
而每个时间段通常要比训练完一个epoch的时间要长，例如一个小时或者更长。

在线算法通过回避离线算法当中的非常规约束将原来的问题改造成整型线性规划问题。
离线算法中的约束大部分都是常规约束，比如：
1、保证被接受的全体作业在系统给定的时间段内训练完毕。
2、训练过程中要满足各种资源的总量约束。

！！！一个作业可能在很早的时候到达，但是由于大部分的资源都被占用，导致其结束时间非常的延后。
！！！因此一个作业的结束时间受到当时资源数的制约，导致无法预测一个准确的结束时间，
且由于效用函数需要取决于该结束时间，因此这导致其成为一个非常规约束。

在线算法通过制定时间表的方式来回避这个不准确的结束时间约束，将问题优化成线性规划问题。
一个作业可能有多个可执行的时间表，但是最终被接受作为最佳执行时间表的只有回报率最高的那一个。
回报=作业效用-资源成本

对每一个到达的作业(枚举结束时间，枚举工作量，枚举服务器)，如果返回的回报值大于零则接受改作业，顺带更新资源总量以及资源价格。

枚举结束时间：对于一个作业来说，从到达时间开始到系统给定的时间都有可能作为其结束时间；
找到一个成本最小的结束时间并返回。

枚举工作量：将工作量分布在从到达时间到结束时间内的所有时段中；
枚举服务器：在服务器上部署worker和server，以完成该时段所安排的工作量；
找到一个成本最小的调度方案返回。

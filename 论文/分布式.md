# 笔记

## 集群和分布式

- 分布式：一个业务分拆多个子业务，部署在不同的服务器上，分布式每一台实现的功能是有差异的，分布式是不同的业务模块拆分到不同的机器上，解决高并发的问题。
- 集群：同一个业务，部署在多个服务器上，集群每一台服务器实现的功能没有什么差别，集群是同一个业务部署在多台机器上，提高系统可用性。

## 消息传递模型

最广为接受的模型就是消息传递模型。什么是消息传递模型？它其实只是指程序通过在进程间传递消息（消息可以理解成带有一些信息和数据的一个数据结构）来完成某些任务。在实践中，并发程序用这个模型去实现特别容易。举例来说，主进程（manager process）可以通过对从进程（worker process）发送一个描述工作的消息来把这个工作分配给它。另一个例子就是一个并发的排序程序可以在当前进程中对当前进程可见的（我们称作本地的，locally）数据进行排序，然后把排好序的数据发送的邻居进程上面来进行合并的操作。几乎所有的并行程序可以使用消息传递模型来描述。

## MIT6.824

可扩展性：扩展可以获得高性能但不是无限扩展无限性能。

- 同步调用场景：在一段IO操作代码块前后输出语句，假设IO操作所需时间非常之久，则位于代码块之后的输出语句也必须等待相同的时间直到IO操作结束才能够执行，假设此处不是输出语句，而是另一部分重要的业务逻辑，那么由于同步的原因导致业务逻辑迟迟无法进行。
- 异步调用场景：同样是在一段IO操作代码块前后输出语句，但是在启动IO操作前，我将IO操作交由另一个线程来执行，我自己继续在当前线程往下执行，如果IO操作完成了，就由它来发出一个通知，告诉我IO操作已经完成了，我可以选择去读取它的结果，这样双方就无需等待对方的执行。

以上场景可以看出来，异步调用的目标结果如果不是用于后续执行，那么就非常适合用异步，如果需要用于后序执行，那么还是乖乖同步等待结果返回后，使用结果继续向后执行。

1. map的过程实际就是一个形式转换的过程，将输入数据转换成另一种形式，方便后续工作。
2. 对于每个map过程来说，都有一个key/value对的集合作为输出。
3. 框架会为每个map输出结果中的相同的key调用一个reduce过程。
4. 一个完整的JOB由一系列的MAPTASK和一系列REDUCETASK组成。
5. 几乎所有的map任务和它对应存储数据的地方都在同一台机器上。

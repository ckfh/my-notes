# 访问数据库

## 使用JDBC

Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：

- 创建全局DataSource实例，表示数据库连接池；
- 在需要读写数据库的方法内部，按如下步骤访问数据库：
  - 从全局DataSource实例获取Connection实例；
  - 通过Connection实例创建PreparedStatement实例；
  - 执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。

**正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务**。

为了在实际工程中，我们需要引入`spring-jdbc`依赖通过Spring使用JDBC。

```Java
// 在AppConfig中，我们需要创建以下几个必须的Bean：
@Configuration
@ComponentScan
// 通过@PropertySource("jdbc.properties")读取数据库配置文件；
@PropertySource("classpath:/jdbc.properties")
public class AppConfig {
    // 通过@Value("${jdbc.url}")注入配置文件的相关配置；
    @Value("${jdbc.url}")
    String jdbcUrl;
    @Value("${jdbc.username}")
    String jdbcUsername;
    @Value("${jdbc.password}")
    String jdbcPassword;
    // 创建一个DataSource实例，它的实际类型是HikariDataSource，创建时需要用到注入的配置；
    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(this.jdbcUrl);
        config.setUsername(this.jdbcUsername);
        config.setPassword(this.jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }
    // 创建一个JdbcTemplate实例，它需要注入DataSource，这是通过方法参数完成注入的。
    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
// 我们只需要在需要访问数据库的Bean中，注入JdbcTemplate即可：
@Component
public class UserService {
    @Autowired
    JdbcTemplate jdbcTemplate;
    ...
}
```

在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式（定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤）。

编写示例代码或者测试代码时，我们强烈推荐使用HSQLDB这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。

需要强调的是，JdbcTemplate只是对JDBC操作的一个简单封装，**它的目的是尽量减少手动编写try(resource) {...}的代码**，对于查询，主要通过RowMapper实现了JDBC结果集到Java对象的转换。

我们总结一下JdbcTemplate的用法，那就是：

- 针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper；
- 针对更新（增/删/改）操作，优选update()，因为只需提供SQL语句和参数；
- 任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。

实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办。那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。

例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下：

```SQL
SELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?
```

Spring提供了JdbcTemplate来简化JDBC操作；**使用JdbcTemplate时，根据需要优先选择高级方法；任何JDBC操作都可以使用保底的execute(ConnectionCallback)方法**。

## 使用声明式事务

> EnableTransactionManagement(EnableAspectJAutoProxy)/Transactional

Spring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。

```Java
// 如果手写事务代码，使用try...catch如下：
TransactionStatus tx = null;
try {
    // 开启事务:
    tx = txManager.getTransaction(new DefaultTransactionDefinition());
    // 相关JDBC操作:
    jdbcTemplate.update("...");
    jdbcTemplate.update("...");
    // 提交事务:
    txManager.commit(tx);
} catch (RuntimeException e) {
    // 回滚事务:
    txManager.rollback(tx);
    throw e;
}
```

Spring为啥要抽象出PlatformTransactionManager和TransactionStatus。原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。**Spring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager**。

```Java
// 因为我们的代码只需要JDBC事务。
// 因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：
@Configuration
@ComponentScan
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
// 使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。
// 使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：
@Configuration
@ComponentScan
@EnableTransactionManagement // 启用声明式
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
}
// 然后，对需要事务支持的方法，加一个@Transactional注解：
@Component
public class UserService {
    // 此public方法自动具有事务支持:
    @Transactional
    public User register(String email, String password, String name) {
       ...
    }
}
// 或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：
@Component
@Transactional
public class UserService {
    ...
}
// Spring对一个声明式事务的方法，如何开启事务支持。
// 原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：
public class UserService$$EnhancerBySpringCGLIB extends UserService {
    // 原始实例
    UserService target = ...
    // 事务实例
    PlatformTransactionManager txManager = ...
    // 覆写后在原始实例调用方法前后实现了类似手写事务管理的逻辑代码
    public User register(String email, String password, String name) {
        TransactionStatus tx = null;
        try {
            tx = txManager.getTransaction(new DefaultTransactionDefinition());
            target.register(email, password, name);
            txManager.commit(tx);
        } catch (RuntimeException e) {
            txManager.rollback(tx);
            throw e;
        }
    }
    ...
}
```

**注意：声明了@EnableTransactionManagement后，不必额外添加@EnableAspectJAutoProxy**。

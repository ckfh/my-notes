# 访问数据库

Spring为了简化数据库访问，主要做了以下几点工作：

- 提供了简化的访问JDBC的模板类，不必手动释放资源；
- 提供了一个统一的DAO类以实现Data Access Object模式；
- 把SQLException封装为DataAccessException，这个异常是一个RuntimeException，并且让我们能区分SQL异常的原因，例如，DuplicateKeyException表示违反了一个唯一约束；
- 能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。

## 使用JDBC

Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：

- 创建全局DataSource实例，表示数据库连接池；
- 在需要读写数据库的方法内部，按如下步骤访问数据库：
  - 从全局DataSource实例获取Connection实例；
  - 通过Connection实例创建PreparedStatement实例；
  - 执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。

**正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务**。

在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。

为了在实际工程中，我们需要引入`spring-jdbc`依赖通过Spring使用JDBC。

在AppConfig中，我们需要创建以下几个必须的Bean：

```Java
@Configuration
@ComponentScan
// 通过@PropertySource("jdbc.properties")读取数据库配置文件；
@PropertySource("classpath:/jdbc.properties")
public class AppConfig {
    // 通过@Value("${jdbc.url}")注入配置文件的相关配置；
    @Value("${jdbc.url}")
    String jdbcUrl;
    @Value("${jdbc.username}")
    String jdbcUsername;
    @Value("${jdbc.password}")
    String jdbcPassword;
    // 创建一个DataSource实例，它的实际类型是HikariDataSource，创建时需要用到注入的配置；
    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(this.jdbcUrl);
        config.setUsername(this.jdbcUsername);
        config.setPassword(this.jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }
    // 创建一个JdbcTemplate实例，它需要注入DataSource，这是通过方法参数完成注入的。
    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

我们只需要在需要访问数据库的Bean中，注入JdbcTemplate即可：

```java
@Component
public class UserService {
    @Autowired
    JdbcTemplate jdbcTemplate;
    ...
}
```

### JdbcTemplate用法

- 使用高级方法进行查询操作时，不再需要自己依次去打开connection/PreparedStatement/ResultSet对象来获取结果集。
- 使用高级方法进行更新操作时，不再需要自己依次去打开connection/PreparedStatement来执行SQL语句。
- 除了减少try...catch代码块这一最大优点外，JdbcTemplate内部还进行了各种优化操作，比如把SQLException封装为DataAccessException，可以让我们准确区分SQL异常的原因。

Spring提供的JdbcTemplate采用Template模式，提供了一系列以**回调**为特点的工具方法，**目的是避免繁琐的try...catch语句**。

在这里，所谓的回调，调用的其实是你传入的函数式接口对象当中的唯一方法，而这个唯一方法的代码逻辑则由你自己来实现，因为返回值是泛型类型，所以返回的类型完全可以由我们自己决定。

```java
// 源码一:
@FunctionalInterface
public interface ConnectionCallback<T> {
    @Nullable
    T doInConnection(Connection con) throws SQLException, DataAccessException;
}
// 源码二:
@Override
@Nullable
public <T> T execute(ConnectionCallback<T> action) throws DataAccessException {
    Assert.notNull(action, "Callback object must not be null");
    // 帮助我们获取connection对象:
    Connection con = DataSourceUtils.getConnection(obtainDataSource());
    try {
        // Create close-suppressing Connection proxy, also preparing returned Statements.
        Connection conToUse = createConnectionProxy(con);
        // 调用我们传入的ConnectionCallback对象当中的doInConnection方法，该方法需要一个connection对象:
        return action.doInConnection(conToUse);
    }
    catch (SQLException ex) {
        // Release Connection early, to avoid potential connection pool deadlock
        // in the case when the exception translator hasn't been initialized yet.
        String sql = getSql(action);
        DataSourceUtils.releaseConnection(con, getDataSource());
        con = null;
        // 帮助我们将SQLException转化为DataAccessException
        throw translateException("ConnectionCallback", sql, ex);
    }
    finally {
        // 帮助我们释放connection对象:
        DataSourceUtils.releaseConnection(con, getDataSource());
    }
}
```

注意以下大部分的JdbcTemplate方法都包含有一个**函数式**接口参数，**我们通过lambda表达式创建子类，并将子类作为参数传递给这些JdbcTemplate方法**。在这里函数式接口的唯一方法其实就是template，具体如何实现完全取决于子类。

我们用lambda表达式创建好接口子类并实现接口方法，然后将接口子类作为参数传给JdbcTemplate方法，而在方法内部，会在准备好所需资源的前提下，**调用我们的接口方法（回调发生在这里）**，调用结束后释放这些资源。

根据方法的返回值进行泛型类型推断，[博客园](https://www.cnblogs.com/binarylei/p/10332100.html)。

```Java
public User getUserById(long id) {
    // <T> T execute(ConnectionCallback<T> action)
    // T doInConnection(Connection con)
    return this.jdbcTemplate.execute((Connection conn) -> {
        // 直接使用conn实例，不要关闭它，回调结束后JdbcTemplate会将其释放:
        // 在内部手动创建的PreparedStatement和ResultSet仍然需要使用try(...)代码块进行释放:
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {
            ps.setObject(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
                }
                throw new RuntimeException("user not found by id.");
            }
        }
    });
}

public User getUserByName(String name) {
    // <T> T execute(String sql, PreparedStatementCallback<T> action)
    // T doInPreparedStatement(PreparedStatement ps)
    return this.jdbcTemplate.execute("SELECT * FROM users WHERE name = ?", (PreparedStatement ps) -> {
        // PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:
        ps.setObject(1, name);
        try (ResultSet rs = ps.executeQuery()) {
            if (rs.next()) {
                return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
            }
            throw new RuntimeException("user not found by id.");
        }
    });
}

public User getUserByEmail(String email) {
    // <T> T queryForObject(String sql, Object[] args, RowMapper<T> rowMapper)
    // T mapRow(ResultSet rs, int rowNum)
    return this.jdbcTemplate.queryForObject("SELECT * FROM users WHERE email = ?", new Object[]{email}, (ResultSet rs, int rowNum) -> {
        // 传入SQL语句、参数、以及RowMapper实例:
        // 查看源码会发现我们传入的RowMapper实例会被封装为RowMapperResultSetExtractor实例，该实例中的extractData(ResultSet rs)方法回调了我们传入的实例方法:
        // JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，然后调用extractData(ResultSet rs)从而进一步调用了我们实现的实例方法:
        // 在这里，我们将查询的结果封装为一个JavaBean返回:
        return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
    });
}

public long getUsers() {
    return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM users", null, (ResultSet rs, int rowNum) -> {
        // 在这里，我们选择返回long，这就是泛型带来的好处:
        return rs.getLong(1);
    });
}

public List<User> getUsers(int pageIndex) {
    int limit = 100;
    int offset = limit * (pageIndex - 1);
    // <T> List<T> query(String sql, Object[] args, RowMapper<T> rowMapper)
    // BeanPropertyRowMapper(Class<T> mappedClass)

    // 同样是传入SQL语句、参数、以及RowMapper实例，只不过这里我们传入的是Spring提供的RowMapper接口的实现类BeanPropertyRowMapper:
    // 该类所实现的mapRow(ResultSet rs, int rowNum)方法内部将查询到的结果一一赋值给我们指定的JavaBean，最后封装成一个JavaBean对象返回:
    // 如果表结构和JavaBean属性名称一致，那么JdbcTemplate可以根据BeanPropertyRowMapper直接把一行记录按列名转换为JavaBean并添加到集合当中：
    // 实际上在queryForObject内部也是调用的query方法，只不过前者在行的个数进行了限制，返回的结果必须为一行记录，否则会报错:
    return this.jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?", new Object[]{limit, offset}, new BeanPropertyRowMapper<>(User.class));
}

public void updateUser(User user) {
    // int update(String sql, @Nullable Object... args)

    // 使用update()方法进行插入、更新和删除操作，传入SQL语句及位置参数，返回被影响的行个数:
    if (1 != this.jdbcTemplate.update("UPDATE user SET name = ? WHERE id=?", user.getName(), user.getId())) {
        throw new RuntimeException("User not found by id");
    }
}

@Transactional
public User register(String email, String password, String name) {
    // 如果某一列是自增列（例如自增主键），我们可能需要获取插入后的自增值:
    // JdbcTemplate提供了一个KeyHolder来简化这一操作：
    KeyHolder holder = new GeneratedKeyHolder();
    // int update(PreparedStatementCreator psc, KeyHolder generatedKeyHolder)
    // PreparedStatement createPreparedStatement(Connection con)
    if (1 != jdbcTemplate.update((conn) -> {
        // 记得指定RETURN_GENERATED_KEYS：
        PreparedStatement ps = conn.prepareStatement("INSERT INTO users(email,password,name) VALUES(?,?,?)", Statement.RETURN_GENERATED_KEYS);
        ps.setObject(1, email);
        ps.setObject(2, password);
        ps.setObject(3, name);
        // 接口方法要求返回PreparedStatement对象:
        return ps;
    }, holder)) {
        throw new RuntimeException("Insert failed.");
    }
    // 从KeyHolder中获取返回的自增值:
    return new User(holder.getKey().longValue(), email, password, name);
}
```

需要强调的是，**JdbcTemplate只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写try(resource) {...}的代码，对于查询，主要通过RowMapper实现了JDBC结果集到Java对象的转换**。

我们总结一下JdbcTemplate的用法，那就是：

- 针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper，**注意后者在查询时如果不存在任一匹配行将报IncorrectResultSizeDataAccessException错误**；
- 针对更新（增/删/改）操作，优选update()，因为只需提供SQL语句和参数；
- 任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。

**实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办。那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致**。

例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下：

```sql
SELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?
```

- 使用JdbcTemplate时，根据需要优先选择高级方法；
- 任何JDBC操作都可以使用保底的execute(ConnectionCallback)方法。

## 使用声明式事务

> EnableTransactionManagement(EnableAspectJAutoProxy)/Transactional

Spring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。

```Java
// 如果手写事务代码，使用try...catch如下：
TransactionStatus tx = null;
try {
    // 开启事务:
    tx = txManager.getTransaction(new DefaultTransactionDefinition());
    // 相关JDBC操作:
    jdbcTemplate.update("...");
    jdbcTemplate.update("...");
    // 提交事务:
    txManager.commit(tx);
} catch (RuntimeException e) {
    // 回滚事务:
    txManager.rollback(tx);
    throw e;
}
```

Spring为啥要抽象出PlatformTransactionManager和TransactionStatus。原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。**Spring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager**。

```Java
// 因为我们的代码只需要JDBC事务。
// 因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：
@Configuration
@ComponentScan
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
// 使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。
// 使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：
@Configuration
@ComponentScan
@EnableTransactionManagement // 启用声明式
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
}
// 然后，对需要事务支持的方法，加一个@Transactional注解：
@Component
public class UserService {
    // 此public方法自动具有事务支持:
    @Transactional
    public User register(String email, String password, String name) {
       ...
    }
}
// 或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：
@Component
@Transactional
public class UserService {
    ...
}
// Spring对一个声明式事务的方法，如何开启事务支持。
// 原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：
public class UserService$$EnhancerBySpringCGLIB extends UserService {
    // 原始实例
    UserService target = ...
    // 事务实例
    PlatformTransactionManager txManager = ...
    // 覆写后在原始实例调用方法前后实现了类似手写事务管理的逻辑代码
    public User register(String email, String password, String name) {
        TransactionStatus tx = null;
        try {
            tx = txManager.getTransaction(new DefaultTransactionDefinition());
            target.register(email, password, name);
            txManager.commit(tx);
        } catch (RuntimeException e) {
            txManager.rollback(tx);
            throw e;
        }
    }
    ...
}
```

**注意：声明了@EnableTransactionManagement后，不必额外添加@EnableAspectJAutoProxy**。

**默认情况下，如果发生了RuntimeException，Spring的声明式事务将自动回滚。**

```Java
// 在一个事务方法中，如果程序判断需要回滚事务，只需抛出RuntimeException，例如：
@Transactional
public buyProducts(long productId, int num) {
    ...
    if (store < num) {
        // 库存不够，购买失败:
        throw new IllegalArgumentException("No enough products");
    }
    ...
}
// 如果要针对Checked Exception回滚事务，需要在@Transactional注解中写出来：
@Transactional(rollbackFor = {RuntimeException.class, IOException.class})
public buyProducts(long productId, int num) throws IOException {
    ...
}
// 为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作：
public class BusinessException extends RuntimeException {
    ...
}

public class LoginException extends BusinessException {
    ...
}

public class PaymentException extends BusinessException {
    ...
}
```

**在使用事务的时候，明确事务边界非常重要。**

```Java
// 对于声明式事务，例如，下面的register()方法：
@Component
public class UserService {
    @Transactional
    public User register(String email, String password, String name) { // 事务开始
       ...
    } // 事务结束
}
// 类似的，一个负责给用户增加积分的addBonus()方法：
@Component
public class BonusService {
    @Transactional
    public void addBonus(long userId, int bonus) { // 事务开始
       ...
    } // 事务结束
}
// 在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：
@Component
public class UserService {
    @Autowired
    BonusService bonusService;

    @Transactional
    public User register(String email, String password, String name) {
        // 插入用户记录:
        User user = jdbcTemplate.insert("...");
        // 增加100积分:
        bonusService.addBonus(user.id, 100);
    }
}
```

现在问题来了：调用方（比如RegisterController）调用UserService.register()这个事务方法，它在内部又调用了BonusService.addBonus()这个事务方法，一共有几个事务。如果addBonus()抛出了异常需要回滚事务，register()方法的事务是否也要回滚。

要解决上面的问题，我们首先要定义事务的传播模型。

```Java
// 假设用户注册的入口是RegisterController，它本身没有事务，仅仅是调用UserService.register()这个事务方法：
@Controller
public class RegisterController {
    @Autowired
    UserService userService;

    @PostMapping("/register")
    public ModelAndView doRegister(HttpServletRequest req) {
        String email = req.getParameter("email");
        String password = req.getParameter("password");
        String name = req.getParameter("name");
        // 因此，UserService.register()这个事务方法的起始和结束，就是事务的范围。
        User user = userService.register(email, password, name);
        return ...
    }
}
// 我们需要关心的问题是，在UserService.register()这个事务方法内，调用BonusService.addBonus()，我们期待的事务行为是什么：
@Transactional
public User register(String email, String password, String name) {
    // 事务已开启:
    User user = jdbcTemplate.insert("...");
    // ???:
    bonusService.addBonus(user.id, 100);
} // 事务结束
```

对于大多数业务来说，我们期待BonusService.addBonus()的调用，和UserService.register()应当融合在一起，它的行为应该如下：UserService.register()已经开启了一个事务，那么在内部调用BonusService.addBonus()时，BonusService.addBonus()方法就没必要再开启一个新事务，直接加入到UserService.register()的事务里就好了。

其实就相当于在**一个事务**内：

  1. UserService.register()先执行了一条INSERT语句：INSERT INTO users ...
  2. BonusService.addBonus()再执行一条INSERT语句：INSERT INTO bonus ...

因此，Spring的声明式事务为事务传播定义了几个级别，默认传播级别就是REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。

我们观察UserService.register()方法，它在RegisterController中执行，因为RegisterController没有事务，因此，UserService.register()方法会自动创建一个新事务。在UserService.register()方法内部，调用BonusService.addBonus()方法时，因为BonusService.addBonus()检测到当前已经有事务了，因此，它会加入到当前事务中执行。

因此，整个业务流程的事务**边界**就清晰了：它只有一个事务，并且**范围**就是UserService.register()方法。

有的童鞋会问：把BonusService.addBonus()方法的@Transactional去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？去掉BonusService.addBonus()方法的@Transactional，会引来另一个问题，即其它地方如果单独调用BonusService.addBonus()方法，那就没法保证事务了。

默认的事务传播级别是REQUIRED，它满足绝大部分的需求。还有一些其它的传播级别：

- SUPPORTS：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；
- MANDATORY：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；
- REQUIRES_NEW：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；
- NOT_SUPPORTED：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；
- NEVER：和NOT_SUPPORTED相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；
- NESTED：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。

上面这么多种事务的传播级别，**其实默认的REQUIRED已经满足绝大部分需求，SUPPORTS和REQUIRES_NEW在少数情况下会用到，其它基本不会用到**，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。

```Java
// 定义事务的传播级别也是写在@Transactional注解里的：
@Transactional(propagation = Propagation.REQUIRES_NEW)
public Product createProduct() {
    ...
}
```

**Spring是如何传播事务的（一个事务方法，如何获知当前是否存在事务）。Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的。**

```Java
// 我们在JDBC中使用事务的时候，是这么个写法：
Connection conn = openConnection();
try {
    // 关闭自动提交:
    conn.setAutoCommit(false);
    // 执行多条SQL语句:
    insert(); update(); delete();
    // 提交事务:
    conn.commit();
} catch (SQLException e) {
    // 回滚事务:
    conn.rollback();
} finally {
    conn.setAutoCommit(true);
    conn.close();
}
```

**答案是使用ThreadLocal。Spring总是把JDBC相关的Connection和TransactionStatus实例绑定到ThreadLocal。如果一个事务方法从ThreadLocal未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从ThreadLocal获取的JDBC连接以及TransactionStatus。**

**因此，事务能正确传播的前提是，方法调用是在一个线程内才行。**

```Java
// 如果像下面这样写：
@Transactional
public User register(String email, String password, String name) { // BEGIN TX-A
    User user = jdbcTemplate.insert("...");
    new Thread(() -> {
        // BEGIN TX-B:
        bonusService.addBonus(user.id, 100);
        // END TX-B
    }).start();
} // END TX-A
```

在另一个线程中调用BonusService.addBonus()，它根本获取不到当前事务（ThreadLocal为每个线程都开辟了独立的存储空间），因此，UserService.register()和BonusService.addBonus()两个方法，将分别开启两个完全独立的事务。

**换句话说，事务只能在当前线程传播，无法跨线程传播。**那如果我们想实现跨线程传播事务呢。原理很简单，就是要想办法把当前线程绑定到ThreadLocal的Connection和TransactionStatus实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。

**Spring提供的声明式事务极大地方便了在数据库中使用事务，正确使用声明式事务的关键在于确定好事务边界，理解事务传播级别。**

## 使用DAO

**在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。**因此，实现数据访问层就是用JdbcTemplate实现对数据库的操作。

编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写。即当我们需要插入user表的一行时，我们不再传入组成一个User对象的所有属性参数，而是选择传入一整个User对象，使用DAO模式时尽可能以**对象**为单位进行各项数据库操作。

```Java
// 它没有什么神秘之处，实现起来基本如下：
public class UserDao {
    // 注入JdbcTemplate实例后，利用该实例进行各项数据库操作
    @Autowired
    JdbcTemplate jdbcTemplate;

    User getById(long id) {
        ...
    }

    List<User> getUsers(int page) {
        ...
    }

    User createUser(User user) {
        ...
    }

    User updateUser(User user) {
        ...
    }

    void deleteUser(User user) {
        ...
    }
}
// Spring提供了一个JdbcDaoSupport类，用于简化DAO的实现。
// 这个JdbcDaoSupport没什么复杂的，核心代码就是持有一个JdbcTemplate：
public abstract class JdbcDaoSupport extends DaoSupport {

    private JdbcTemplate jdbcTemplate;

    public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        initTemplateConfig();
    }

    public final JdbcTemplate getJdbcTemplate() {
        return this.jdbcTemplate;
    }

    ...
}
// 它的意图是子类直接从JdbcDaoSupport继承后，可以随时调用getJdbcTemplate()获得JdbcTemplate的实例。
// 那么问题来了：因为JdbcDaoSupport的jdbcTemplate字段没有标记@Autowired，所以，子类想要注入JdbcTemplate，还得自己想个办法：
@Component
@Transactional
public class UserDao extends JdbcDaoSupport {
    // 子类先对自己注入JdbcTemplate实例(成员变量先于构造方法)
    @Autowired
    JdbcTemplate jdbcTemplate;
    // 在构造方法调用之后为父类的jdbcTemplate字段进行赋值
    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }
}
// 既然UserDao都已经注入了JdbcTemplate，那再把它放到父类里，通过getJdbcTemplate()访问岂不是多此一举。
// 如果使用传统的XML配置，并不需要编写@Autowired JdbcTemplate jdbcTemplate，但是考虑到现在基本上是使用注解的方式。
// 我们可以编写一个AbstractDao，专门负责注入JdbcTemplate：
public abstract class AbstractDao extends JdbcDaoSupport {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }
}
// 这样，子类的代码就非常干净，可以直接调用getJdbcTemplate()：
@Component
@Transactional
public class UserDao extends AbstractDao {
    public User getById(long id) {
        return getJdbcTemplate().queryForObject(
                "SELECT * FROM users WHERE id = ?",
                new BeanPropertyRowMapper<>(User.class),
                id
        );
    }
    ...
}
// 倘若肯再多写一点样板代码，就可以把AbstractDao改成泛型，并实现getById()，getAll()，deleteById()这样的通用方法：
public abstract class AbstractDao<T> extends JdbcDaoSupport {
    private String table;
    private Class<T> entityClass;
    private RowMapper<T> rowMapper;

    public AbstractDao() {
        // 获取当前类型的泛型类型:
        this.entityClass = getParameterizedType();
        this.table = this.entityClass.getSimpleName().toLowerCase() + "s";
        this.rowMapper = new BeanPropertyRowMapper<>(entityClass);
    }

    public T getById(long id) {
        return getJdbcTemplate().queryForObject("SELECT * FROM " + table + " WHERE id = ?", this.rowMapper, id);
    }

    public List<T> getAll(int pageIndex) {
        int limit = 100;
        int offset = limit * (pageIndex - 1);
        return getJdbcTemplate().query("SELECT * FROM " + table + " LIMIT ? OFFSET ?",
                new Object[] { limit, offset },
                this.rowMapper);
    }

    public void deleteById(long id) {
        getJdbcTemplate().update("DELETE FROM " + table + " WHERE id = ?", id);
    }
    ...
}
// 这样，每个子类就自动获得了这些通用方法：
@Component
@Transactional
public class UserDao extends AbstractDao<User> {
    // 已经有了:
    // User getById(long)
    // List<User> getAll(int)
    // void deleteById(long)
}

@Component
@Transactional
public class BookDao extends AbstractDao<Book> {
    // 已经有了:
    // Book getById(long)
    // List<Book> getAll(int)
    // void deleteById(long)
}
```

借助JdbcDaoSupport我们可以从多个子类中将注入JdbcTemplate的操作给抽取到抽象父类当中，并在抽象父类当中定义一些通用方法。

**可见，DAO模式就是一个简单的数据访问模式，是否使用DAO模式，定义DAO层，根据实际情况决定，因为很多时候，直接在Service层操作数据库也是完全没有问题的。**

## 集成Hibernate

> 有了ORM框架后，我们实现数据库各项操作可以围绕JavaBean来进行，不再需要手动编写SQL语句，即使要编写也是编写更加简单并且依旧围绕JavaBean的HQL语句。

使用JdbcTemplate的时候，我们用得最多的方法就是`List<T> query(String sql, Object[] args, RowMapper rowMapper)`。这个RowMapper的作用就是把ResultSet的一行记录映射为Java Bean。

这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。

使用JdbcTemplate配合RowMapper可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如Hibernate。

Hibernate作为ORM框架，它可以替代JdbcTemplate，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。

```Java
// 在AppConfig中，我们仍然需要创建DataSource、引入JDBC配置文件，以及启用声明式事务：
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("classpath:/jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() {
        ...
    }
    // 为了启用Hibernate，我们需要创建一个LocalSessionFactoryBean：
    @Bean
    LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) {
        Properties props = new Properties();
        // 表示自动创建数据库的表结构，注意不要在生产环境中启用：
        props.setProperty("hibernate.hbm2ddl.auto", "update");
        // 指示Hibernate使用的数据库是HSQLDB：
        // Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL：
        props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
        // 让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期：
        props.setProperty("hibernate.show_sql", "true");
        LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        // 指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean：
        sessionFactoryBean.setPackagesToScan("com.cat.entity");
        sessionFactoryBean.setHibernateProperties(props);
        return sessionFactoryBean;
    }
    // Spring为了便于我们使用Hibernate提供的工具类，不是非用不可，但推荐使用以简化代码：
    @Bean
    HibernateTemplate createHibernateTemplate(@Autowired SessionFactory sessionFactory) {
        return new HibernateTemplate(sessionFactory);
    }
    // 配合Hibernate使用声明式事务所必须的：
    @Bean
    PlatformTransactionManager createTxManager(@Autowired SessionFactory sessionFactory) {
        return new HibernateTransactionManager(sessionFactory);
    }
}
```

LocalSessionFactoryBean是一个FactoryBean，它会再自动创建一个SessionFactory（即getObject()方法返回的对象），在Hibernate中，Session是封装了一个JDBC Connection的实例，而SessionFactory是封装了JDBC DataSource的实例，即SessionFactory持有连接池，每次需要操作数据库的时候，SessionFactory创建一个新的Session，相当于从连接池获取到一个新的Connection。**SessionFactory就是Hibernate提供的最核心的一个对象，但LocalSessionFactoryBean是Spring提供的为了让我们方便创建SessionFactory的类**。LocalSessionFactoryBean -> SessionFactory(DataSource) -> Session(Connection)。

```SQL
# email带唯一索引以确保唯一性，createdAt存储整型类型的时间戳：
CREATE TABLE user
    id BIGINT NOT NULL AUTO_INCREMENT,
    email VARCHAR(100) NOT NULL,
    password VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    createdAt BIGINT NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `email` (`email`)
);
```

```Java
public class User {
    private Long id;
    private String email;
    private String password;
    private String name;
    private Long createdAt;

    // getters and setters
    ...
}
// 我们需要添加一些注解来告诉Hibernate如何把User类映射到表记录：
// 如果一个JavaBean被用于映射，我们就标记一个@Entity：
// 默认情况下，映射的表名是user，如果实际的表名不同，例如实际表名是users，可以追加一个@Table(name="users")表示：
@Entity
public class User {
    // 对于主键，还需要用@Id标识，自增主键再追加一个@GeneratedValue，以便Hibernate能读取到自增主键的值：
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    // 每个属性到数据库列的映射用@Column()标识，nullable指示列是否允许为NULL，updatable指示该列是否允许被用在UPDATE语句：
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }
    // length指示String类型的列的长度（如果没有指定，默认是255）：
    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ... }

    @Column(nullable = false, length = 100)
    public String getPassword() { ... }

    @Column(nullable = false, length = 100)
    public String getName() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
}
```

主键id定义的类型不是long，而是Long。这是因为Hibernate如果检测到主键为null，就不会在INSERT语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在INSERT语句中直接列出。long型字段总是具有默认值0，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。createdAt虽然是整型，但我们并没有使用long，而是Long，这是因为使用基本类型会导致某种查询会添加意外的条件，后面我们会详细讨论，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。**使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer**。

```Java
// 再定义一个Book类：
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }

    @Column(nullable = false, length = 100)
    public String getTitle() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
}
```

仔细观察User和Book，会发现它们定义的id、createdAt属性是一样的，这在数据库表结构的设计中很常见：对于每个表，**通常我们会统一使用一种主键生成机制，并添加createdAt表示创建时间，updatedAt表示修改时间等通用字段**。

```Java
// 不必在User和Book中重复定义这些通用字段，我们可以把它们提到一个抽象类中：
// 对于AbstractEntity来说，我们要标注一个@MappedSuperclass表示它用于继承：
@MappedSuperclass
public abstract class AbstractEntity {

    private Long id;
    private Long createdAt;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
    // 定义了一个@Transient方法，它返回一个“虚拟”的属性。因为getCreatedDateTime()是计算得出的属性，而不是从数据库表读出的值，因此必须要标注@Transient：
    // 否则Hibernate会尝试从数据库读取名为createdDateTime这个不存在的字段从而出错。
    @Transient
    public ZonedDateTime getCreatedDateTime() {
        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());
    }
    // @PrePersist标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句）：
    // Hibernate会先执行该方法，这样我们就可以自动设置好createdAt属性（不需要调用数据库函数也不需要在insert语句中列出）：
    @PrePersist
    public void preInsert() {
        this.setCreatedAt(System.currentTimeMillis());
    }
}
// 有了AbstractEntity，我们就可以大幅简化User和Book：
@Entity
public class User extends AbstractEntity {

    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ... }

    @Column(nullable = false, length = 100)
    public String getPassword() { ... }

    @Column(nullable = false, length = 100)
    public String getName() { ... }
}
```

注意到使用的所有注解均来自javax.persistence，它是JPA规范的一部分。这里我们只介绍使用注解的方式配置Hibernate映射关系，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要hibernate.cfg.xml配置文件，用一句话总结：**使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置**。

类似User、Book这样的用于ORM的Java Bean，我们通常称之为Entity Bean。

我们来看看如果对user表进行增删改查。因为使用了Hibernate，因此，我们要做的，**实际上是对User这个JavaBean进行“增删改查”**。

```Java
// 编写一个UserService，注入HibernateTemplate以便简化代码：
@Component
@Transactional
public class UserService {
    @Autowired
    HibernateTemplate hibernateTemplate;
    @Autowired
    SessionFactory sessionFactory;
    // 要持久化（插入）一个User实例，我们只需调用save()方法。以register()方法为例，代码如下：
    public User register(String email, String password, String name) {
        // 创建对象并设置属性但不要设置id，因为使用了自增主键：
        User user = new User();
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);
        // 保存到数据库：
        this.hibernateTemplate.save(user);
        // 此时已经自动获得了id：
        System.out.println(user.getId());
        return user;
    }
    // 删除一个User相当于从表中删除对应的记录。注意Hibernate总是用id来删除记录，因此，要正确设置User的id属性才能正常删除记录：
    public boolean deleteUser(Long id) {
        // 通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除：
        // load()和get()都可以根据主键加载记录，它们的区别在于，当记录不存在时，get()返回null，而load()抛出异常：
        User user = this.hibernateTemplate.get(User.class, id);
        if (user != null) {
            this.hibernateTemplate.delete(user);
            return true;
        }
        return false;
    }
    // 更新记录相当于先更新User的指定属性，然后调用update()方法：
    public void updateUser(Long id, String name) {
        User user = this.hibernateTemplate.load(User.class, id);
        user.setName(name);
        this.hibernateTemplate.update(user);
    }

    public User login(String email, String password) {
        // SELECT * FROM user WHERE email = ? AND password = ?

        // 使用Example查询：
        // 使用findByExample()，给出一个User实例，Hibernate把该实例所有非null的属性拼成WHERE条件：
        // 因为example实例只有email和password两个属性为非null，所以最终生成的WHERE语句就是WHERE email = ? AND password = ?：
//        User example = new User();
//        example.setEmail(email);
//        example.setPassword(password);
//        List<User> list = this.hibernateTemplate.findByExample(example);
//        return list.isEmpty() ? null : list.get(0);

        // 使用Criteria查询：
        // DetachedCriteria使用链式语句来添加多个AND条件：
        DetachedCriteria criteria = DetachedCriteria.forClass(User.class);
        criteria.add(Restrictions.eq("email", email))
                .add(Restrictions.eq("password", password));
        // 和findByExample()相比，findByCriteria()可以组装出更灵活的WHERE条件，例如：
        // SELECT * FROM user WHERE (email = ? OR name = ?) AND password = ?
        // 只要组织好Restrictions的嵌套关系，Criteria查询可以实现任意复杂的查询：
//        criteria.add(
//                Restrictions.and(
//                        Restrictions.or(
//                                Restrictions.eq("email", email),
//                                Restrictions.eq("name", email)
//                        ),
//                        Restrictions.eq("password", password)
//                )
//        );
        List<User> list = (List<User>) this.hibernateTemplate.findByCriteria(criteria);
        return list.isEmpty() ? null : list.get(0);
        // 使用HQL查询：
//        List<User> list = (List<User>) this.hibernateTemplate.find("FROM User WHERE email=? AND password=?", email, password);
//        return list.isEmpty() ? null : list.get(0);
        // 使用NamedQuery查询：
//        List<User> list = (List<User>) this.hibernateTemplate.findByNamedQuery("login", email, password);
//        return list.isEmpty() ? null : list.get(0);
    }
    // 使用Hibernate的原生接口实际上总是从SessionFactory出发，它通常用全局变量存储：
    // 有了SessionFactory，使用Hibernate用法如下：
    public void operation(Long id) {
        Session session = null;
        boolean isNew = false;
        // 获取当前Session或者打开新的Session:
        try {
            session = this.sessionFactory.getCurrentSession();
        } catch (HibernateException e) {
            session = this.sessionFactory.openSession();
            isNew = true;
        }
        // 操作Session:
        try {
            User user = session.load(User.class, id);
        } finally {
            // 关闭新打开的Session:
            if (isNew) {
                session.close();
            }
        }
    }
}
```

前面我们在定义User时，对有的属性标注了@Column(updatable=false)。Hibernate在更新记录时，它只会把@Column(updatable=true)的属性加入到UPDATE语句中，这样可以提供一层额外的安全性，即如果不小心修改了User的email、createdAt等属性，执行update()时并不会更新对应的数据库列。但也必须牢记：**这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行UPDATE语句仍然可以更新数据库的任意列的值**。

如果我们把User的createdAt的类型从Long改为long，findByExample()的查询将出问题，原因在于example实例的long类型字段有了默认值0，导致Hibernate最终生成的WHERE语句意外变成了WHERE email = ? AND password = ? AND createdAt = 0。显然，额外的查询条件将导致错误的查询结果。**使用findByExample()时，注意基本类型字段总是会加入到WHERE条件**！

**和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名**。详细的HQL语法可以参考Hibernate文档。

## 集成JPA

# 访问数据库

Spring为了简化数据库访问，主要做了以下几点工作：

- 提供了简化的访问JDBC的模板类，不必手动释放资源；
- 提供了一个统一的DAO类以实现Data Access Object模式；
- 把SQLException封装为DataAccessException，这个异常是一个RuntimeException，并且让我们能区分SQL异常的原因，例如，DuplicateKeyException表示违反了一个唯一约束；
- 能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。

## 使用JDBC

Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：

- 创建全局DataSource实例，表示数据库连接池；
- 在需要读写数据库的方法内部，按如下步骤访问数据库：
  - 从全局DataSource实例获取Connection实例；
  - 通过Connection实例创建PreparedStatement实例；
  - 执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。

**正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务**。

在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。

为了在实际工程中，我们需要引入`spring-jdbc`依赖通过Spring使用JDBC。

在AppConfig中，我们需要创建以下几个必须的Bean：

```Java
@Configuration
@ComponentScan
// 通过@PropertySource("jdbc.properties")读取数据库配置文件；
@PropertySource("classpath:/jdbc.properties")
public class AppConfig {
    // 通过@Value("${jdbc.url}")注入配置文件的相关配置；
    @Value("${jdbc.url}")
    String jdbcUrl;
    @Value("${jdbc.username}")
    String jdbcUsername;
    @Value("${jdbc.password}")
    String jdbcPassword;
    // 创建一个DataSource实例，它的实际类型是HikariDataSource，创建时需要用到注入的配置；
    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(this.jdbcUrl);
        config.setUsername(this.jdbcUsername);
        config.setPassword(this.jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }
    // 创建一个JdbcTemplate实例，它需要注入DataSource，这是通过方法参数完成注入的。
    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

我们只需要在需要访问数据库的Bean中，注入JdbcTemplate即可：

```java
@Component
public class UserService {
    @Autowired
    JdbcTemplate jdbcTemplate;
    ...
}
```

### JdbcTemplate用法

- 使用高级方法进行查询操作时，不再需要自己依次去打开connection/PreparedStatement/ResultSet对象来获取结果集。
- 使用高级方法进行更新操作时，不再需要自己依次去打开connection/PreparedStatement来执行SQL语句。
- 除了减少try...catch代码块这一最大优点外，JdbcTemplate内部还进行了各种优化操作，比如把SQLException封装为DataAccessException，可以让我们准确区分SQL异常的原因。

Spring提供的JdbcTemplate采用Template模式，提供了一系列以**回调**为特点的工具方法，**目的是避免繁琐的try...catch语句**。

在这里，所谓的回调，调用的其实是你实现并传入的函数式接口对象当中的唯一方法，而这个唯一方法的代码逻辑则由你自己来实现，因为返回值是泛型类型，所以返回的类型完全可以由我们自己决定。

```java
// 源码一:
@FunctionalInterface
public interface ConnectionCallback<T> {
    @Nullable
    T doInConnection(Connection con) throws SQLException, DataAccessException;
}
// 源码二:
@Override
@Nullable
public <T> T execute(ConnectionCallback<T> action) throws DataAccessException {
    Assert.notNull(action, "Callback object must not be null");
    // 帮助我们获取connection对象:
    Connection con = DataSourceUtils.getConnection(obtainDataSource());
    try {
        // Create close-suppressing Connection proxy, also preparing returned Statements.
        Connection conToUse = createConnectionProxy(con);
        // 调用我们传入的ConnectionCallback对象当中的doInConnection方法，该方法需要一个connection对象:
        return action.doInConnection(conToUse);
    }
    catch (SQLException ex) {
        // Release Connection early, to avoid potential connection pool deadlock
        // in the case when the exception translator hasn't been initialized yet.
        String sql = getSql(action);
        DataSourceUtils.releaseConnection(con, getDataSource());
        con = null;
        // 帮助我们将SQLException转化为DataAccessException
        throw translateException("ConnectionCallback", sql, ex);
    }
    finally {
        // 帮助我们释放connection对象:
        DataSourceUtils.releaseConnection(con, getDataSource());
    }
}
```

注意以下大部分的JdbcTemplate方法都包含有一个**函数式**接口参数，**我们通过lambda表达式创建子类，并将子类作为参数传递给这些JdbcTemplate方法**。在这里函数式接口的唯一方法其实就是template，具体如何实现完全取决于子类。

我们用lambda表达式创建好接口子类并实现接口方法，然后将接口子类作为参数传给JdbcTemplate方法，而在方法内部，会在准备好所需资源的前提下，**调用我们的接口方法（回调发生在这里）**，调用结束后释放这些资源。

根据方法的返回类型进行泛型类型推断，[博客园](https://www.cnblogs.com/heimianshusheng/p/5766573.html)。

> 需要注意的是：类型推导只能根据调用的参数类型、目标类型（这个马上会讲到）和返回类型（如果有返回的话）进行推导，而不能根据程序后面的一些需求来进行推导。

```Java
public User getUserById(long id) {
    // <T> T execute(ConnectionCallback<T> action)
    // T doInConnection(Connection con)
    return this.jdbcTemplate.execute((Connection conn) -> {
        // 直接使用conn实例，不要关闭它，回调结束后JdbcTemplate会将其释放:
        // 在内部手动创建的PreparedStatement和ResultSet仍然需要使用try(...)代码块进行释放:
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {
            ps.setObject(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
                }
                throw new RuntimeException("user not found by id.");
            }
        }
    });
}

public User getUserByName(String name) {
    // <T> T execute(String sql, PreparedStatementCallback<T> action)
    // T doInPreparedStatement(PreparedStatement ps)
    return this.jdbcTemplate.execute("SELECT * FROM users WHERE name = ?", (PreparedStatement ps) -> {
        // PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:
        ps.setObject(1, name);
        try (ResultSet rs = ps.executeQuery()) {
            if (rs.next()) {
                return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
            }
            throw new RuntimeException("user not found by id.");
        }
    });
}

public User getUserByEmail(String email) {
    // <T> T queryForObject(String sql, Object[] args, RowMapper<T> rowMapper)
    // T mapRow(ResultSet rs, int rowNum)
    return this.jdbcTemplate.queryForObject("SELECT * FROM users WHERE email = ?", new Object[]{email}, (ResultSet rs, int rowNum) -> {
        // 传入SQL语句、参数、以及RowMapper实例:
        // 查看源码会发现我们传入的RowMapper实例会被封装为RowMapperResultSetExtractor实例，该实例中的extractData(ResultSet rs)方法回调了我们传入的实例方法:
        // JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，然后调用extractData(ResultSet rs)从而进一步调用了我们实现的实例方法:
        // 在这里，我们将查询的结果封装为一个JavaBean返回:
        return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
    });
}

public long getUsers() {
    return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM users", null, (ResultSet rs, int rowNum) -> {
        // mapRow方法不一定返回JavaBean，实际上它可以返回任何Java对象，这就是泛型带来的好处:
        // 顺带一提，getLong()方法虽然返回的long基本类型，但是泛型推断应该是推断成了Long包装类型，因为泛型不接收基本类型:
        return rs.getLong(1);
    });
}

public List<User> getUsers(int pageIndex) {
    int limit = 100;
    int offset = limit * (pageIndex - 1);
    // <T> List<T> query(String sql, Object[] args, RowMapper<T> rowMapper)
    // BeanPropertyRowMapper(Class<T> mappedClass)

    // 同样是传入SQL语句、参数、以及RowMapper实例，只不过这里我们传入的是Spring提供的RowMapper接口的实现类BeanPropertyRowMapper:
    // 该类所实现的mapRow(ResultSet rs, int rowNum)方法内部将查询到的结果一一赋值给我们指定的JavaBean，最后封装成一个JavaBean对象返回:
    // 如果表结构和JavaBean属性名称一致，那么JdbcTemplate可以根据BeanPropertyRowMapper直接把一行记录按列名转换为JavaBean并添加到集合当中：
    // 实际上在queryForObject内部也是调用的query方法，只不过前者在行的个数进行了限制，返回的结果必须为一行记录，否则会报错:
    return this.jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?", new Object[]{limit, offset}, new BeanPropertyRowMapper<>(User.class));
}

public void updateUser(User user) {
    // int update(String sql, @Nullable Object... args)

    // 使用update()方法进行插入、更新和删除操作，传入SQL语句及位置参数，返回被影响的行个数:
    if (1 != this.jdbcTemplate.update("UPDATE user SET name = ? WHERE id=?", user.getName(), user.getId())) {
        throw new RuntimeException("User not found by id");
    }
}

@Transactional
public User register(String email, String password, String name) {
    // 如果某一列是自增列（例如自增主键），我们可能需要获取插入后的自增值:
    // JdbcTemplate提供了一个KeyHolder来简化这一操作：
    KeyHolder holder = new GeneratedKeyHolder();
    // int update(PreparedStatementCreator psc, KeyHolder generatedKeyHolder)
    // PreparedStatement createPreparedStatement(Connection con)
    if (1 != jdbcTemplate.update((conn) -> {
        // 记得指定RETURN_GENERATED_KEYS：
        PreparedStatement ps = conn.prepareStatement("INSERT INTO users(email,password,name) VALUES(?,?,?)", Statement.RETURN_GENERATED_KEYS);
        ps.setObject(1, email);
        ps.setObject(2, password);
        ps.setObject(3, name);
        // 接口方法要求返回PreparedStatement对象:
        return ps;
    }, holder)) {
        throw new RuntimeException("Insert failed.");
    }
    // 从KeyHolder中获取返回的自增值:
    return new User(holder.getKey().longValue(), email, password, name);
}
```

需要强调的是，**JdbcTemplate只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写try(resource) {...}的代码，对于查询，主要通过RowMapper实现了JDBC结果集到Java对象的转换**。

我们总结一下JdbcTemplate的用法，那就是：

- 针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper，**注意后者在查询时如果不存在任一匹配行将报IncorrectResultSizeDataAccessException错误**；
- 针对更新（增/删/改）操作，优选update()，因为只需提供SQL语句和参数；
- 任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。

**实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办。那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致**。

例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下：

```sql
SELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?
```

- 使用JdbcTemplate时，根据需要优先选择高级方法；
- 任何JDBC操作都可以使用保底的execute(ConnectionCallback)方法。

## 使用声明式事务

- 使用注解来启用事务，只要抛出RuntimeException，则回滚public方法起始直到错误抛出位置的所有JDBC操作（后续的JDBC操作你也没机会执行了）。
- 注意事务的传播范围，默认是当前有事务则加入，无事务则新建事务。
- 借助了ThreadLocal来判断当前是否有事务。

Spring提供了一个`PlatformTransactionManager`来表示事务管理器，所有的事务都由它负责管理。而事务由`TransactionStatus`表示。

如果手写事务代码，使用try...catch如下：

```Java
TransactionStatus tx = null;
try {
    // 开启事务:
    tx = txManager.getTransaction(new DefaultTransactionDefinition());
    // 相关JDBC操作:
    jdbcTemplate.update("...");
    jdbcTemplate.update("...");
    // 提交事务:
    txManager.commit(tx);
} catch (RuntimeException e) {
    // 回滚事务:
    txManager.rollback(tx);
    throw e;
}
// 比对原生的JDBC事务操作，前者是在TransactionStatus上进行事务操作，而后者是在Connection上进行事务操作:
Connection conn = openConnection();
try {
    // 关闭自动提交:
    conn.setAutoCommit(false);
    // 执行多条SQL语句:
    insert();
    update();
    delete();
    // 提交事务:
    conn.commit();
} catch (SQLException e) {
    // 回滚事务:
    conn.rollback();
} finally {
    conn.setAutoCommit(true);
    conn.close();
}
```

Spring为啥要抽象出`PlatformTransactionManager`和`TransactionStatus`。原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。

**Spring为了同时支持JDBC（JavaSE）和JTA（JavaEE）两种事务模型，就抽象出`PlatformTransactionManager`**。

**因为我们的代码只需要JDBC事务**，因此，在AppConfig中，需要再定义一个`PlatformTransactionManager`对应的Bean，它的实际类型是`DataSourceTransactionManager`：

```Java
@Configuration
@ComponentScan
@PropertySource("classpath:jdbc.properties")
public class AppConfig {
    ...
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个`@EnableTransactionManagement`就可以启用声明式事务：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement // 启用声明式
@PropertySource("classpath:jdbc.properties")
public class AppConfig {
    ...
}
```

然后，对需要事务支持的方法，加一个@Transactional注解：

```java
@Component
public class UserService {
    // 此public方法自动具有事务支持（要么执行所有JDBC操作，要么不执行任一JDBC操作）:
    @Transactional
    public User register(String email, String password, String name) {
       ...
    }
}
```

或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：

```java
@Component
@Transactional
public class UserService {
    ...
}
```

Spring对一个声明式事务的方法，如何开启事务支持？**原理仍然是AOP代理，即通过自动创建Bean的Proxy实现**：

```java
public class UserService$$EnhancerBySpringCGLIB extends UserService {
    // 原始实例:
    UserService target = ...
    // 切面（事务）实例:
    PlatformTransactionManager txManager = ...
    // 覆写原始实例的业务方法，并在调用原始业务方法的前后实现了类似手写事务管理的逻辑代码:
    @Override
    public User register(String email, String password, String name) {
        // 注意这里有一个TransactionStatus变量:
        TransactionStatus tx = null;
        try {
            // 开启事务(切面逻辑):
            tx = txManager.getTransaction(new DefaultTransactionDefinition());
            // 执行原始逻辑:
            target.register(email, password, name);
            // 提交事务(切面逻辑):
            txManager.commit(tx);
        } catch (RuntimeException e) {
            // 回滚事务(切面逻辑):
            txManager.rollback(tx);
            throw e;
        }
    }
    ...
}
```

注意：因为使用了AOP代理，因此打印从Spring容器获取的UserService的Class类型时，它类似`UserService$$EnhancerBySpringCGLIB$$3064804a`。

**注意：声明了@EnableTransactionManagement后，不必额外添加@EnableAspectJAutoProxy**。原因如上所述。

### 回滚事务

**默认情况下，如果发生了RuntimeException，Spring的声明式事务将自动回滚**。

在一个事务方法中，如果程序判断需要回滚事务，只需抛出RuntimeException，例如：

```Java
@Transactional
public buyProducts(long productId, int num) {
    ...
    if (store < num) {
        // 库存不够，购买失败:
        throw new IllegalArgumentException("No enough products");
    }
    ...
}
```

如果要针对Checked Exception回滚事务，需要在@Transactional注解中写出来：

```java
@Transactional(rollbackFor = {RuntimeException.class, IOException.class})
public buyProducts(long productId, int num) throws IOException {
    ...
}
```

上述代码表示在抛出RuntimeException或IOException时，事务将回滚。

**为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作**：

```java
public class BusinessException extends RuntimeException {
    ...
}

public class LoginException extends BusinessException {
    ...
}

public class PaymentException extends BusinessException {
    ...
}
```

### 事务边界

**在使用事务的时候，明确事务边界非常重要**。对于声明式事务，例如，下面的register()方法：

```Java
@Component
public class UserService {
    @Transactional
    public User register(String email, String password, String name) { // 事务开始
       ...
    } // 事务结束
}
```

它的事务边界就是register()方法开始和结束。

类似的，一个负责给用户增加积分的addBonus()方法：

```java
@Component
public class BonusService {
    @Transactional
    public void addBonus(long userId, int bonus) { // 事务开始
       ...
    } // 事务结束
}
```

它的事务边界就是addBonus()方法开始和结束。

在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：

```java
@Component
public class UserService {
    @Autowired
    BonusService bonusService;

    @Transactional
    public User register(String email, String password, String name) {
        // 插入用户记录:
        User user = jdbcTemplate.insert("...");
        // 增加100积分:
        bonusService.addBonus(user.id, 100);
    }
}
```

现在问题来了：调用方（比如RegisterController）调用UserService.register()这个事务方法，它在内部又调用了BonusService.addBonus()这个事务方法，一共有几个事务？如果addBonus()抛出了异常需要回滚事务，register()方法的事务是否也要回滚？

### 事务传播

要解决上面的问题，我们首先要定义事务的传播模型。

假设用户注册的入口是RegisterController，它本身没有事务，仅仅是调用UserService.register()这个事务方法：

```Java
@Controller
public class RegisterController {
    @Autowired
    UserService userService;

    @PostMapping("/register")
    public ModelAndView doRegister(HttpServletRequest req) {
        String email = req.getParameter("email");
        String password = req.getParameter("password");
        String name = req.getParameter("name");
        User user = userService.register(email, password, name);
        return ...
    }
}
```

因此，UserService.register()这个事务方法的起始和结束，就是事务的范围。

我们需要关心的问题是，在UserService.register()这个事务方法内，调用BonusService.addBonus()，我们期待的事务行为是什么：

```java
@Transactional
public User register(String email, String password, String name) {
    // 事务已开启:
    User user = jdbcTemplate.insert("...");
    // ???:
    bonusService.addBonus(user.id, 100);
} // 事务结束
```

对于大多数业务来说，**我们期待BonusService.addBonus()的调用，和UserService.register()应当融合在一起**，它的行为应该如下：

UserService.register()已经开启了一个事务，那么在内部调用BonusService.addBonus()时，BonusService.addBonus()方法就没必要再开启一个新事务，直接加入到UserService.register()的事务里就好了。

其实就相当于在**同一个事务**内：

  1. UserService.register()先执行了一条INSERT语句：INSERT INTO users ...
  2. BonusService.addBonus()再执行一条INSERT语句：INSERT INTO bonus ...

因此，Spring的声明式事务为事务传播定义了几个级别，**默认传播级别就是REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行**。

我们观察UserService.register()方法，它在RegisterController中执行，因为RegisterController没有事务，因此，UserService.register()方法会自动创建一个新事务。在UserService.register()方法内部，调用BonusService.addBonus()方法时，因为BonusService.addBonus()检测到当前已经有事务了，因此，它会加入到当前事务中执行。

因此，整个业务流程的事务**边界**就清晰了：它只有一个事务，并且**范围**就是UserService.register()方法。

有的童鞋会问：把BonusService.addBonus()方法的@Transactional去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？

去掉BonusService.addBonus()方法的@Transactional，会引来另一个问题，即其它地方如果单独调用BonusService.addBonus()方法，那就没法保证事务了。例如，规定用户登录时积分+5：

```java
@Controller
public class LoginController {
    @Autowired
    BonusService bonusService;

    @PostMapping("/login")
    public ModelAndView doLogin(HttpServletRequest req) {
        User user = ...
        bonusService.addBonus(user.id, 5);
    }
}
```

可见，BonusService.addBonus()方法必须要有@Transactional，否则，登录后积分就无法添加了。

默认的事务传播级别是`REQUIRED`，它满足绝大部分的需求。还有一些其它的传播级别：

- `SUPPORTS`：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；
- MANDATORY：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；
- `REQUIRES_NEW`：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；
- NOT_SUPPORTED：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；
- NEVER：和NOT_SUPPORTED相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；
- NESTED：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。

上面这么多种事务的传播级别，其实默认的REQUIRED已经满足绝大部分需求，SUPPORTS和REQUIRES_NEW在少数情况下会用到，其它基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。

定义事务的传播级别也是写在@Transactional注解里的：

```Java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public Product createProduct() {
    ...
}
```

**Spring是如何传播事务的（一个事务方法，如何获知当前是否存在事务）。Spring使用声明式事务，实际上最终也是通过执行JDBC事务来实现功能的**。

```Java
// 我们在JDBC中使用事务的时候，是这么个写法：
Connection conn = openConnection();
try {
    // 关闭自动提交:
    conn.setAutoCommit(false);
    // 执行多条SQL语句:
    insert(); update(); delete();
    // 提交事务:
    conn.commit();
} catch (SQLException e) {
    // 回滚事务:
    conn.rollback();
} finally {
    conn.setAutoCommit(true);
    conn.close();
}
```

**答案是使用ThreadLocal。Spring总是把JDBC相关的Connection（原生）和TransactionStatus（Spring）实例绑定到ThreadLocal。如果一个事务方法从ThreadLocal未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从ThreadLocal获取的JDBC连接以及TransactionStatus**。

这里开启新事务最快的方式就是打开一个新的connection，然后关闭自动提交，在该连接范围执行JDBC操作。

**因此，事务能正确传播的前提是，方法调用是在一个线程内才行**。如果像下面这样写：

```Java
@Transactional
public User register(String email, String password, String name) { // BEGIN TX-A
    User user = jdbcTemplate.insert("...");
    new Thread(() -> {
        // BEGIN TX-B:
        bonusService.addBonus(user.id, 100);
        // END TX-B
    }).start();
} // END TX-A
```

在另一个线程中调用BonusService.addBonus()，它根本获取不到当前事务（ThreadLocal为每个线程都开辟了独立的存储空间），因此，UserService.register()和BonusService.addBonus()两个方法，将分别开启两个完全独立的事务。

**换句话说，事务只能在当前线程传播，无法跨线程传播**。

那如果我们想实现跨线程传播事务呢。原理很简单，就是要想办法把当前线程绑定到ThreadLocal的Connection和TransactionStatus实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。

## 使用DAO

在菜鸟教程网站上，DAO模式被归类为设计模式当中的一种，[菜鸟教程](https://www.runoob.com/design-pattern/data-access-object-pattern.html)。

这一节你就简单地理解为告诉了你一种设计模式——DAO模式，你想按照DAO模式开发就开发，不想按照DAO模式开发也完全可以，不要绕进去。

个人理解：DAO模式可以理解为是一种设计模式，service层负责业务逻辑，dao层负责数据处理，这样的严格分离方式符合所谓的单一职责原则。

场景：针对每一个JavaBean，例如user类、goods类，我们为它们各自建立相应的XxxDao类**封装**它们各自的数据持久化操作。或者说数据库当中已有一个日期表，那我们应当先建立一个日期类，然后建立对应的dao类，其各种成员方法都是针对日期类的属性到日期表的持久化操作。这样后续编写业务层代码时，只需编写业务逻辑，具体的数据操作则通过调用数据访问层当中封装好的各式方法进行操作，自身不会出现任何有关对数据库操作的代码。

在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用JdbcTemplate实现对数据库的操作。

编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写。它没有什么神秘之处，实现起来基本如下：

```Java
public class UserDao {
    @Autowired
    JdbcTemplate jdbcTemplate;

    User getById(long id) {
        ...
    }

    List<User> getUsers(int page) {
        ...
    }

    User createUser(User user) {
        ...
    }

    User updateUser(User user) {
        ...
    }

    void deleteUser(User user) {
        ...
    }
}
```

Spring提供了一个JdbcDaoSupport类，用于简化DAO的实现。这个JdbcDaoSupport没什么复杂的，核心代码就是持有一个JdbcTemplate：

```java
public abstract class JdbcDaoSupport extends DaoSupport {

    private JdbcTemplate jdbcTemplate;

    public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        initTemplateConfig();
    }

    public final JdbcTemplate getJdbcTemplate() {
        return this.jdbcTemplate;
    }

    ...
}
```

**它的意图是子类直接从JdbcDaoSupport继承后，可以随时调用getJdbcTemplate()获得JdbcTemplate的实例**。那么问题来了：因为JdbcDaoSupport的jdbcTemplate字段没有标记@Autowired，所以，子类想要注入JdbcTemplate，还得自己想个办法：

```java
@Component
@Transactional
public class UserDao extends JdbcDaoSupport {

    @Autowired
    JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }
}
```

既然UserDao都已经注入了JdbcTemplate，那再把它放到父类里，通过getJdbcTemplate()访问岂不是多此一举？

如果使用传统的XML配置，并不需要编写`@Autowired JdbcTemplate jdbcTemplate`，但是考虑到现在基本上是使用注解的方式，我们可以编写一个AbstractDao，专门负责注入JdbcTemplate：

```java
public abstract class AbstractDao extends JdbcDaoSupport {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }
}
```

这样，**子类的代码就非常干净**，可以直接调用getJdbcTemplate()：

```java
@Component
@Transactional
public class UserDao extends AbstractDao {
    public User getById(long id) {
        return getJdbcTemplate().queryForObject(
                "SELECT * FROM users WHERE id = ?",
                new BeanPropertyRowMapper<>(User.class),
                id
        );
    }
    ...
}
```

倘若肯再多写一点样板代码，就可以把AbstractDao改成泛型，并实现getById()，getAll()，deleteById()这样的通用方法：

```java
public abstract class AbstractDao<T> extends JdbcDaoSupport {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    private String table;
    private Class<T> entityClass;
    private RowMapper<T> rowMapper;

    public AbstractDao() {
        // 获取当前类型的泛型类型:
        this.entityClass = this.getParameterizedType();
        // 根据泛型类型名称获取对应的表名，该变量用于下方的SQL语句拼接:
        this.table = this.entityClass.getSimpleName().toLowerCase() + "s";
        this.rowMapper = new BeanPropertyRowMapper<>(entityClass);
    }

    @PostConstruct
    public void init() {
        super.setJdbcTemplate(jdbcTemplate);
    }

    public T getById(long id) {
        return getJdbcTemplate().queryForObject("SELECT * FROM " + table + " WHERE id = ?", this.rowMapper, id);
    }

    public List<T> getAll(int pageIndex) {
        int limit = 100;
        int offset = limit * (pageIndex - 1);
        return getJdbcTemplate().query("SELECT * FROM " + table + " LIMIT ? OFFSET ?",
                new Object[] { limit, offset },
                this.rowMapper);
    }

    public void deleteById(long id) {
        getJdbcTemplate().update("DELETE FROM " + table + " WHERE id = ?", id);
    }

    private Class<T> getParameterizedType() {
        ...
    }
}
```

这样，每个子类就自动获得了这些通用方法：

```java
@Component
@Transactional
public class UserDao extends AbstractDao<User> {
    // 已经有了:
    // User getById(long)
    // List<User> getAll(int)
    // void deleteById(long)
    User fetchUserByEmail(String email) {
        ...
    }
    User getUserByEmail(String email) {
        ...
    }
    User login(String email, String password) {
        ...
    }
    User createUser(String email, String password, String name) {
        ...
    }
    void updateUser(User user) {
        ...
    }
}

@Component
@Transactional
public class BookDao extends AbstractDao<Book> {
    // 已经有了:
    // Book getById(long)
    // List<Book> getAll(int)
    // void deleteById(long)
}
```

**这样从AbstractDao延伸出来的子类就不用再一一注入JdbcTemplate，并且从抽象父类当中获取到了一些通用方法，子类代码非常干净明了**。

可见，DAO模式就是一个简单的数据访问模式，是否使用DAO模式，定义DAO层，根据实际情况决定，**因为很多时候，直接在Service层操作数据库也是完全没有问题的**。

直接在Service层操作数据库也是完全没有问题的，但也建议将业务逻辑和数据访问的代码分成独立的方法进行编写：

```java
// 数据访问:
public User fetchUserByEmail(String email) {
    User example = new User();
    example.setEmail(email);
    List<User> list = hibernateTemplate.findByExample(example);
    return list.isEmpty() ? null : list.get(0);
}
// 业务逻辑:
public User getUserByEmail(String email) {
    User user = fetchUserByEmail(email);
    if (user == null) {
        throw new RuntimeException("user not found by email: " + email);
    }
    return user;
}
```

## 集成Hibernate

[廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744/1266263275862720)，评论中有不错的相关资料参考。

> 有了Hibernate这个全自动ORM框架后，各种数据库持久化操作都是围绕JavaBean来进行，不再需要手动编写任何的SQL语句，即使要编写也是编写使用JavaBean的类名和属性名的HQL语句。

在Spring中集成Hibernate需要配置的Bean如下：

- DataSource；
- LocalSessionFactory；
- HibernateTransactionManager；
- HibernateTemplate（推荐）。

使用JdbcTemplate的时候，我们用得最多的方法就是`List<T> query(String sql, Object[] args, RowMapper rowMapper)`。并且通常将RowMapper唯一方法的逻辑实现为把ResultSet的一行记录映射为Java Bean。

这种把关系数据库的**表记录映射为Java对象**的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。

使用JdbcTemplate配合RowMapper可以看作是最原始的ORM：

```java
// 手动封装:
public User getUserByEmail(String email) {
    return this.jdbcTemplate.queryForObject("SELECT * FROM users WHERE email = ?", new Object[]{email}, (ResultSet rs, int rowNum) -> {
        return new User(rs.getLong("id"), rs.getString("email"), rs.getString("password"), rs.getString("name"));
    });
}
// 自动封装:
public List<User> getUsers(int pageIndex) {
    int limit = 100;
    int offset = limit * (pageIndex - 1);
    return this.jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?", new Object[]{limit, offset}, new BeanPropertyRowMapper<>(User.class));
}
```

如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如Hibernate。Hibernate作为ORM框架，它可以替代JdbcTemplate，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。

在AppConfig中，我们仍然需要创建DataSource、引入JDBC配置文件，以及启用声明式事务：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() {
        ...
    }
}
```

为了启用Hibernate，我们需要创建一个`LocalSessionFactoryBean`：

```java
public class AppConfig {
    @Bean
    LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) {
        Properties props = new Properties();
        // 表示自动创建数据库的表结构，注意不要在生产环境中启用:
        props.setProperty("hibernate.hbm2ddl.auto", "update");
        // 指示Hibernate使用的数据库是HSQLDB:
        // Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL:
        props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
        // props.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect");
        // 让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期:
        props.setProperty("hibernate.show_sql", "true");
        LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        // 指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean:
        sessionFactoryBean.setPackagesToScan("com.cat.entity");
        sessionFactoryBean.setHibernateProperties(props);
        return sessionFactoryBean;
    }
    // Spring为了便于我们使用Hibernate提供的工具类，不是非用不可，但推荐使用以简化代码:
    @Bean
    HibernateTemplate createHibernateTemplate(@Autowired SessionFactory sessionFactory) {
        return new HibernateTemplate(sessionFactory);
    }
    // 配合Hibernate使用声明式事务所必须的:
    @Bean
    PlatformTransactionManager createTxManager(@Autowired SessionFactory sessionFactory) {
        return new HibernateTransactionManager(sessionFactory);
    }
}
```

```java
public class LocalSessionFactoryBean
extends HibernateExceptionTranslator
implements FactoryBean<SessionFactory>, ResourceLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean
```

LocalSessionFactoryBean是一个`FactoryBean`，它在内部创建一个`SessionFactory`并用getObject()方法返回，在Hibernate中，`Session`是封装了一个JDBC Connection的实例，而SessionFactory是封装了JDBC DataSource的实例，即SessionFactory持有连接池，每次需要操作数据库的时候，SessionFactory创建一个新的Session，相当于从连接池获取到一个新的Connection。**SessionFactory就是Hibernate提供的最核心的一个对象，但LocalSessionFactoryBean是Spring提供的为了让我们方便创建SessionFactory的类**。

LocalSessionFactoryBean -> SessionFactory(DataSource) -> Session(Connection)。

考察如下的数据库表：

```SQL
# email带唯一索引以确保唯一性，createdAt存储整型类型的时间戳：
CREATE TABLE user
(
    id BIGINT NOT NULL AUTO_INCREMENT,
    email VARCHAR(100) NOT NULL,
    password VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    createdAt BIGINT NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `email` (`email`)
);
```

如果用JavaBean来表示一行记录：

```Java
public class User {
    private Long id;
    private String email;
    private String password;
    private String name;
    private Long createdAt;

    // getters and setters
    ...
}
```

这种映射关系十分易懂，但我们需要添加一些注解来告诉Hibernate如何把User类映射到表记录：

```java
// 如果一个JavaBean被用于映射，我们就标记一个@Entity:
// 默认情况下，映射的表名是user，如果实际的表名不同，例如实际表名是users，可以追加一个@Table(name="users")表示:
@Entity
public class User {
    // 对于主键，还需要用@Id标识，自增主键再追加一个@GeneratedValue，以便Hibernate能读取到自增主键的值:
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    // 每个属性到数据库列的映射用@Column()标识，nullable指示列是否允许为NULL，updatable指示该列是否允许被用在UPDATE语句:
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }
    // length指示String类型的列的长度（如果没有指定，默认是255）：
    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ... }

    @Column(nullable = false, length = 100)
    public String getPassword() { ... }

    @Column(nullable = false, length = 100)
    public String getName() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
}
```

**主键id定义的类型不是long，而是Long。这是因为Hibernate如果检测到主键为null，就不会在INSERT语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在INSERT语句中直接列出。long型字段总是具有默认值0，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败**。

createdAt虽然是整型，但我们并没有使用long，而是Long，这是因为使用基本类型会导致某种查询会添加意外的条件，后面我们会详细讨论，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。

**使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer**。

类似的，我们再定义一个Book类：

```Java
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }

    @Column(nullable = false, length = 100)
    public String getTitle() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
}
```

仔细观察User和Book，会发现它们定义的id、createdAt属性是一样的，这在数据库表结构的设计中很常见：对于每个表，**通常我们会统一使用一种主键生成机制，并添加createdAt表示创建时间，updatedAt表示修改时间等通用字段**。

不必在User和Book中重复定义这些通用字段，我们可以把它们提到一个抽象类中：

```Java
// 对于AbstractEntity来说，我们要标注一个@MappedSuperclass表示它用于继承:
@MappedSuperclass
public abstract class AbstractEntity {

    private Long id;
    private Long createdAt;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
    // 定义了一个@Transient方法，它返回一个“虚拟”的属性。因为getCreatedDateTime()是计算得出的属性，而不是从数据库表读出的值，因此必须要标注@Transient:
    // 否则Hibernate会尝试从数据库读取名为createdDateTime这个不存在的字段从而出错:
    @Transient
    public ZonedDateTime getCreatedDateTime() {
        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());
    }
    // @PrePersist标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句）:
    // Hibernate会先执行该方法，这样我们就可以自动设置好createdAt属性（不需要调用数据库函数也不需要传参给insert语句）:
    @PrePersist
    public void preInsert() {
        this.setCreatedAt(System.currentTimeMillis());
    }
}
```

有了AbstractEntity，我们就可以大幅简化User和Book：

```java
@Entity
public class User extends AbstractEntity {

    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ... }

    @Column(nullable = false, length = 100)
    public String getPassword() { ... }

    @Column(nullable = false, length = 100)
    public String getName() { ... }
}
```

注意到使用的所有注解均来自javax.persistence，它是[JPA规范](https://jakarta.ee/specifications/persistence/)的一部分。这里我们只介绍**使用注解的方式配置Hibernate映射关系**，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要hibernate.cfg.xml配置文件，用一句话总结：**使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置**。

类似User、Book这样的用于ORM的Java Bean，我们通常称之为Entity Bean。

我们来看看如果对user表进行增删改查。因为使用了Hibernate，因此，我们要做的，**实际上是对User这个JavaBean进行“增删改查”。我们用到了ORM技术，而ORM是将行记录映射为JavaBean，因此对JavaBean的操作就是在对行记录进行操作，通常情况下，我们将看不到任何SQL语句的身影，即不需要我们编写原生SQL语句**。

我们编写一个UserService，注入HibernateTemplate以便简化代码：

```java
@Component
@Transactional
public class UserService {
    @Autowired
    HibernateTemplate hibernateTemplate;
}
```

### Insert操作

要持久化一个User实例，我们只需调用save()方法。以register()方法为例，代码如下：

```java
public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);
    // 不需要设置id，因为使用了自增主键:
    // 保存到数据库:
    hibernateTemplate.save(user);
    // 现在已经自动获得了id:
    System.out.println(user.getId());
    return user;
}
```

### Delete操作

删除一个User相当于从表中删除对应的记录。注意Hibernate总是用id来删除记录，因此，要正确设置User的id属性才能正常删除记录：

```java
public boolean deleteUser(Long id) {
    // 先获取:
    User user = hibernateTemplate.get(User.class, id);
    if (user != null) {
        // 后删除:
        hibernateTemplate.delete(user);
        return true;
    }
    return false;
}
```

通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。load()和get()都可以根据主键加载记录，它们的区别在于，当记录不存在时，get()返回null，而load()抛出异常。

### Update操作

更新记录相当于先更新User的指定属性，然后调用update()方法：

```java
public void updateUser(Long id, String name) {
    // 先获取:
    User user = hibernateTemplate.load(User.class, id);
    // 再设置:
    user.setName(name);
    // 后更新:
    hibernateTemplate.update(user);
}
```

**前面我们在定义User时，对有的属性标注了@Column(updatable=false)。Hibernate在更新记录时，它只会把@Column(updatable=true)的属性加入到UPDATE语句中，这样可以提供一层额外的安全性，即如果不小心修改了User的id、createdAt等属性，执行update()时并不会更新对应的数据库列。但也必须牢记：这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行UPDATE语句仍然可以更新数据库的任意列的值**。

### 查询

最后，我们编写的大部分方法都是各种各样的查询。根据id查询我们可以直接调用load()或get()，如果要使用条件查询，有3种方法。

假设我们想执行以下查询：

```sql
SELECT * FROM user WHERE email = ? AND password = ?
```

### 使用Example查询

第一种方法是使用findByExample()，给出一个User实例，**Hibernate把该实例所有非null的属性拼成WHERE条件**：

```java
public User login(String email, String password) {
    // 实例化JavaBean，注意属性都是包装类，因此初始化都为null:
    User example = new User();
    example.setEmail(email);
    example.setPassword(password);
    List<User> list = hibernateTemplate.findByExample(example);
    return list.isEmpty() ? null : list.get(0);
}
```

因为example实例只有email和password两个属性为非null，所以最终生成的WHERE语句就是`WHERE email = ? AND password = ?`。

**如果我们把User的createdAt的类型从Long改为long，findByExample()的查询将出问题，原因在于example实例的long类型字段有了默认值0**，导致Hibernate最终生成的WHERE语句意外变成了`WHERE email = ? AND password = ? AND createdAt = 0`。显然，额外的查询条件将导致错误的查询结果。

**使用findByExample()时，注意基本类型字段总是会加入到WHERE条件**！

### 使用Criteria查询

> Note: Do not reuse criteria objects! They need to recreated per execution, due to the suboptimal design of Hibernate's criteria facility.

第二种查询方法是使用Criteria查询，可以实现如下：

```java
public User login(String email, String password) {
    // 实例化一个DetachedCriteria，需要JavaBean的Class对象:
    DetachedCriteria criteria = DetachedCriteria.forClass(User.class);
    // 为criteria添加限制条件，如果不添加任何限制条件则获取所有:
    criteria.add(Restrictions.eq("email", email))
            .add(Restrictions.eq("password", password));
    List<User> list = (List<User>) hibernateTemplate.findByCriteria(criteria);
    return list.isEmpty() ? null : list.get(0);
}
```

注意findByCriteria()方法可以提供额外的两个参数来限制返回的数据个数，通常用在分页查询当中。

DetachedCriteria使用add语句来添加多个AND条件。和findByExample()相比，findByCriteria()可以组装出更灵活的WHERE条件，例如：

```sql
SELECT * FROM user WHERE (email = ? OR name = ?) AND password = ?
```

上述查询没法用findByExample()实现，但用Criteria查询可以实现如下：

```java
DetachedCriteria criteria = DetachedCriteria.forClass(User.class);
criteria.add(
    Restrictions.and(
        Restrictions.or(
            Restrictions.eq("email", email),
            Restrictions.eq("name", email)
        ),
        Restrictions.eq("password", password)
    )
);
```

**只要组织好Restrictions的嵌套关系，Criteria查询可以实现任意复杂的查询**。

### 使用HQL查询

本小节当中的两种查询方法`find`和`findByNamedQuery`都已被弃用。

最后一种常用的查询是直接编写Hibernate内置的HQL查询：

```java
List<User> list = (List<User>) hibernateTemplate.find("FROM User WHERE email=? AND password=?", email, password);
List<User> list = (List<User>) hibernateTemplate.find("FROM User WHERE email=?0 AND password=?1", email, password);
```

```text
org.hibernate.QueryException: Legacy-style query parameters (`?`) are no longer supported; use JPA-style ordinal parameters (e.g., `?1`) instead : FROM com.cat.entity.User WHERE email=? AND password=? [FROM com.cat.entity.User WHERE email=? AND password=?]
```

和SQL相比，**HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名**。

除了可以直接传入HQL字符串外，Hibernate还可以使用一种NamedQuery，它**给查询起个名字**，然后保存在注解中。使用NamedQuery时，我们要先在User类标注：

```java
@NamedQueries(
    @NamedQuery(
        // 查询名称:
        name = "login",
        // 查询语句:
        query = "SELECT u FROM User u WHERE u.email=?0 AND u.password=?1"
    )
)
@Entity
public class User extends AbstractEntity {
    ...
}
```

注意到引入的NamedQuery是`javax.persistence.NamedQuery`，它和直接传入HQL有点不同的是，占位符使用?0、?1，并且索引是从0开始的。

使用NamedQuery只需要引入查询名和参数：

```java
public User login(String email, String password) {
    List<User> list = (List<User>) hibernateTemplate.findByNamedQuery("login", email, password);
    return list.isEmpty() ? null : list.get(0);
}
```

**直接写HQL和使用NamedQuery各有优劣。前者可以在代码中直观地看到查询语句，后者可以在User类统一管理所有相关查询**。

### 使用Hibernate原生接口

如果要使用Hibernate原生接口，但不知道怎么写，可以参考HibernateTemplate的源码。使用Hibernate的原生接口实际上总是从SessionFactory出发，它通常用全局变量存储，在HibernateTemplate中以成员变量被注入。有了SessionFactory，使用Hibernate用法如下：

```java
void operation() {
    Session session = null;
    boolean isNew = false;
    // 获取当前Session或者打开新的Session:
    try {
        session = this.sessionFactory.getCurrentSession();
    } catch (HibernateException e) {
        session = this.sessionFactory.openSession();
        isNew = true;
    }
    // 操作Session:
    try {
        User user = session.load(User.class, 123L);
    }
    finally {
        // 关闭新打开的Session:
        if (isNew) {
            session.close();
        }
    }
}
```

HibernateTemplate的load()方法源码，本质上就是使用session对象来完成JDBC操作：

```java
@Override
public <T> T load(final Class<T> entityClass, final Serializable id, @Nullable final LockMode lockMode)
        throws DataAccessException {

    return nonNull(executeWithNativeSession(session -> {
        if (lockMode != null) {
            return session.load(entityClass, id, new LockOptions(lockMode));
        }
        else {
            return session.load(entityClass, id);
        }
    }));
}
```

## 集成JPA

JPA是来自JavaEE定义的多种规范当中的一种，[JavaEE-JPA](https://jakarta.ee/specifications/persistence/)。

注意到在上述集成Hibernate章节当中，我们只是用到了JPA当中的**注解**用来配置Hibernate的映射关系，而其它相关的持久化操作**类**都是来自Hibernate包（因为Hibernate本身就是最底层，因此这些操作都有着具体实现）。

```java
package org.springframework.orm.hibernate5;

public class HibernateTemplate implements HibernateOperations, InitializingBean {
    ...
    @Deprecated
    @Override
    @SuppressWarnings({"rawtypes", "unchecked", "deprecation"})
    public List<?> find(final String queryString, @Nullable final Object... values) throws DataAccessException {
        return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {
            org.hibernate.Query queryObject = queryObject(
                    ReflectionUtils.invokeMethod(createQueryMethod, session, queryString));
            prepareQuery(queryObject);
            if (values != null) {
                for (int i = 0; i < values.length; i++) {
                    queryObject.setParameter(i, values[i]);
                }
            }
            return queryObject.list();
        }));
    }
    ...
}
```

而在本章节当中，所有有关数据库访问的操作都来自JPA当中的各种**接口**对象，但是底层仍由Hibernate来进行实现。

```java
package javax.persistence;

public interface EntityManager {
    ...
    public <T> T find(Class<T> entityClass, Object primaryKey);
    ...
}
```

在讨论JPA之前，我们要注意到JavaEE早在1999年就发布了，并且有Servlet、JMS等诸多标准。和其他平台不同，Java世界早期非常热衷于标准先行，各家跟进：**大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想JDBC）**。

JPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，**那么引用的就是javax.persistence这个“标准”包，而不是org.hibernate这样的第三方包**。**因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理**。

我们使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如EclipseLink。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。这里我们仍然以主流的Hibernate作为JPA实现为例子，演示JPA的基本用法。

在AppConfig中启用声明式事务管理，创建DataSource：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() { ... }
}
```

使用Hibernate时，我们需要创建一个LocalSessionFactoryBean，并让它再自动创建一个SessionFactory。使用JPA也是类似的，我们需要创建一个LocalContainerEntityManagerFactoryBean，并让它再自动创建一个EntityManagerFactory：

```java
@Bean
LocalContainerEntityManagerFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) {
    var entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
    // 设置DataSource:
    entityManagerFactoryBean.setDataSource(dataSource);
    // 扫描指定的package获取所有entity class:
    entityManagerFactoryBean.setPackagesToScan("com.itranswarp.learnjava.entity");
    // 指定JPA的提供商是Hibernate，即JPA接口的具体实现类由谁来提供:
    JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    entityManagerFactoryBean.setJpaVendorAdapter(vendorAdapter);
    // 设定特定提供商自己的配置:
    var props = new Properties();
    props.setProperty("hibernate.hbm2ddl.auto", "update");
    props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
    props.setProperty("hibernate.show_sql", "true");
    entityManagerFactoryBean.setJpaProperties(props);
    return entityManagerFactoryBean;
}
```

观察上述代码，除了需要注入DataSource和设定自动扫描的package外，还需要指定JPA的提供商，这里使用Spring提供的一个HibernateJpaVendorAdapter，最后，针对Hibernate自己需要的配置，以Properties的形式注入。

最后，我们还需要实例化一个JpaTransactionManager，以实现声明式事务：

```java
@Bean
PlatformTransactionManager createTxManager(@Autowired EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
}
```

这样，我们就完成了JPA的全部初始化工作。使用Spring+Hibernate作为JPA实现，无需任何配置文件。

所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。我们现在只需关心具体的业务类如何通过JPA接口操作数据库。

还是以UserService为例，除了标注@Component和@Transactional外，我们需要注入一个EntityManager，但是不要使用Autowired，而是@PersistenceContext：

```java
@Component
@Transactional
public class UserService {
    @PersistenceContext
    EntityManager em;
}
```

我们回顾一下JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：

- JDBC: DataSource -> Connection
- Hibernate: SessionFactory -> Session
- JPA: EntityManagerFactory -> EntityManager

SessionFactory和EntityManagerFactory相当于DataSource，Session和EntityManager相当于Connection。每次需要访问数据库的时候，需要获取新的Session和EntityManager，用完后再关闭。

但是，注意到UserService注入的不是EntityManagerFactory，而是EntityManager，并且标注了@PersistenceContext。难道使用JPA可以允许多线程操作同一个EntityManager？

实际上这里注入的并不是真正的EntityManager，而是一个EntityManager的代理类，相当于：

```java
public class EntityManagerProxy implements EntityManager {
    private EntityManagerFactory emf;
}
```

Spring遇到标注了@PersistenceContext的EntityManager会自动注入代理，该代理会在必要的时候自动打开EntityManager。**换句话说，多线程引用的EntityManager虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的EntityManager实例**。

简单总结一下，标注了@PersistenceContext的EntityManager可以被多线程安全地共享。

因此，在UserService的每个业务方法里，直接使用EntityManager就很方便。以主键查询为例：

```java
public User getUserById(long id) {
    User user = this.em.find(User.class, id);
    if (user == null) {
        throw new RuntimeException("User not found by id: " + id);
    }
    return user;
}
```

JPA同样支持Criteria查询，比如我们需要的查询如下：

```sql
SELECT * FROM user WHERE email = ?
```

使用Criteria查询的代码如下：

```java
public User fetchUserByEmail(String email) {
    // CriteriaBuilder:
    var cb = em.getCriteriaBuilder();
    CriteriaQuery<User> q = cb.createQuery(User.class);
    Root<User> r = q.from(User.class);
    q.where(cb.equal(r.get("email"), cb.parameter(String.class, "e")));
    TypedQuery<User> query = em.createQuery(q);
    // 绑定参数:
    query.setParameter("e", email);
    // 执行查询:
    List<User> list = query.getResultList();
    return list.isEmpty() ? null : list.get(0);
}
```

一个简单的查询用Criteria写出来就像上面那样复杂，太恐怖了，如果条件多加几个，这种写法谁读得懂？

所以，正常人还是建议写JPQL查询，它的语法和HQL基本差不多：

```java
public User getUserByEmail(String email) {
    // JPQL查询:
    TypedQuery<User> query = em.createQuery("SELECT u FROM User u WHERE u.email = :e", User.class);
    query.setParameter("e", email);
    List<User> list = query.getResultList();
    if (list.isEmpty()) {
        throw new RuntimeException("User not found by email.");
    }
    return list.get(0);
}
```

获取到的TypedQuery对象可以通过调用setFirstResult()和setMaxResults()方法实现类似分页查询的效果。

同样的，JPA也支持NamedQuery，即先给查询起个名字，再按名字创建查询：

```java
public User login(String email, String password) {
    TypedQuery<User> query = em.createNamedQuery("login", User.class);
    query.setParameter("e", email);
    query.setParameter("p", password);
    List<User> list = query.getResultList();
    return list.isEmpty() ? null : list.get(0);
}
```

NamedQuery通过注解标注在User类上，它的定义和上一节的User类一样：

```java
@NamedQueries(
    @NamedQuery(
        name = "login",
        query = "SELECT u FROM User u WHERE u.email=:e AND u.password=:p"
    )
)
@Entity
public class User {
    ...
}
```

对数据库进行增删改的操作，可以分别使用persist()、remove()和merge()方法，参数均为Entity Bean本身，使用非常简单。

## 集成MyBatis

> MyBatis是一个半自动化的ORM框架，需要手写SQL语句，没有自动加载一对多或多对一关系的功能。

使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。

**而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射**。

那么，ORM框架是如何跟踪Java Bean的修改，以便在update()操作中更新**必要**的属性？

答案是使用Proxy模式，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：

```java
public class UserProxy extends User {
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }
}
```

这样，代理类可以跟踪到每个属性的变化。

针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：

```java
public class UserProxy extends User {
    Session _session;
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }

    /**
     * 获取User对象关联的Address对象:
     */
    public Address getAddress() {
        Query q = _session.createQuery("from Address where userId = :userId");
        q.setParameter("userId", this.getId());
        List<Address> list = query.list();
        return list.isEmpty() ? null : list(0);
    }
}
```

**为了实现这样的查询，UserProxy必须保存Hibernate的当前Session。但是，当事务提交后，Session自动关闭，此时再获取getAddress()将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached/Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的PersistentObjectException异常。这种隐式状态使得普通Java Bean的生命周期变得复杂**。

此外，Hibernate和JPA为了实现兼容多种数据库，它使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，**但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦**。

最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：

```java
User user1 = session.load(User.class, 123);
User user2 = session.load(User.class, 123);
```

二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：

```java
// 线程1读取:
User user1 = session1.load(User.class, 123);
...
// 一段时间后，线程2读取:
User user2 = session2.load(User.class, 123);
```

**当二级缓存生效的时候，跨线程读取的User实例是一样的，但是，数据库对应的行记录完全可能被修改**，例如：

```sql
-- 给老用户增加100积分:
UPDATE users SET bonus = bonus + 100 WHERE createdAt <= ?
```

**ORM无法判断id=123的用户是否受该UPDATE语句影响**。考虑到数据库通常会支持多个应用程序，此UPDATE语句可能由其他进程执行，ORM框架就更不知道了。

我们把这种ORM框架称之为全自动ORM框架。

对比Spring提供的JdbcTemplate，它和ORM框架相比，主要有几点差别：

  1. 查询后需要手动提供Mapper实例以便把ResultSet的每一行变为Java对象；
  2. 增删改操作所需的参数列表，需要手动传入，即把User实例变为[user.id, user.name, user.email]这样的列表，比较麻烦。

但是JdbcTemplate的优势在于它的确定性：**即每次读取操作一定是数据库操作而不是缓存，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造INSERT INTO users VALUES (?,?,?)更是复杂**。

所以，介于**全自动ORM如Hibernate**和**手写全部如JdbcTemplate**之间，还有一种**半自动的ORM，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL**。MyBatis就是这样一种半自动化ORM框架。

首先，我们要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，我们需要再引入MyBatis官方自己开发的一个与Spring集成的库：

和前面一样，先创建DataSource是必不可少的：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() { ... }
}
```

再回顾一下Hibernate和JPA的SessionFactory与EntityManagerFactory，MyBatis与之对应的是SqlSessionFactory（DataSource）和SqlSession（Connection）。

可见，ORM的设计套路都是类似的。使用MyBatis的核心就是创建SqlSessionFactory，这里我们需要创建的是SqlSessionFactoryBean：

```java
@Bean
SqlSessionFactoryBean createSqlSessionFactoryBean(@Autowired DataSource dataSource) {
    var sqlSessionFactoryBean = new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
```

因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：

```java
@Bean
PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
```

和Hibernate不同的是，**MyBatis使用Mapper来实现映射，而且Mapper必须是接口**。我们以User类为例，在User类和users表之间映射的UserMapper编写如下：

```java
public interface UserMapper {
    @Select("SELECT * FROM users WHERE id = #{id}")
    User getById(@Param("id") long id);
}
```

**注意：这里的Mapper不是JdbcTemplate的RowMapper的概念，它是定义访问users表的接口方法。比如我们定义了一个User getById(long)的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解@Select标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数id的名字通过注解@Param()标记为id，则SQL语句里将来替换的占位符就是#{id}**。

如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：

```java
@Select("SELECT * FROM users LIMIT #{offset}, #{maxResults}")
List<User> getAll(@Param("offset") int offset, @Param("maxResults") int maxResults);
```

**注意：MyBatis执行查询后，将根据方法的返回类型自动把ResultSet的每一行转换为User实例，转换规则当然是按列名和属性名对应**。如果列名和属性名不同，最简单的方式是编写SELECT语句的别名：

```sql
-- 列名是created_time，属性名是createdAt:
SELECT id, name, email, created_time AS createdAt FROM users
```

执行INSERT语句就稍微麻烦点，因为我们希望传入User实例，因此，定义的方法接口与@Insert注解如下：

```java
@Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
void insert(@Param("user") User user);
```

上述方法传入的参数名称是user，参数类型是User类，在SQL中引用的时候，以#{obj.property}的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。

如果users表的id是自增主键，那么，我们在SQL中不传入id，但希望获取插入后的主键，需要再加一个@Options注解：

```java
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
@Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
void insert(@Param("user") User user);
```

keyProperty和keyColumn分别指出JavaBean的属性和数据库的主键列名。

执行UPDATE和DELETE语句相对比较简单，我们定义方法如下：

```java
@Update("UPDATE users SET name = #{user.name}, createdAt = #{user.createdAt} WHERE id = #{user.id}")
void update(@Param("user") User user);

@Delete("DELETE FROM users WHERE id = #{id}")
void deleteById(@Param("id") long id);
```

有了UserMapper接口，还需要对应的实现类才能真正执行这些数据库操作的方法（真正执行数据库操作的语句，比如先获取注解中的SQL语句，然后调用原生JDBC进行实现）。虽然可以自己写实现类，但我们除了编写UserMapper接口外，还有BookMapper、BonusMapper……一个一个写太麻烦，因此，MyBatis提供了一个MapperFactoryBean来自动创建所有Mapper的实现类。可以用一个简单的注解来启用它：

```java
@MapperScan("com.itranswarp.learnjava.mapper")
...其他注解...
public class AppConfig {
    ...
}
```

有了@MapperScan，就可以让MyBatis自动扫描指定包的所有Mapper并创建实现类。在真正的业务逻辑中，我们可以直接注入：

```java
@Component
@Transactional
public class UserService {
    // 注入UserMapper:
    @Autowired
    UserMapper userMapper;

    public User getUserById(long id) {
        // 调用Mapper方法:
        User user = userMapper.getById(id);
        if (user == null) {
            throw new RuntimeException("User not found by id.");
        }
        return user;
    }
}
```

可见，业务逻辑主要就是通过XxxMapper定义的数据库方法来访问数据库。

### XML配置

上述在Spring中集成MyBatis的方式，我们只需要用到注解，并没有任何XML配置文件。MyBatis也允许使用XML配置映射关系和SQL语句，例如，更新User时根据属性值构造动态SQL：

```xml
<update id="updateUser">
  UPDATE users SET
  <set>
    <if test="user.name != null"> name = #{user.name} </if>
    <if test="user.hobby != null"> hobby = #{user.hobby} </if>
    <if test="user.summary != null"> summary = #{user.summary} </if>
  </set>
  WHERE id = #{user.id}
</update>
```

编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中。这里我们不介绍XML的配置方式，需要了解的童鞋请自行阅读官方文档。

**使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易**。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。

## 设计ORM

> ORM框架就是自动映射数据库表结构到JavaBean的工具，设计并实现一个简单高效的ORM框架并不困难。

我们从前几节可以看到，所谓ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。

而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种ORM解决方案各不相同，Hibernate和JPA自己实现了HQL和JPQL查询语法，用以生成最终的SQL，而MyBatis则完全手写，每增加一个查询都需要先编写SQL并增加接口方法。

还有一种Hibernate和JPA支持的Criteria查询，用Hibernate写出来类似：

```java
DetachedCriteria criteria = DetachedCriteria.forClass(User.class);
criteria.add(Restrictions.eq("email", email))
        .add(Restrictions.eq("password", password));
List<User> list = (List<User>) hibernateTemplate.findByCriteria(criteria);
```

上述Criteria查询写法复杂，但和JPA相比，还是小巫见大巫了：

```java
var cb = em.getCriteriaBuilder();
CriteriaQuery<User> q = cb.createQuery(User.class);
Root<User> r = q.from(User.class);
q.where(cb.equal(r.get("email"), cb.parameter(String.class, "e")));
TypedQuery<User> query = em.createQuery(q);
query.setParameter("e", email);
List<User> list = query.getResultList();
```

此外，是否支持自动读取一对多和多对一关系也是全自动化ORM框架的一个重要功能。

如果我们自己来设计并实现一个ORM，应该吸取这些ORM的哪些特色，然后高效实现呢？

### 设计ORM接口

任何设计，都必须明确设计目标。这里我们准备实现的ORM并不想要全自动ORM那种自动读取一对多和多对一关系的功能，也不想给Entity加上复杂的状态，因此，对于Entity来说，它就是纯粹的JavaBean，没有任何Proxy。

此外，ORM要兼顾易用性和适用性。易用性是指能覆盖95%的应用场景，但总有一些复杂的SQL，很难用ORM去自动生成，因此，也要给出原生的JDBC接口，能支持5%的特殊需求。

最后，我们希望设计的接口要易于编写，并使用流式API便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。

以User类为例，我们设计的查询接口如下：

```java
// 按主键查询: SELECT * FROM users WHERE id = ?
User u = db.get(User.class, 123);

// 条件查询唯一记录: SELECT * FROM users WHERE email = ? AND password = ?
User u = db.from(User.class)
           .where("email=? AND password=?", "bob@example.com", "bob123")
           .unique();

// 条件查询多条记录: SELECT * FROM users WHERE id < ? ORDER BY email LIMIT ?, ?
List<User> us = db.from(User.class)
                  .where("id < ?", 1000)
                  .orderBy("email")
                  .limit(0, 10)
                  .list();

// 查询特定列: SELECT id, name FROM users WHERE email = ?
User u = db.select("id", "name")
           .from(User.class)
           .where("email = ?", "bob@example.com")
           .unique();
```

这样的流式API便于阅读，也非常容易推导出最终生成的SQL。

对于插入、更新和删除操作，就相对比较简单：

```java
// 插入User:
db.insert(user);

// 按主键更新更新User:
db.update(user);

// 按主键删除User:
db.delete(User.class, 123);
```

对于Entity来说，通常一个表对应一个。手动列出所有Entity是非常麻烦的，一定要传入package自动扫描。

最后，ORM总是需要元数据才能知道如何映射。我们不想编写复杂的XML配置，也没必要自己去定义一套规则，直接使用JPA的注解就行。

### 实现ORM

我们并不需要从JDBC底层开始编写，并且，还要考虑到事务，最好能直接使用Spring的声明式事务。实际上，我们可以设计一个全局DbTemplate，它注入了Spring的JdbcTemplate，涉及到数据库操作时，全部通过JdbcTemplate完成，自然天生支持Spring的声明式事务，因为这个ORM只是在JdbcTemplate的基础上做了一层封装。

在AppConfig中，我们初始化所有Bean如下：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
@PropertySource("jdbc.properties")
public class AppConfig {
    @Bean
    DataSource createDataSource() { ... }

    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    @Bean
    DbTemplate createDbTemplate(@Autowired JdbcTemplate jdbcTemplate) {
        return new DbTemplate(jdbcTemplate, "com.itranswarp.learnjava.entity");
    }

    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

以上就是我们所需的所有配置。

编写业务逻辑，例如UserService，写出来像这样：

```java
@Component
@Transactional
public class UserService {
    @Autowired
    DbTemplate db;

    public User getUserById(long id) {
        return db.get(User.class, id);
    }

    public User getUserByEmail(String email) {
        return db.from(User.class)
                 .where("email = ?", email)
                 .unique();
    }

    public List<User> getUsers(int pageIndex) {
        int pageSize = 100;
        return db.from(User.class)
                 .orderBy("id")
                 .limit((pageIndex - 1) * pageSize, pageSize)
                 .list();
    }

    public User register(String email, String password, String name) {
        User user = new User();
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);
        user.setCreatedAt(System.currentTimeMillis());
        db.insert(user);
        return user;
    }
    ...
}
```

上述代码给出了ORM的接口，以及如何在业务逻辑中使用ORM。下一步，就是如何实现这个DbTemplate。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：

```java
public class DbTemplate {
    private JdbcTemplate jdbcTemplate;

    // 保存Entity Class到Mapper的映射:
    private Map<Class<?>, Mapper<?>> classMapping;

    public <T> T fetch(Class<T> clazz, Object id) {
        Mapper<T> mapper = getMapper(clazz);
        List<T> list = (List<T>) jdbcTemplate.query(mapper.selectSQL, new Object[] { id }, mapper.rowMapper);
        if (list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }

    public <T> T get(Class<T> clazz, Object id) {
        ...
    }

    public <T> void insert(T bean) {
        ...
    }

    public <T> void update(T bean) {
        ...
    }

    public <T> void delete(Class<T> clazz, Object id) {
        ...
    }
}
```

实现链式API的核心代码是第一步从DbTemplate调用select()或from()时实例化一个CriteriaQuery实例，并在后续的链式调用中设置它的字段：

```java
public class DbTemplate {
    ...
    public Select select(String... selectFields) {
        return new Select(new Criteria(this), selectFields);
    }

    public <T> From<T> from(Class<T> entityClass) {
        Mapper<T> mapper = getMapper(entityClass);
        return new From<>(new Criteria<>(this), mapper);
    }
}
```

然后以此定义Select、From、Where、OrderBy、Limit等。在From中可以设置Class类型、表名等：

```java
public final class From<T> extends CriteriaQuery<T> {
    From(Criteria<T> criteria, Mapper<T> mapper) {
        super(criteria);
        // from可以设置class、tableName:
        this.criteria.mapper = mapper;
        this.criteria.clazz = mapper.entityClass;
        this.criteria.table = mapper.tableName;
    }

    public Where<T> where(String clause, Object... args) {
        return new Where<>(this.criteria, clause, args);
    }
}
```

在Where中可以设置条件参数：

```java
public final class Where<T> extends CriteriaQuery<T> {
    Where(Criteria<T> criteria, String clause, Object... params) {
        super(criteria);
        this.criteria.where = clause;
        this.criteria.whereParams = new ArrayList<>();
        // add:
        for (Object param : params) {
            this.criteria.whereParams.add(param);
        }
    }
}
```

最后，链式调用的尽头是调用list()返回一组结果，调用unique()返回唯一结果，调用first()返回首个结果。

需要复杂查询的时候，总是可以使用JdbcTemplate执行任意复杂的SQL。

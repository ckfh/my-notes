# 集成第三方组件

## 集成JavaMail

在Spring中，发送邮件最终也是需要JavaMail，Spring只对JavaMail做了一点简单的封装，目的是简化代码。

我们希望用户在注册成功后能收到注册邮件，为此，我们先定义一个JavaMailSender的Bean；

```Java
@Bean
JavaMailSender createJavaMailSender(
        // smtp.properties:
        @Value("${smtp.host}") String host,
        @Value("${smtp.port}") int port,
        @Value("${smtp.auth}") String auth,
        @Value("${smtp.username}") String username,
        @Value("${smtp.password}") String password,
        @Value("${smtp.debug:true}") String debug)
{
    var mailSender = new JavaMailSenderImpl();
    mailSender.setHost(host);
    mailSender.setPort(port);
    mailSender.setUsername(username);
    mailSender.setPassword(password);
    Properties props = mailSender.getJavaMailProperties();
    props.put("mail.transport.protocol", "smtp");
    props.put("mail.smtp.auth", auth);
    if (port == 587) {
        props.put("mail.smtp.starttls.enable", "true");
    }
    if (port == 465) {
        props.put("mail.smtp.socketFactory.port", "465");
        props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
    }
    props.put("mail.debug", debug);
    return mailSender;
}
```

下一步是封装一个MailService，并定义sendRegistrationMail()方法；

```Java
@Component
public class MailService {
    @Value("${smtp.from}")
    String from;
    @Autowired
    JavaMailSender mailSender;

    public void sendRegistrationMail(User user) {
        try {
            // MimeMessage是JavaMail的邮件对象：
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            // MimeMessageHelper是Spring提供的用于简化设置MimeMessage的类:
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, "utf-8");
            helper.setFrom(from);
            helper.setTo(user.getEmail());
            helper.setSubject("Welcome to Java course!");
            String html = String.format("<p>Hi, %s,</p><p>Welcome to Java course!</p><p>Sent at %s</p>", user.getName(), LocalDateTime.now());
            // 设置HTML邮件就可以直接调用setText(String text, boolean html)方法，而不必再调用比较繁琐的JavaMail接口方法：
            helper.setText(html, true);
            // 调用JavaMailSender.send()方法把邮件发送出去：
            mailSender.send(mimeMessage);
        } catch (MessagingException e) {
            throw new RuntimeException(e);
        }
    }
}
```

在MVC的某个Controller方法中，当用户注册成功后，我们就启动一个新线程来异步发送邮件：

```Java
@PostMapping("/register")
public ModelAndView doRegister(@RequestParam("email") String email, @RequestParam("password") String password, @RequestParam("name") String name) {
    try {
        User user = userService.register(email, password, name);
        logger.info("user registered: {}", user.getEmail());
        // send registration mail:
        new Thread(() -> {
            mailService.sendRegistrationMail(user);
        }).start();
    } catch (RuntimeException e) {
        return new ModelAndView("register.html", Map.of("email", email, "error", "Register failed"));
    }
    return new ModelAndView("redirect:/signin");
}
```

**因为发送邮件是一种耗时的任务，从几秒到几分钟不等，因此，异步发送是保证页面能快速显示的必要措施。这里我们直接启动了一个新的线程**。但实际上还有更优化的方法，可以使用下一节中的消息服务。

Spring可以集成JavaMail，通过简单的封装，能简化邮件发送代码。**其核心是定义一个JavaMailSender的Bean，然后调用其send()方法**。

## 集成JMS

JMS即Java Message Service，是JavaEE的消息服务接口。

所谓消息服务，就是两个进程之间，通过消息服务器传递消息。

使用消息服务，而不是直接调用对方的API，它的好处是：

- 双方各自无需知晓对方的存在，消息可以异步处理，因为消息服务器会在Consumer离线的时候自动缓存消息；
- 如果Producer发送的消息频率高于Consumer的处理能力，消息可以积压在消息服务器，不至于压垮Consumer；
- 通过一个消息服务器，可以连接多个Producer和多个Consumer。

因为消息服务在各类应用程序中非常有用，所以JavaEE专门定义了JMS规范。**注意到JMS是一组接口定义，如果我们要使用JMS，还需要选择一个具体的JMS产品**。

在编写JMS代码之前，我们首先得理解JMS的消息模型。JMS把生产消息的一方称为Producer，处理消息的一方称为Consumer。有两种类型的消息通道，一种是Queue，一种是Topic。

- Queue是一种*一对一*的通道，如果Consumer离线无法处理消息时，Queue会把消息存起来，等Consumer再次连接的时候发给它。*设定了持久化机制*的Queue不会丢失消息。如果有多个Consumer接入同一个Queue，那么它们等效于*以集群方式处理消息*，例如，发送方发送的消息是A，B，C，D，E，F，两个Consumer可能分别收到A，C，E和B，D，F，即*每个消息只会交给其中一个Consumer*处理。

- Topic则是一种*一对多*通道。一个Producer发出的消息，会被多个Consumer同时收到，即*每个Consumer都会收到一份完整的消息流*。如果消息服务器不存储Topic消息，那么离线的Consumer会丢失部分离线时期的消息，如果消息服务器存储了Topic消息，那么离线的Consumer可以收到自上次离线时刻开始后产生的所有消息。JMS规范通过*Consumer指定一个持久化订阅*可以在上线后收取所有离线期间的消息，如果指定的是非持久化订阅，那么离线期间的消息会全部丢失。

因此，如果一个Topic的消息全部都持久化了，并且只有一个Consumer，那么它和Queue其实是一样的。实际上，很多消息服务器内部都只有Topic类型的消息架构，Queue可以通过Topic“模拟”出来。

无论是Queue还是Topic，对Producer没有什么要求。多个Producer也可以写入同一个Queue或者Topic，此时消息服务器内部会自动排序确保消息总是有序的。

具体到某个消息服务器时，Producer和Consumer通常是通过TCP连接消息服务器（**注意TCP连接所使用的端口，在服务器启动消息中会有指出**）。

- 在AppConfig中，通过@EnableJms让Spring自动扫描JMS相关的Bean，并加载JMS配置文件jms.properties;
- 首先要创建的Bean是ConnectionFactory，即连接消息服务器的连接池：

```Java
    @Bean
    ConnectionFactory createJMSConnectionFactory(@Value("${jms.uri:tcp://localhost:61616}") String uri,
                                                 @Value("${jms.username:admin}") String username,
                                                 @Value("${jms.password:password}") String password) {
        return new ActiveMQJMSConnectionFactory(uri, username, password);
    }
```

- 再创建一个JmsTemplate，它是Spring提供的一个工具类，和JdbcTemplate类似，可以简化发送消息的代码：

```Java
    @Bean
    JmsTemplate createJmsTemplate(@Autowired ConnectionFactory connectionFactory) {
        return new JmsTemplate(connectionFactory);
    }
```

- 下一步要创建的是JmsListenerContainerFactory：

```Java
    @Bean("jmsListenerContainerFactory")
    // 必须指定Bean的名称为jmsListenerContainerFactory，不要使用默认的名称，这个Bean主要用于处理和Consumer相关的Bean：
    DefaultJmsListenerContainerFactory createJmsListenerContainerFactory(@Autowired ConnectionFactory connectionFactory) {
        var factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        return factory;
    }
```

- 编写MessagingService来发送消息：

```Java
public class MailMessage {
    public static enum Type {
        REGISTRATION, SIGNIN;
    }

    public Type type;
    public String email;
    public String name;
    public long timestamp;

    public static MailMessage registration(String email, String name) {
        var msg = new MailMessage();
        msg.email = email;
        msg.name = name;
        msg.type = Type.REGISTRATION;
        msg.timestamp = System.currentTimeMillis();
        return msg;
    }
}

@Component
public class MessagingService {
    @Autowired
    ObjectMapper objectMapper;
    @Autowired
    JmsTemplate jmsTemplate;

    public void sendMailMessage(MailMessage msg) throws Exception {
        // 最常用的是发送基于JSON的文本消息，通过JmsTemplate创建一个TextMessage并发送到名称为jms/queue/mail的Queue：
        // MailMessage是我们自己定义的一个JavaBean，真正的JMS消息是创建的TextMessage，它的内容是JSON格式的字符串：
        // {"type":"REGISTRATION","email":"tom@example.com","name":"tom","timestamp":1596596181834}
        String text = objectMapper.writeValueAsString(msg);
        jmsTemplate.send("jms/queue/mail", new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage(text);
            }
        });
    }
}
```

注意：Artemis消息服务器默认配置下会自动创建Queue，因此不必手动创建一个名为jms/queue/mail的Queue，但不是所有的消息服务器都会自动创建Queue，**生产环境的消息服务器通常会关闭自动创建功能，需要手动创建Queue**。

- 当用户注册成功后，我们就调用MessagingService.sendMailMessage()发送一条JMS消息：

```Java
    @PostMapping("/register")
    public ModelAndView doRegister(@RequestParam("email") String email, @RequestParam("password") String password,
                                   @RequestParam("name") String name) throws Exception {
        try {
            User user = userService.register(email, password, name);
            logger.info("user registered: {}", user.getEmail());
            // 调用MessagingService.sendMailMessage()发送一条JMS消息：
            messagingService.sendMailMessage(MailMessage.registration(user.getEmail(), user.getName()));
        } catch (RuntimeException e) {
            logger.warn(e.getMessage(), e);
            return new ModelAndView("register.html", Map.of("email", email, "error", "Register failed"));
        }
        return new ModelAndView("redirect:/signin");
    }
```

从理论上讲，可以创建另一个Java**进程**来处理消息，但对于我们这个简单的Web程序来说没有必要，直接在同一个Web应用中接收并处理消息即可。

- 处理消息的核心代码是编写一个Bean，并在处理方法上标注@JmsListener：

```Java
@Component
public class MailService {
    final Logger logger = LoggerFactory.getLogger(getClass());

    public void sendRegistrationMail(MailMessage mm) {
        logger.info("[send mail] sending registration mail to {}...", mm.email);
        // TODO: simulate a long-time task:
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
        }
        logger.info("[send mail] registration mail was sent to {}.", mm.email);
    }
}

@Component
public class MailMessageListener {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    @Autowired
    ObjectMapper objectMapper;
    @Autowired
    MailService mailService;
    // 注意到@JmsListener指定了Queue的名称，因此，凡是发到此Queue的消息都会被这个onMailMessageReceived()方法处理：
    // 10表示可以最多同时并发处理10个消息，5-10表示并发处理的线程可以在5到10之间调整：
    @JmsListener(destination = "jms/queue/mail", concurrency = "10")
    public void onMailMessageReceived(Message message) throws Exception {
        logger.info("received message: " + message);
        if (message instanceof TextMessage) {
            // 方法参数是JMS的Message接口，我们通过强制转型为TextMessage并提取JSON，反序列化后获得自定义的JavaBean，也就获得了发送邮件所需的所有信息：
            String text = ((TextMessage) message).getText();
            MailMessage mm = objectMapper.readValue(text, MailMessage.class);
            // 向用户邮箱中发送注册邮件：
            mailService.sendRegistrationMail(mm);
        } else {
            logger.error("unable to process non-text message!");
        }
    }
}
```

```Java
// 发送消息的典型代码如下：
try {
    Connection connection = null;
    try {
        // 创建连接:
        connection = connectionFactory.createConnection();
        // 创建会话:
        Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
        // 创建一个Producer并关联到某个Queue:
        MessageProducer messageProducer = session.createProducer(queue);
        // 创建一个文本消息:
        TextMessage textMessage = session.createTextMessage(text);
        // 发送消息:
        messageProducer.send(textMessage);
    } finally {
        // 关闭连接:
        if (connection != null) {
            connection.close();
        }
    }
} catch (JMSException ex) {
    // 处理JMS异常
}

// Spring处理JMS消息的流程:
// 创建JMS连接:
Connection connection = connectionFactory.createConnection();
// 创建会话:
Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
// 创建一个Consumer:
MessageConsumer consumer = session.createConsumer(queue);
// 为Consumer指定一个消息处理器:
consumer.setMessageListener(new MessageListener() {
    public void onMessage(Message message) {
        // 在此处理消息...
    }
});
// 启动接收消息的循环:
connection.start();
```

我们自己编写的MailMessageListener.onMailMessageReceived()相当于**消息处理器**：

```Java
consumer.setMessageListener(new MessageListener() {
    public void onMessage(Message message) {
        mailMessageListener.onMailMessageReceived(message);
    }
});
```

所以，Spring根据AppConfig的注解@EnableJms自动扫描带有@JmsListener的Bean方法，**并为其创建一个MessageListener把它包装起来**。

注意到前面我们还创建了一个JmsListenerContainerFactory的Bean，它的作用就是**为每个MessageListener创建MessageConsumer并启动消息接收循环**。

再注意到@JmsListener还有一个concurrency参数，10表示可以最多同时并发处理10个消息，5-10表示并发处理的线程可以在5-10之间调整。

因此，Spring在通过MessageListener接收到消息后，并不是直接调用mailMessageListener.onMailMessageReceived()，而是用线程池调用，因此，要时刻牢记，onMailMessageReceived()方法**可能被多线程并发执行，一定要保证线程安全**。

总结一下Spring接收消息的步骤：

通过JmsListenerContainerFactory配合@EnableJms扫描所有@JmsListener方法，自动创建MessageConsumer、MessageListener以及线程池，启动消息循环接收处理消息，最终由我们自己编写的@JmsListener方法处理消息，可能会由多线程同时并发处理，**如果应用在发送邮件的场景那就是Consumer会同时向多个用户发送注册邮件**。

**使用消息服务对上一节中启动新线程发送Email进行改造的好处是，发送Email的能力通常是有限的，通过JMS消息服务，如果短时间内需要给大量用户发送Email，可以先把消息堆积在JMS服务器上慢慢发送，对于批量发送邮件、短信等尤其有用**。

## 集成Scheduler

## 集成JMX

JMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？

为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。

实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。

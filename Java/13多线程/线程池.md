# 笔记

## 核心线程与救急线程的区别

核心线程一旦被创建就一直存在，直到线程池本身被停止。救急线程是在队列满了的情况下才会创建的线程，在执行完任务之后如果没有新的任务，那就会等待keepAliveTime时间后被销毁。

## 四大拒绝策略(当任务队列已满且活跃线程数目达到最大线程数)

1. 丢弃任务并抛出异常。推荐用于关键业务，及时发现问题。
2. 丢弃任务不抛出异常。适合于无关紧要的业务。
3. 丢弃队列最前面的任务，重新提交被拒绝的任务。根据实际业务是否允许丢弃老任务来判断。
4. 由提交任务的线程自己执行任务。这种情况就是要求所有的任务都必须执行，不允许丢弃，适合大量计算的任务类型去执行，多线程仅仅是增大了吞吐量，最终必须要让每个任务执行完毕。

## 线程池工具类提供的几个线程池

1. (newFixedThreadPool)核心线程数等于最大线程数，无超时，无界阻塞队列。适用于任务量已知，且相对耗时的任务。
2. (newCachedThreadPool)核心线程数为零，最大线程数为整型最大值，超时60S，无容量的同步队列。整个线程池表现为线程数随着任务量增长，没有上限，任务执行完毕后，等待1分钟释放线程。适合任务密集，但每个任务执行时间较短的情况。
3. (newSingleThreadExecutor)核心线程数与最大线程数都为1，无超时，无界阻塞队列。适用于希望多个任务排队执行的场景。该线程池与第一类线程池不同的地方在于，此处用了装饰器模式，只暴露了ExecutorService接口，因此无法调用ThreadPoolExecutor中特有的方法。而第一类线程池可以初始时设置为1，但后续可以通过setCorePoolSize方法进行修改。

## 自定义线程池

# 黑马视频笔记

## interrupt方法

1. interrupt方法打断正在sleep、wait、join的线程，会抛出异常，并清除打断标记；
    - 所以sonarlint推荐我们在捕获异常时，最后手动再设置一次打断标记，让其它线程知道该线程被打断了。
2. interrupt方法打断正在运行的线程，会设置打断标记；
3. interrupt方法打断正在park的线程，会设置打断标记。
    - 如果线程打断标记为true，则park方法会失效，可以使用interrupted方法清除打断标记。

## 线程的五种状态和六种状态

从操作系统层面来说，线程有五种状态：

1. 创建；
2. 就绪；
3. 运行；
4. 阻塞；
5. 结束。

从Java层面来说，线程有六种状态：

1. NEW；
2. RUNNABLE；
    - Java API层面的RUNNABLE状态涵盖了操作系统层面的【就绪】、【运行】、【阻塞】状态。
    - 比如由于BIO导致的线程阻塞，在Java里无法区分，仍然认为是RUNNABLE。
3. TERMINATED；
4. BLCOKED；
5. WAITING；
6. TIMED_WAITING。

## monitor

每个Java对象都可以关联一个monitor对象，如果使用syn给对象上锁之后，该对象头的mark word中标志位会被设置为10，剩余的位数则被设置为指向monitor对象的指针。

monitor对象包含以下三个部分：

1. waitset；
    - 这是获得了锁，但因为条件不满足而进入**WAITING**状态，比如调用了wait方法。
2. entrylist；
    - 后续想要获得锁的对象会进入该集合，置为**BLOCKED**状态。
    - 当持有锁的线程释放锁时，会唤醒该集合中的所有线程来竞争锁，竞争是非公平的，**可能一个不在集合中又刚好想要加锁的线程获得了锁**。
3. owner。
    - 置为当前持有锁的线程。

**以上这些规则基于这些线程都是进入同一个对象的monitor才有效**。

对应到字节码层面就是，会执行`monitorenter`将锁对象的mark word置为monitor指针，执行`monitorexit`将锁对象的mark word重置，唤醒entrylist。方法级别的syn不会在字节码指令中有所体现。

## syn原理进阶

因为syn底层涉及操作系统的mutex lock互斥锁，该操作会将线程挂起，进行互斥操作修改，随后唤醒该线程，因为挂起、唤醒涉及到了线程的状态切换，又因为Java线程映射于操作系统的内核线程之上，因此状态切换需要耗费CPU时间，增加CPU开销。

**有的时候对于一个简单的同步代码块，状态切换比起本身执行所需要耗费的处理器时间还要更多**。

### 无锁

### 偏向锁

mark word此时存放的是线程ID，在对象已经计算hashcode的情况下，无法进入偏向状态，因为此时没有额外的数据结构来存放mark word原来的内容。

**它仅在第一次设置线程ID时需要借助CAS操作，往后则可以直接进行检查**。

偏向状态撤销：

- 计算对象hashcode，**并且之后再也无法进入偏向状态**；
- 其它对象竞争时，会根据当前对象是否锁定，恢复为无锁或者升级为轻量级锁；
    - 一开始后三位为101，表示可偏向，因此A线程加锁时，直接利用CAS操作将A线程ID放到mark word中；
    - A线程解锁后，mark word仍然会保留线程A的ID；
    - 线程B此时发现mark word仍为101，但是线程ID并非自己，因此 将标志位改为00，进入轻量级锁加锁过程；
    - 线程B解锁之后将后三位修改为001，表示此时为无锁状态(不可偏向状态)。
- 调用wait/notify；
    - 该机制只有在重量级锁下才可进行，直接撤销偏向状态，标志位改为10。

场景：线程A对30个对象进行加锁并解锁，随后线程B对这30个对象也进行加锁并解锁，双方没有发生竞争。

批量重偏向：

- 一开始这30个对象的后三位都为101，表示可偏向，因此线程A将自己的ID放到这30个对象的mark word中；
- B线程比对线程ID发现不是自己，因此将标志位改为00，进入轻量级加锁过程，解锁后将后三位修改为001，表示无锁(不可偏向)；
- B线程在进行到**第20个**对象的加锁时，由于触发批量重偏向的阈值，此时直接将此对象mark word中的线程ID设为自己，表示B线程此时对该对象施加了偏向锁；
- 之后剩余的所有对象皆采用此操作，**这是因为JVM认为这些原本偏向线程A的对象实际上应该偏向B线程，因此在后续再遇到持有A线程ID的对象时，B线程的加锁依然会采取偏向锁的形式，将线程ID从A线程改为B线程**。

场景：线程A对39个对象进行加锁并解锁，随后线程B对这39个对象也进行加锁并解锁，最后线程C对这39个对象进行加锁并解锁，三方没有发生竞争。

批量撤销：

- A线程给39个对象mark word中放入自己的线程ID；
- B线程对前19个对象进行轻量级锁加锁，解锁后置为不可偏向状态，剩下20个对象则是将自己的线程ID替换原来的线程ID。
- C线程对前19个对象进行轻量级锁加锁(001->X00)，对剩下20个对象进行轻量级锁加锁，解锁后置为不可偏向状态(101->001)。

由于上述该类对象的总撤销次数(101->X00->001)到达了**40次，于是整个类对应的所有对象都会变为不可偏向，即使是新建对象**。

### 轻量级锁

mark word此时存放的是加锁线程栈帧中lock record的地址，lock record里存放着mark word原来的内容，并且lock record会反过来指向该对象。

**它每次加锁解锁都需要进行CAS操作，即使在当前线程发生锁重入时，依然需要进行**。

- 首先在线程栈帧中创建一个lock record空间，拷贝当前mark word到该空间中；
- 通过CAS操作将mark word更新为指向lock record的指针，并将lock record中的owner指针指向对象的mark word；
    - 操作成功，表示当前线程持有该对象的锁，将对象mark word标志位设为“00”；
    - 操作失败，检查对象mark word是否指向当前线程的栈帧，是表明当前对象已经持有对象的锁，直接进入代码块执行；
    - 如果对象mark word没有指针当前线程的栈帧，若当前只有一个等待线程，则该线程会通过自旋进行等待；
    - 当自旋超过一定次数，或者一个对象持有锁，一个在自旋，又有第三个线程来访时，轻量级锁升级为重量级锁。

B线程轻量级锁失败到重量级锁的升级过程：

- 申请monitor锁，将mark word原本存放轻量锁的地址改为monitor的地址；
- 将monitor的owner指针指向A线程，而B线程自己进入entrylist进行等待；
- A线程运行结束，使用CAS将lock record中mark word的值恢复给对象头，**失败**；
- 按照此时对象mark word中monitor地址找到monitor，将owner置为空，唤醒B线程。

### 重量级锁

mark word此时存放的是monitor的地址，monitor里存放着mark word原来的内容，并且monitor会指向加锁线程。

### 锁消除

**是指虚拟机即时编译器在运行时检测到某段需要同步的代码根本不可能存在共享数据竞争而实施的一种对锁进行消除的优化策略**。

比如在JDK5之前，对字符串的拼接操作在编译后会被转化为StringBuffer对象的连续append操作：

```java
// JDK5之前:
public String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
// 编译后:
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

而StringBuffer的append操作中恰恰含有一个同步块，锁就是对象本身。

经过逃逸分析后发现它的动态作用域被限制在方法内部，其它线程无法对其进行访问。

虽然有锁，但可以安全地消除锁。

**在解释执行时这里仍然会加锁，但在服务端编译器地即时编译之后，这段代码就会忽略所有的同步措施直接执行**。

### 锁粗化

一般原则是，锁的粒度越小越好，一方面是为了减少同步的操作数量，一方面是为了等待锁的线程能尽快获得锁。

**但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之内，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能开销**。

比如上述锁消除的例子，虚拟机探测到这些操作都是对同一个对象加锁，**就会把加锁同步的范围扩展到整个操作序列的外部，即第一个append操作之前直至最后一个append操作之后，这样仅需加锁一次**。

## 定位死锁

1. 用jconsole工具；
2. 用jps定位进程id，然后用jstack定位死锁。

## ReentrantLock

相比syn，具备如下特点：

- 可打断；
- 可超时；
- 可公平；
- 支持多个条件变量。
    - syn不满足条件的线程都在一个waitset上等待；
    - rl相当于支持多个waitset。

## Java内存模型

JMM体现在：

- 原子性-保证指令不会受到线程上下文切换的影响；
- 可见性-保证指令不会受CPU缓存的影响；
- 有序性-保证指令不会受CPU指令并行优化的影响。

**线程操作volatile变量都是直接操作主存**。

volatile能保证可见性，但不能保证原子性，比如著名的“i++和i--”问题，从字节码角度出发，volatile能保证`getstatic`和`putstatic`这两个获取和存入的指令是在主存上进行，**但它不能保证两个线程的所有指令是否会出现交错**。

syn代码块可以保证代码块的原子性也可以保证代码块内变量的可见性。

### 内存屏障

- 可见性
    - 写屏障保证在该屏障之前的，对共享变量的改动，都同步到主存之中；
    - 读屏障保证在该屏障之后的，对共享变量的读取，加载的是主存中最新数据。
- 有序性
    - 写屏障会确保指令重排时，不会将写屏障之前的代码排在屏障之后(之前的不会到之后)；
    - 读屏障会确保指令重排时，不会将读屏障之后的代码排序屏障之前(之后的不会到之前)。

### 指令重排

JVM会在不影响正确性的前提下，尝试调整语句的执行顺序，这被称为【指令重排】，而在多线程下【指令重排】会影响正确性。

【指令重排】的原因：

- 现代CPU支持多级指令流水线，一条指令执行被分为【取指-译码-执行-访存-写回】等阶段；
- 能同时执行上述阶段的，称之为【五级指令流水线】，这是CPU可以在一个时钟周期内，运行五条指令的不同阶段；
- **流水线不能缩短指令的执行时间，但变相提高了指令的吞吐率**；
- **因此尝试优化一些指令顺序(不同指令的每个阶段的执行时间可能不同)，使这些指令的不同阶段可以流水并行是关键**。

### volatile保证可见性和有序性的原理

前提：

- **对volatile变量的写指令之后都会加入写屏障**；
- **对volatile变量的读指令之前都会加入读屏障**。

可见性：

- 写屏障保证在该屏障之前的，对共享变量的改动，都同步到主存之中；
- 读屏障保证在该屏障之后的，对共享变量的读取，加载的是主存中最新数据。

有序性：

- 写屏障会确保指令重排时，不会将写屏障之前的代码排在屏障之后(写屏障，之前的不会到之后)；
- 读屏障会确保指令重排时，不会将读屏障之后的代码排序屏障之前(读屏障，之后的不会到之前)。

不能保证原子性，即不能解决指令交错：

- **写屏障仅仅是保证之后的读能读最新的结果，但不能保证读跑到它前面去**；
- **有序性的保证也只是保证【本线程】执行相关代码不被重排序**。
